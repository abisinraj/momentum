<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0;
            background-color: transparent;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

        let camera, scene, renderer;
        let group, particles, linesMesh;

        // Configuration
        const PARTICLE_COUNT = 1800;
        const CONNECTIVITY_DISTANCE = 15;
        const COLOR_PRIMARY = 0x00D9B8; // Teal
        const COLOR_SECONDARY = 0xFFFFFF; // White

        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 400;
            camera.position.y = 50; // Look slightly down/center

            // Group
            group = new THREE.Group();
            scene.add(group);

            // --- ANATOMY GENERATION ---
            const musclePoints = [];
            const colors = [];
            const c1 = new THREE.Color(COLOR_PRIMARY);
            const c2 = new THREE.Color(COLOR_SECONDARY);

            // Helper: Create a muscle between two points
            function createMuscle(start, end, count, radius, bulge = 1.0) {
                const curve = new THREE.LineCurve3(start, end);

                for (let i = 0; i < count; i++) {
                    const t = Math.random();
                    // Get point on line
                    const point = curve.getPoint(t);

                    // Calculate thickness (bulge in middle, taper at ends)
                    // Parabola: 4 * t * (1-t) gives 0 at ends, 1 at center
                    const shapeFactor = 4 * t * (1 - t);
                    const r = radius * (0.5 + 0.5 * shapeFactor * bulge);

                    // Random offset in sphere
                    const u = Math.random();
                    const v = Math.random();
                    const theta = 2 * Math.PI * u;
                    const phi = Math.acos(2 * v - 1);

                    const x = point.x + r * Math.sin(phi) * Math.cos(theta);
                    const y = point.y + r * Math.sin(phi) * Math.sin(theta);
                    const z = point.z + r * Math.cos(phi); // Flatten Z slightly for muscles? No, keep round for now.

                    musclePoints.push(x, y, z);

                    // Color mix
                    const mixColor = c1.clone().lerp(c2, Math.random() * 0.6); // Mostly primary
                    colors.push(mixColor.r, mixColor.g, mixColor.b);
                }
            }

            // --- SKELETON DEFINITION (Simple Approx) ---
            const headCenter = new THREE.Vector3(0, 165, 0);
            const neck = new THREE.Vector3(0, 150, 0);
            const shoulderL = new THREE.Vector3(-45, 145, 0);
            const shoulderR = new THREE.Vector3(45, 145, 0);
            const elbowL = new THREE.Vector3(-65, 105, 10);
            const elbowR = new THREE.Vector3(65, 105, 10);
            const handL = new THREE.Vector3(-75, 70, 20);
            const handR = new THREE.Vector3(75, 70, 20);

            const spineTop = new THREE.Vector3(0, 145, -5);
            const spineMid = new THREE.Vector3(0, 120, -10);
            const spineBase = new THREE.Vector3(0, 100, -5);
            const hipL = new THREE.Vector3(-25, 95, 0);
            const hipR = new THREE.Vector3(25, 95, 0);

            const kneeL = new THREE.Vector3(-30, 50, 10);
            const kneeR = new THREE.Vector3(30, 50, 10);
            const ankleL = new THREE.Vector3(-30, 5, 0);
            const ankleR = new THREE.Vector3(30, 5, 0);
            const footL = new THREE.Vector3(-30, 0, 15);
            const footR = new THREE.Vector3(30, 0, 15);

            // --- MUSCLE GROUPS ---

            // Head & Neck
            createMuscle(headCenter, new THREE.Vector3(0, 185, 0), 150, 22, 0.2); // Cranium
            createMuscle(new THREE.Vector3(0, 150, 0), headCenter, 80, 12, 0.5); // Neck

            // Torso
            createMuscle(shoulderL, shoulderR, 100, 10, 0.2); // Clavicles
            createMuscle(shoulderL, hipL, 120, 15, 1.5); // Lats/Obliques L
            createMuscle(shoulderR, hipR, 120, 15, 1.5); // Lats/Obliques R
            createMuscle(spineTop, spineBase, 150, 18, 1.2); // Spine/Back
            createMuscle(new THREE.Vector3(-15, 140, 10), new THREE.Vector3(-10, 100, 12), 100, 15, 1.0); // Pecs/Abs L
            createMuscle(new THREE.Vector3(15, 140, 10), new THREE.Vector3(10, 100, 12), 100, 15, 1.0); // Pecs/Abs R

            // Arms
            createMuscle(shoulderL, elbowL, 90, 12, 1.8); // Bicep/Tricep L
            createMuscle(shoulderR, elbowR, 90, 12, 1.8); // Bicep/Tricep R
            createMuscle(elbowL, handL, 70, 9, 1.4); // Forearm L
            createMuscle(elbowR, handR, 70, 9, 1.4); // Forearm R

            // Legs
            createMuscle(hipL, kneeL, 130, 16, 1.8); // Quads/Hams L
            createMuscle(hipR, kneeR, 130, 16, 1.8); // Quads/Hams R
            createMuscle(kneeL, ankleL, 90, 11, 1.6); // Calves L
            createMuscle(kneeR, ankleR, 90, 11, 1.6); // Calves R
            createMuscle(ankleL, footL, 40, 8, 1.0); // Foot L
            createMuscle(ankleR, footR, 40, 8, 1.0); // Foot R

            // --- BUILD GEOMETRY ---
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(musclePoints, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            // Particles Material
            const pMaterial = new THREE.PointsMaterial({
                size: 3,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            particles = new THREE.Points(geometry, pMaterial);
            group.add(particles);

            // --- CONNECTIVITY (The "Plexus" Lines) ---
            // Calculate connections once (static mesh for performance)
            const linePositions = [];
            const lineColors = [];
            // Optimize: simple n^2 check is fine for < 2000 points once at startup
            const pos = geometry.attributes.position.array;
            const thresholdSq = CONNECTIVITY_DISTANCE * CONNECTIVITY_DISTANCE;

            // Limit connections to avoid over-drawing
            const maxConnections = 6;

            for (let i = 0; i < musclePoints.length / 3; i++) {
                const x1 = pos[i * 3];
                const y1 = pos[i * 3 + 1];
                const z1 = pos[i * 3 + 2];
                let connections = 0;

                // Look at a subset of other points to save time? 
                // Just doing full check for quality, it runs once.
                for (let j = i + 1; j < musclePoints.length / 3; j++) {
                    const x2 = pos[j * 3];
                    const y2 = pos[j * 3 + 1];
                    const z2 = pos[j * 3 + 2];

                    const dx = x1 - x2;
                    const dy = y1 - y2;
                    const dz = z1 - z2;
                    const distSq = dx * dx + dy * dy + dz * dz;

                    if (distSq < thresholdSq) {
                        linePositions.push(x1, y1, z1);
                        linePositions.push(x2, y2, z2);

                        // Faint line color
                        lineColors.push(c1.r, c1.g, c1.b); // Start teal
                        lineColors.push(c1.r, c1.g, c1.b); // End teal

                        connections++;
                        if (connections >= maxConnections) break;
                    }
                }
            }

            const lineGeo = new THREE.BufferGeometry();
            lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
            lineGeo.setAttribute('color', new THREE.Float32BufferAttribute(lineColors, 3));

            const lineMat = new THREE.LineBasicMaterial({
                vertexColors: true,
                transparent: true,
                opacity: 0.15, // Very faint connections
                blending: THREE.AdditiveBlending
            });

            linesMesh = new THREE.LineSegments(lineGeo, lineMat);
            group.add(linesMesh);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Interaction
            window.addEventListener('resize', onWindowResize);

            // Input handling
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            const onDown = (x, y) => {
                isDragging = true;
                previousMousePosition = { x, y };
            };

            const onMove = (x, y) => {
                if (isDragging) {
                    const deltaX = x - previousMousePosition.x;
                    const deltaY = y - previousMousePosition.y;
                    group.rotation.y += deltaX * 0.005;
                    group.rotation.x += deltaY * 0.005;
                    previousMousePosition = { x, y };
                }
            };

            const onUp = () => isDragging = false;

            // Touch events
            document.addEventListener('touchstart', e => onDown(e.touches[0].clientX, e.touches[0].clientY));
            document.addEventListener('touchmove', e => onMove(e.touches[0].clientX, e.touches[0].clientY));
            document.addEventListener('touchend', onUp);

            // Mouse events
            document.addEventListener('mousedown', e => onDown(e.clientX, e.clientY));
            document.addEventListener('mousemove', e => onMove(e.clientX, e.clientY));
            document.addEventListener('mouseup', onUp);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Slow auto-rotation
            group.rotation.y += 0.002;

            // Breathing animation
            const time = Date.now() * 0.002;
            const scale = 1 + Math.sin(time) * 0.005;
            group.scale.set(scale, scale, scale);

            renderer.render(scene, camera);
        }
    </script>
</body>

</html>