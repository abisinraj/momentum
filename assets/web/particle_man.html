<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Momentum 3D Recovery Tracker</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Inter', sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            pointer-events: none;
        }

        h1 {
            margin: 0;
            font-weight: 300;
            letter-spacing: 2px;
            font-size: 1.5rem;
            text-transform: uppercase;
        }

        .subtitle {
            color: #888;
            font-size: 0.8rem;
            margin-top: 5px;
        }

        #info-card {
            position: absolute;
            bottom: 40px;
            right: 40px;
            width: 280px;
            background: rgba(10, 10, 10, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 24px;
            color: white;
            display: none;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s, transform 0.3s;
        }

        #info-card.visible {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 16px;
        }

        .muscle-title {
            font-size: 1.2rem;
            font-weight: 700;
        }

        .status-badge {
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.7rem;
            font-weight: 700;
            text-transform: uppercase;
        }

        .status-fresh {
            background: rgba(0, 255, 128, 0.15);
            color: #00ff80;
            border: 1px solid rgba(0, 255, 128, 0.3);
        }

        .status-recovering {
            background: rgba(255, 170, 0, 0.15);
            color: #ffaa00;
            border: 1px solid rgba(255, 170, 0, 0.3);
        }

        .status-sore {
            background: rgba(255, 50, 50, 0.15);
            color: #ff3232;
            border: 1px solid rgba(255, 50, 50, 0.3);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .stat-label {
            color: #888;
        }

        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #444;
            font-size: 0.8rem;
            letter-spacing: 1px;
        }
    </style>

    <!-- Load Three.js Global Scripts (No Modules) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>

<body>
    <div id="canvas-container"></div>
    <div id="hud">
        <h1>Anatomy of Momentum</h1>
        <div class="subtitle">Interactive Recovery Visualization</div>
    </div>
    <div id="loader">INITIALIZING ANATOMICAL RIG...</div>

    <div id="info-card">
        <div class="card-header">
            <div class="muscle-title" id="card-title">Chest</div>
            <div class="status-badge status-fresh" id="card-status">Fresh</div>
        </div>
        <div class="stat-row">
            <span class="stat-label">Recovery Score</span>
            <span class="stat-value" id="card-score">92%</span>
        </div>
    </div>

    <script>
        // Main Logic
        // Strict Proportional Humanoid Generator
        const PARTICLE_COUNT = 20000;
        const PARTICLE_SIZE = 0.02;
        const COLORS = {
            FRESH: new THREE.Color(0x00ff80),
            RECOVERING: new THREE.Color(0xffaa00),
            SORE: new THREE.Color(0xff3232),
            NEUTRAL: new THREE.Color(0x8888aa)
        };

        // Global State
        var scene, camera, renderer, controls, raycaster;
        var particles, geometry, material;
        var selectedMuscle = null;
        var clock = new THREE.Clock();
        var mouse = new THREE.Vector2();

        var particlePositions = [];
        var particleColors = [];
        var particleSizes = [];
        var particleAttributes = {
            muscleName: [],
            originalPos: []
        };

        const MUSCLE_DATA = {
            'Chest': { recovery: 95 },
            'Back': { recovery: 85 },
            'Shoulders': { recovery: 45 },
            'Biceps': { recovery: 60 },
            'Triceps': { recovery: 60 },
            'Abs': { recovery: 92 },
            'Quads': { recovery: 100 },
            'Hamstrings': { recovery: 100 },
            'Calves': { recovery: 100 },
            'Glutes': { recovery: 90 },
            'Traps': { recovery: 70 },
            'Forearms': { recovery: 80 },
            'Head': { recovery: 100 }
        };

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.10);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.1, 3.5);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxDistance = 6;
            controls.minDistance = 1;
            controls.target.set(0, 1.0, 0);

            raycaster = new THREE.Raycaster();
            raycaster.params.Points.threshold = 0.08;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            generateFitBody();

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('click', onMouseClick);

            document.getElementById('loader').style.display = 'none';
        }

        // --- Generators ---
        function getPointInSphere(r) {
            const u = Math.random(), v = Math.random();
            const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
            const rad = Math.cbrt(Math.random()) * r;
            return { x: rad * Math.sin(phi) * Math.cos(theta), y: rad * Math.sin(phi) * Math.sin(theta), z: rad * Math.cos(phi) };
        }

        function getPointInFrustum(rTop, rBottom, height) {
            const y = (Math.random() - 0.5) * height;
            const t = (y + height / 2) / height;
            const r = rBottom + (rTop - rBottom) * t;
            const angle = Math.random() * 2 * Math.PI;
            const dist = Math.sqrt(Math.random()) * r;
            return { x: dist * Math.cos(angle), y: y, z: dist * Math.sin(angle) };
        }

        function getPointInEllipsoid(rx, ry, rz) {
            const p = getPointInSphere(1);
            return { x: p.x * rx, y: p.y * ry, z: p.z * rz };
        }

        function addVolume(name, count, generator, pos, rot = { x: 0, y: 0, z: 0 }) {
            const muscle = MUSCLE_DATA[name] || { recovery: 100 };
            let baseColor;
            if (muscle.recovery >= 90) baseColor = COLORS.FRESH;
            else if (muscle.recovery >= 60) baseColor = COLORS.RECOVERING;
            else baseColor = COLORS.SORE;

            for (let i = 0; i < count; i++) {
                let p = generator();

                if (rot.z) {
                    const x = p.x * Math.cos(rot.z) - p.y * Math.sin(rot.z);
                    const y = p.x * Math.sin(rot.z) + p.y * Math.cos(rot.z);
                    p.x = x; p.y = y;
                }
                if (rot.x) {
                    const y = p.y * Math.cos(rot.x) - p.z * Math.sin(rot.x);
                    const z = p.y * Math.sin(rot.x) + p.z * Math.cos(rot.x);
                    p.y = y; p.z = z;
                }
                if (rot.y) {
                    const x = p.x * Math.cos(rot.y) - p.z * Math.sin(rot.y);
                    const z = p.x * Math.sin(rot.y) + p.z * Math.cos(rot.y);
                    p.x = x; p.z = z;
                }

                p.x += pos.x; p.y += pos.y; p.z += pos.z;

                particlePositions.push(p.x, p.y, p.z);
                particleColors.push(baseColor.r, baseColor.g, baseColor.b);
                particleSizes.push(PARTICLE_SIZE * (0.5 + Math.random()));

                particleAttributes.muscleName.push(name);
                particleAttributes.originalPos.push(p.x, p.y, p.z);
            }
        }

        function generateFitBody() {
            // Reset
            particlePositions = []; particleColors = []; particleSizes = [];
            particleAttributes.muscleName = []; particleAttributes.originalPos = [];

            // ANATOMY CONFIGURATION (8 Heads Rule)
            // 1 Head Unit = 0.22 meters (approx)
            const H = 0.22;

            // --- 1. HEAD & NECK ---
            // Head (Ovoid)
            addVolume('Head', 1000, () => getPointInEllipsoid(H * 0.65, H * 0.8, H * 0.75), { x: 0, y: 1.76, z: 0 });
            // Neck (Cylinder)
            addVolume('Traps', 300, () => getPointInFrustum(H * 0.3, H * 0.35, H * 0.6), { x: 0, y: 1.6, z: 0 });
            // Traps Slopes
            addVolume('Traps', 400, () => getPointInFrustum(0.04, 0.08, 0.25), { x: -H * 0.5, y: 1.58, z: 0 }, { z: -0.6 });
            addVolume('Traps', 400, () => getPointInFrustum(0.04, 0.08, 0.25), { x: H * 0.5, y: 1.58, z: 0 }, { z: 0.6 });

            // --- 2. TORSO (V-Taper) ---
            // Shoulders (Deltoids)
            addVolume('Shoulders', 700, () => getPointInSphere(H * 0.65), { x: -H * 1.1, y: 1.52, z: 0 });
            addVolume('Shoulders', 700, () => getPointInSphere(H * 0.65), { x: H * 1.1, y: 1.52, z: 0 });

            // Chest (Pecs)
            addVolume('Chest', 1000, () => getPointInEllipsoid(H * 0.9, H * 0.7, H * 0.3), { x: -H * 0.5, y: 1.42, z: H * 0.3 }, { z: 0.1, y: 0.2 });
            addVolume('Chest', 1000, () => getPointInEllipsoid(H * 0.9, H * 0.7, H * 0.3), { x: H * 0.5, y: 1.42, z: H * 0.3 }, { z: -0.1, y: -0.2 });

            // Upper Back (Lats Wings)
            addVolume('Back', 1200, () => getPointInFrustum(H * 1.3, H * 0.7, H * 2.0), { x: 0, y: 1.3, z: -H * 0.2 });

            // Abs (6-pack Segmented)
            addVolume('Abs', 400, () => getPointInEllipsoid(H * 0.5, H * 0.25, H * 0.2), { x: 0, y: 1.25, z: H * 0.4 });
            addVolume('Abs', 400, () => getPointInEllipsoid(H * 0.48, H * 0.25, H * 0.2), { x: 0, y: 1.12, z: H * 0.4 });
            addVolume('Abs', 400, () => getPointInEllipsoid(H * 0.45, H * 0.3, H * 0.2), { x: 0, y: 0.98, z: H * 0.45 });

            // Obliques
            addVolume('Abs', 500, () => getPointInFrustum(H * 0.3, H * 0.4, H * 1.5), { x: -H * 0.7, y: 1.1, z: H * 0.3 });
            addVolume('Abs', 500, () => getPointInFrustum(H * 0.3, H * 0.4, H * 1.5), { x: H * 0.7, y: 1.1, z: H * 0.3 });

            // --- 3. ARMS ---
            // Biceps (Upper Arm Front)
            addVolume('Biceps', 500, () => getPointInEllipsoid(H * 0.35, H * 0.7, H * 0.35), { x: -H * 1.3, y: 1.25, z: H * 0.1 });
            addVolume('Biceps', 500, () => getPointInEllipsoid(H * 0.35, H * 0.7, H * 0.35), { x: H * 1.3, y: 1.25, z: H * 0.1 });
            // Triceps (Upper Arm Back)
            addVolume('Triceps', 500, () => getPointInEllipsoid(H * 0.3, H * 0.65, H * 0.3), { x: -H * 1.3, y: 1.28, z: -H * 0.15 });
            addVolume('Triceps', 500, () => getPointInEllipsoid(H * 0.3, H * 0.65, H * 0.3), { x: H * 1.3, y: 1.28, z: -H * 0.15 });
            // Elbows
            addVolume('Forearms', 200, () => getPointInSphere(H * 0.25), { x: -H * 1.4, y: 1.0, z: 0 });
            addVolume('Forearms', 200, () => getPointInSphere(H * 0.25), { x: H * 1.4, y: 1.0, z: 0 });
            // Forearms
            addVolume('Forearms', 600, () => getPointInFrustum(H * 0.32, H * 0.2, H * 1.2), { x: -H * 1.5, y: 0.7, z: 0 }, { z: 0.1 });
            addVolume('Forearms', 600, () => getPointInFrustum(H * 0.32, H * 0.2, H * 1.2), { x: H * 1.5, y: 0.7, z: 0 }, { z: -0.1 });

            // --- 4. LOWER BODY ---
            // Hips/Glutes
            addVolume('Glutes', 800, () => getPointInEllipsoid(H * 0.8, H * 0.5, H * 0.6), { x: 0, y: 0.9, z: 0 }); // Center
            addVolume('Glutes', 600, () => getPointInSphere(H * 0.6), { x: -H * 0.4, y: 0.85, z: -H * 0.3 }); // Left Cheek
            addVolume('Glutes', 600, () => getPointInSphere(H * 0.6), { x: H * 0.4, y: 0.85, z: -H * 0.3 }); // Right Cheek

            // Thighs (Quads/Hams)
            addVolume('Quads', 800, () => getPointInFrustum(H * 0.6, H * 0.4, H * 1.8), { x: -H * 0.6, y: 0.55, z: H * 0.1 }, { z: -0.05 });
            addVolume('Quads', 800, () => getPointInFrustum(H * 0.6, H * 0.4, H * 1.8), { x: H * 0.6, y: 0.55, z: H * 0.1 }, { z: 0.05 });
            addVolume('Hamstrings', 600, () => getPointInFrustum(H * 0.55, H * 0.35, H * 1.8), { x: -H * 0.6, y: 0.55, z: -H * 0.2 }, { z: -0.05 });
            addVolume('Hamstrings', 600, () => getPointInFrustum(H * 0.55, H * 0.35, H * 1.8), { x: H * 0.6, y: 0.55, z: -H * 0.2 }, { z: 0.05 });

            // Knees
            addVolume('Quads', 300, () => getPointInSphere(H * 0.35), { x: -H * 0.65, y: 0.15, z: 0.05 });
            addVolume('Quads', 300, () => getPointInSphere(H * 0.35), { x: H * 0.65, y: 0.15, z: 0.05 });

            // Calves
            addVolume('Calves', 700, () => getPointInEllipsoid(H * 0.35, H * 0.6, H * 0.35), { x: -H * 0.7, y: -0.2, z: -0.05 }); // Muscle
            addVolume('Calves', 400, () => getPointInFrustum(H * 0.25, H * 0.15, H * 1.5), { x: -H * 0.7, y: -0.3, z: 0 }); // Shin
            addVolume('Calves', 700, () => getPointInEllipsoid(H * 0.35, H * 0.6, H * 0.35), { x: H * 0.7, y: -0.2, z: -0.05 });
            addVolume('Calves', 400, () => getPointInFrustum(H * 0.25, H * 0.15, H * 1.5), { x: H * 0.7, y: -0.3, z: 0 });

            // Feet
            addVolume('Calves', 300, () => getPointInEllipsoid(H * 0.3, H * 0.15, H * 0.6), { x: -H * 0.8, y: -0.75, z: H * 0.3 });
            addVolume('Calves', 300, () => getPointInEllipsoid(H * 0.3, H * 0.15, H * 0.6), { x: H * 0.8, y: -0.75, z: H * 0.3 });

            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(particlePositions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(particleColors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(particleSizes, 1));

            material = new THREE.PointsMaterial({
                size: PARTICLE_SIZE, vertexColors: true, transparent: true, opacity: 0.9,
                sizeAttenuation: true, blending: THREE.AdditiveBlending
            });
            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            const planeGeo = new THREE.PlaneGeometry(3, 3);
            const planeMat = new THREE.MeshBasicMaterial({ color: 0x222222, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
            const plane = new THREE.Mesh(planeGeo, planeMat);
            plane.rotation.x = Math.PI / 2;
            plane.position.y = -0.8;
            scene.add(plane);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }
        function onMouseClick(event) {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(particles);
            if (intersects.length > 0) {
                const name = particleAttributes.muscleName[intersects[0].index];
                if (name) selectMuscle(name);
            } else resetView();
        }

        function selectMuscle(name) {
            if (selectedMuscle === name) return;
            selectedMuscle = name;

            const colors = geometry.attributes.color.array;
            for (let i = 0; i < particleAttributes.muscleName.length; i++) {
                const mName = particleAttributes.muscleName[i];
                const muscle = MUSCLE_DATA[mName] || { recovery: 100 };
                let baseColor = (muscle.recovery >= 90) ? COLORS.FRESH : (muscle.recovery >= 60 ? COLORS.RECOVERING : COLORS.SORE);

                if (mName === name) {
                    colors[i * 3] = baseColor.r * 1.5; colors[i * 3 + 1] = baseColor.g * 1.5; colors[i * 3 + 2] = baseColor.b * 1.5;
                } else {
                    colors[i * 3] = baseColor.r * 0.1; colors[i * 3 + 1] = baseColor.g * 0.1; colors[i * 3 + 2] = baseColor.b * 0.1;
                }
            }
            geometry.attributes.color.needsUpdate = true;

            const card = document.getElementById('info-card');
            const data = MUSCLE_DATA[name];
            document.getElementById('card-title').innerText = name;
            document.getElementById('card-score').innerText = data.recovery + "%";
            const badge = document.getElementById('card-status');
            badge.innerText = data.recovery >= 90 ? "Fresh" : (data.recovery >= 60 ? "Recovering" : "Sore");
            badge.className = "status-badge " + (data.recovery >= 90 ? "status-fresh" : (data.recovery >= 60 ? "status-recovering" : "status-sore"));
            card.className = "visible";

            let sumX = 0, sumY = 0, sumZ = 0, count = 0;
            for (let i = 0; i < particleAttributes.muscleName.length; i++) {
                if (particleAttributes.muscleName[i] === name) {
                    sumX += particleAttributes.originalPos[i * 3];
                    sumY += particleAttributes.originalPos[i * 3 + 1];
                    sumZ += particleAttributes.originalPos[i * 3 + 2];
                    count++;
                }
            }
            if (count) {
                const t = { x: sumX / count, y: sumY / count, z: sumZ / count };
                new TWEEN.Tween(camera.position).to({ x: t.x, y: t.y, z: t.z + 1.2 }, 1000).easing(TWEEN.Easing.Cubic.Out).start();
                new TWEEN.Tween(controls.target).to(t, 1000).easing(TWEEN.Easing.Cubic.Out).start();
            }
        }

        function resetView() {
            selectedMuscle = null;
            document.getElementById('info-card').className = "";
            const colors = geometry.attributes.color.array;
            for (let i = 0; i < particleAttributes.muscleName.length; i++) {
                const mName = particleAttributes.muscleName[i];
                const muscle = MUSCLE_DATA[mName] || { recovery: 100 };
                let baseColor = (muscle.recovery >= 90) ? COLORS.FRESH : (muscle.recovery >= 60 ? COLORS.RECOVERING : COLORS.SORE);
                colors[i * 3] = baseColor.r; colors[i * 3 + 1] = baseColor.g; colors[i * 3 + 2] = baseColor.b;
            }
            geometry.attributes.color.needsUpdate = true;

            new TWEEN.Tween(camera.position).to({ x: 0, y: 1.1, z: 3.5 }, 1000).easing(TWEEN.Easing.Cubic.Out).start();
            new TWEEN.Tween(controls.target).to({ x: 0, y: 1, z: 0 }, 1000).easing(TWEEN.Easing.Cubic.Out).start();
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            if (TWEEN) TWEEN.update();
            controls.update();
            particles.rotation.y = Math.sin(time * 0.1) * 0.1;
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>