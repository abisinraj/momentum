<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Momentum 3D Recovery Tracker</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Inter', sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        /* HUD Overlay */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            pointer-events: none;
        }

        h1 {
            margin: 0;
            font-weight: 300;
            letter-spacing: 2px;
            font-size: 1.5rem;
            text-transform: uppercase;
        }

        .subtitle {
            color: #888;
            font-size: 0.8rem;
            margin-top: 5px;
        }

        /* Tooltip / Info Card */
        #info-card {
            position: absolute;
            bottom: 40px;
            right: 40px;
            width: 280px;
            background: rgba(10, 10, 10, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 24px;
            color: white;
            display: none;
            /* Hidden by default */
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        #info-card.visible {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
        }

        .muscle-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: #fff;
        }

        .status-badge {
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.7rem;
            font-weight: 700;
            text-transform: uppercase;
        }

        .status-fresh {
            background: rgba(0, 255, 128, 0.15);
            color: #00ff80;
            border: 1px solid rgba(0, 255, 128, 0.3);
        }

        .status-recovering {
            background: rgba(255, 170, 0, 0.15);
            color: #ffaa00;
            border: 1px solid rgba(255, 170, 0, 0.3);
        }

        .status-sore {
            background: rgba(255, 50, 50, 0.15);
            color: #ff3232;
            border: 1px solid rgba(255, 50, 50, 0.3);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            font-weight: 600;
        }

        .progress-bar {
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            margin-top: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #00ff80;
            width: 0%;
            transition: width 0.5s ease;
        }

        /* Loader */
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #444;
            font-size: 0.8rem;
            letter-spacing: 1px;
        }

        /* Interaction Hint */
        #hint {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #444;
            font-size: 0.8rem;
            pointer-events: none;
            opacity: 0.6;
        }
    </style>
    <!-- Import Maps Polyfill -->
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <div id="canvas-container"></div>
    <div id="hud">
        <h1>Anatomy of Momentum</h1>
        <div class="subtitle">Interactive Recovery Visualization</div>
    </div>
    <div id="loader">INITIALIZING NEURAL LINK...</div>
    <div id="hint">Click to Interact • Drag to Rotate • Scroll to Zoom</div>

    <div id="info-card">
        <div class="card-header">
            <div class="muscle-title" id="card-title">Chest</div>
            <div class="status-badge status-fresh" id="card-status">Fresh</div>
        </div>
        <div class="stat-row">
            <span class="stat-label">Recovery Score</span>
            <span class="stat-value" id="card-score">92%</span>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="card-bar"></div>
        </div>
        <br>
        <div class="stat-row">
            <span class="stat-label">Last Worked</span>
            <span class="stat-value" id="card-last">3 days ago</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Volume Load</span>
            <span class="stat-value" id="card-vol">12,400 kg</span>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TWEEN } from 'three/addons/libs/tween.module.min.js';

        // --- Configuration ---
        // --- Configuration ---
        const PARTICLE_COUNT = 15000; // Increased density
        const PARTICLE_SIZE = 0.025;  // Finer particles
        const COLORS = {
            FRESH: new THREE.Color(0x00ff80),
            RECOVERING: new THREE.Color(0xffaa00),
            SORE: new THREE.Color(0xff3232),
            NEUTRAL: new THREE.Color(0xaaaaaa)
        };

        // --- State ---
        let scene, camera, renderer, controls, raycaster;
        let particles, geometry, material;
        let selectedMuscle = null;
        let clock = new THREE.Clock();
        const mouse = new THREE.Vector2();

        // Muscle Data (Logic for colors/stats)
        const MUSCLE_DATA = {
            'Chest': { recovery: 95 },
            'Back': { recovery: 85 },
            'Shoulders': { recovery: 45 },
            'Biceps': { recovery: 60 },
            'Triceps': { recovery: 60 },
            'Abs': { recovery: 92 },
            'Quads': { recovery: 100 },
            'Hamstrings': { recovery: 100 },
            'Calves': { recovery: 100 },
            'Head': { recovery: 100 } // Just for visual
        };

        const particleAttributes = {
            muscleName: [],
            originalPos: []
        };
        const muscleNames = Object.keys(MUSCLE_DATA);

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.15);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.2, 4.0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxDistance = 6;
            controls.minDistance = 1;
            controls.target.set(0, 1.0, 0);

            raycaster = new THREE.Raycaster();
            raycaster.params.Points.threshold = 0.1;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            generateBody();

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('click', onMouseClick);

            document.getElementById('loader').style.display = 'none';
        }

        // --- Organic shape generators ---

        function getPointInSphere(radius) {
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            const r = Math.cbrt(Math.random()) * radius; // Uniform distribution
            return {
                x: r * Math.sin(phi) * Math.cos(theta),
                y: r * Math.sin(phi) * Math.sin(theta),
                z: r * Math.cos(phi)
            };
        }

        function getPointInEllipsoid(rx, ry, rz) {
            const p = getPointInSphere(1);
            return { x: p.x * rx, y: p.y * ry, z: p.z * rz };
        }

        function getPointInCylinder(radiusTop, radiusBottom, height) {
            // Simplified: interpolation between two circles
            const y = (Math.random() - 0.5) * height; // Centered at 0
            const t = (y + height / 2) / height; // 0 to 1
            const r = radiusBottom + (radiusTop - radiusBottom) * t;

            // Random point in circle at height y
            const angle = Math.random() * 2 * Math.PI;
            const dist = Math.sqrt(Math.random()) * r;

            return {
                x: dist * Math.cos(angle),
                y: y,
                z: dist * Math.sin(angle)
            };
        }

        function addMuscleShape(name, count, generatorFn, positionOffset, rotation = { x: 0, y: 0, z: 0 }) {
            const muscle = MUSCLE_DATA[name] || { recovery: 100 };

            let baseColor;
            if (muscle.recovery >= 90) baseColor = COLORS.FRESH;
            else if (muscle.recovery >= 60) baseColor = COLORS.RECOVERING;
            else baseColor = COLORS.SORE;

            for (let i = 0; i < count; i++) {
                let p = generatorFn();

                // Rotate
                // Simple Euler rotation logic needed?
                // Minimal rotation needed for T pose mostly.
                if (rotation.z !== 0) {
                    const x_new = p.x * Math.cos(rotation.z) - p.y * Math.sin(rotation.z);
                    const y_new = p.x * Math.sin(rotation.z) + p.y * Math.cos(rotation.z);
                    p.x = x_new; p.y = y_new;
                }

                // Translate
                p.x += positionOffset.x;
                p.y += positionOffset.y;
                p.z += positionOffset.z;

                particlePositions.push(p.x, p.y, p.z);
                particleColors.push(baseColor.r, baseColor.g, baseColor.b);
                particleSizes.push(PARTICLE_SIZE * (0.5 + Math.random()));

                particleAttributes.muscleName.push(name);
                particleAttributes.originalPos.push(p.x, p.y, p.z);
            }
        }

        let particlePositions = [];
        let particleColors = [];
        let particleSizes = [];

        function generateBody() {
            particlePositions = [];
            particleColors = [];
            particleSizes = [];
            particleAttributes.muscleName = [];
            particleAttributes.originalPos = [];

            // 1. HEAD (Sphere)
            addMuscleShape('Head', 800, () => getPointInSphere(0.14), { x: 0, y: 1.75, z: 0 });

            // 2. NECK (Small Cylinder)
            addMuscleShape('Back', 200, () => getPointInCylinder(0.06, 0.07, 0.15), { x: 0, y: 1.6, z: 0 });

            // 3. CHEST (Two Ellipsoids for Pecs)
            // Left Pec
            addMuscleShape('Chest', 600, () => getPointInEllipsoid(0.18, 0.14, 0.08), { x: -0.2, y: 1.45, z: 0.08 }, { z: 0.1 });
            // Right Pec
            addMuscleShape('Chest', 600, () => getPointInEllipsoid(0.18, 0.14, 0.08), { x: 0.2, y: 1.45, z: 0.08 }, { z: -0.1 });

            // 4. ABS (Vertical Cylinder stack)
            addMuscleShape('Abs', 800, () => getPointInCylinder(0.18, 0.16, 0.45), { x: 0, y: 1.1, z: 0.05 });

            // 5. SHOULDERS (Spheres)
            addMuscleShape('Shoulders', 500, () => getPointInSphere(0.13), { x: -0.5, y: 1.55, z: 0 });
            addMuscleShape('Shoulders', 500, () => getPointInSphere(0.13), { x: 0.5, y: 1.55, z: 0 });

            // 6. ARMS (Tapered Cylinders)
            // Biceps (Upper Arm)
            addMuscleShape('Biceps', 500, () => getPointInCylinder(0.11, 0.09, 0.35), { x: -0.6, y: 1.3, z: 0 }, { z: 0.2 });
            addMuscleShape('Biceps', 500, () => getPointInCylinder(0.11, 0.09, 0.35), { x: 0.6, y: 1.3, z: 0 }, { z: -0.2 });

            // Forearms
            addMuscleShape('Biceps', 400, () => getPointInCylinder(0.08, 0.06, 0.35), { x: -0.7, y: 0.95, z: 0 }, { z: 0.2 });
            addMuscleShape('Biceps', 400, () => getPointInCylinder(0.08, 0.06, 0.35), { x: 0.7, y: 0.95, z: 0 }, { z: -0.2 });

            // 7. BACK (Broad Ellipsoid flattened)
            addMuscleShape('Back', 1200, () => getPointInEllipsoid(0.35, 0.4, 0.1), { x: 0, y: 1.4, z: -0.1 });

            // 8. LEGS
            // Quads (Thighs) - Large cylinders
            addMuscleShape('Quads', 800, () => getPointInCylinder(0.14, 0.11, 0.5), { x: -0.2, y: 0.6, z: 0.05 });
            addMuscleShape('Quads', 800, () => getPointInCylinder(0.14, 0.11, 0.5), { x: 0.2, y: 0.6, z: 0.05 });

            // Hamstrings (Back of Thighs)
            addMuscleShape('Hamstrings', 600, () => getPointInCylinder(0.13, 0.11, 0.5), { x: -0.2, y: 0.6, z: -0.05 });
            addMuscleShape('Hamstrings', 600, () => getPointInCylinder(0.13, 0.11, 0.5), { x: 0.2, y: 0.6, z: -0.05 });

            // Calves (Lower Leg)
            addMuscleShape('Calves', 600, () => getPointInCylinder(0.10, 0.06, 0.45), { x: -0.22, y: 0.1, z: 0 });
            addMuscleShape('Calves', 600, () => getPointInCylinder(0.10, 0.06, 0.45), { x: 0.22, y: 0.1, z: 0 });

            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(particlePositions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(particleColors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(particleSizes, 1));

            material = new THREE.PointsMaterial({
                size: PARTICLE_SIZE,
                vertexColors: true,
                transparent: true,
                opacity: 0.85,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // --- Interaction ---

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onMouseClick(event) {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(particles);

            if (intersects.length > 0) {
                const index = intersects[0].index;
                const name = particleAttributes.muscleName[index];
                if (name && MUSCLE_DATA[name]) {
                    selectMuscle(name);
                }
            } else {
                resetView();
            }
        }

        function selectMuscle(name) {
            if (selectedMuscle === name) return;
            selectedMuscle = name;

            // Highlight logic
            const colors = geometry.attributes.color.array;
            for (let i = 0; i < particleAttributes.muscleName.length; i++) {
                const mName = particleAttributes.muscleName[i];
                const muscle = MUSCLE_DATA[mName];

                // Recalculate base color
                let baseColor;
                if (muscle.recovery >= 90) baseColor = COLORS.FRESH;
                else if (muscle.recovery >= 60) baseColor = COLORS.RECOVERING;
                else baseColor = COLORS.SORE;

                if (mName === name) {
                    // Bright
                    colors[i * 3] = baseColor.r * 1.5;
                    colors[i * 3 + 1] = baseColor.g * 1.5;
                    colors[i * 3 + 2] = baseColor.b * 1.5;
                } else {
                    // Dim
                    colors[i * 3] = baseColor.r * 0.1;
                    colors[i * 3 + 1] = baseColor.g * 0.1;
                    colors[i * 3 + 2] = baseColor.b * 0.1;
                }
            }
            geometry.attributes.color.needsUpdate = true;

            // Updated Card logic
            // ... (keep similar logic or simplified) ...
            updateInfoCard(name, MUSCLE_DATA[name]);

            // Camera Zoom would need center of mass calculation for general case
            // or hardcoded targets. Let's reset to neutral logic for now to avoid errors.
            // But user wants CLICK TO ZOOM. 
            // We can approximate center of selected points!
            let sumX = 0, sumY = 0, sumZ = 0, count = 0;
            for (let i = 0; i < particleAttributes.muscleName.length; i++) {
                if (particleAttributes.muscleName[i] === name) {
                    sumX += particleAttributes.originalPos[i * 3];
                    sumY += particleAttributes.originalPos[i * 3 + 1];
                    sumZ += particleAttributes.originalPos[i * 3 + 2];
                    count++;
                }
            }
            if (count > 0) {
                const centerX = sumX / count;
                const centerY = sumY / count;
                const centerZ = sumZ / count;

                new TWEEN.Tween(camera.position)
                    .to({ x: centerX, y: centerY, z: centerZ + 1.2 }, 1000)
                    .easing(TWEEN.Easing.Cubic.Out)
                    .start();

                new TWEEN.Tween(controls.target)
                    .to({ x: centerX, y: centerY, z: centerZ }, 1000)
                    .easing(TWEEN.Easing.Cubic.Out)
                    .start();
            }
        }

        function resetView() {
            selectedMuscle = null;
            resetParticles();
            hideInfoCard();

            new TWEEN.Tween(camera.position)
                .to({ x: 0, y: 1.2, z: 4.0 }, 1000)
                .easing(TWEEN.Easing.Cubic.Out)
                .start();
            new TWEEN.Tween(controls.target)
                .to({ x: 0, y: 1.0, z: 0 }, 1000)
                .easing(TWEEN.Easing.Cubic.Out)
                .start();
        }

        function resetParticles() {
            const colors = geometry.attributes.color.array;
            // Reset to base
            for (let i = 0; i < particleAttributes.muscleName.length; i++) {
                const name = particleAttributes.muscleName[i];
                const muscle = MUSCLE_DATA[name];
                let baseColor;
                if (muscle.recovery >= 90) baseColor = COLORS.FRESH;
                else if (muscle.recovery >= 60) baseColor = COLORS.RECOVERING;
                else baseColor = COLORS.SORE;

                colors[i * 3] = baseColor.r;
                colors[i * 3 + 1] = baseColor.g;
                colors[i * 3 + 2] = baseColor.b;
            }
            geometry.attributes.color.needsUpdate = true;
        }

        // --- UI Updates ---

        function updateInfoCard(name, muscle) {
            const card = document.getElementById('info-card');

            document.getElementById('card-title').innerText = name;

            const statusBadge = document.getElementById('card-status');
            const scoreVal = document.getElementById('card-score');
            const barFill = document.getElementById('card-bar');

            // Logic
            let statusText = "Fresh";
            let statusClass = "status-fresh";
            let barColor = "#00ff80";

            if (muscle.recovery < 60) {
                statusText = "Sore";
                statusClass = "status-sore";
                barColor = "#ff3232";
            } else if (muscle.recovery < 90) {
                statusText = "Recovering";
                statusClass = "status-recovering";
                barColor = "#ffaa00";
            }

            statusBadge.innerText = statusText;
            statusBadge.className = `status-badge ${statusClass}`; // Reset class

            scoreVal.innerText = `${muscle.recovery}%`;
            barFill.style.width = `${muscle.recovery}%`;
            barFill.style.backgroundColor = barColor; // Override css

            // Fake Data randomness for "Last Worked"
            const daysAgo = Math.floor(Math.random() * 5) + 1;
            document.getElementById('card-last').innerText = `${daysAgo} days ago`;
            document.getElementById('card-vol').innerText = `${Math.floor(Math.random() * 5000 + 1000)} kg`;

            card.classList.add('visible');
        }

        function hideInfoCard() {
            document.getElementById('info-card').classList.remove('visible');
        }

        // --- Loop ---

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();
            TWEEN.update();
            controls.update();

            // Breathing / Idle Animation
            // Expand/Contract Chest particles slightly
            // We can just oscillate the geometry vertices? No, expensive.
            // Move object? 
            // Simple: Rotate the whole group slowly
            if (!selectedMuscle) {
                particles.rotation.y = Math.sin(time * 0.1) * 0.1; // Gentle sway
            }

            // Pulse Sore Muscles (Red)
            // Advanced: Write custom shader for pulse. 
            // Simple JS Pulse:
            // Find "Sore" muscles and modulate their color intensity
            // Omitted for performance in simple version, but "Breathing" sway is added.

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>

</html>