<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Momentum 3D Recovery Tracker</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Inter', sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            pointer-events: none;
        }

        h1 {
            margin: 0;
            font-weight: 300;
            letter-spacing: 2px;
            font-size: 1.5rem;
            text-transform: uppercase;
        }

        .subtitle {
            color: #888;
            font-size: 0.8rem;
            margin-top: 5px;
        }

        #info-card {
            position: absolute;
            bottom: 40px;
            right: 40px;
            width: 280px;
            background: rgba(10, 10, 10, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 24px;
            color: white;
            display: none;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s, transform 0.3s;
        }

        #info-card.visible {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 16px;
        }

        .muscle-title {
            font-size: 1.2rem;
            font-weight: 700;
        }

        .status-badge {
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.7rem;
            font-weight: 700;
            text-transform: uppercase;
        }

        .status-fresh {
            background: rgba(0, 255, 128, 0.15);
            color: #00ff80;
            border: 1px solid rgba(0, 255, 128, 0.3);
        }

        .status-recovering {
            background: rgba(255, 170, 0, 0.15);
            color: #ffaa00;
            border: 1px solid rgba(255, 170, 0, 0.3);
        }

        .status-sore {
            background: rgba(255, 50, 50, 0.15);
            color: #ff3232;
            border: 1px solid rgba(255, 50, 50, 0.3);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .stat-label {
            color: #888;
        }

        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #444;
            font-size: 0.8rem;
            letter-spacing: 1px;
        }
    </style>

    <!-- Load Three.js Global Scripts (No Modules) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>

<body>
    <div id="canvas-container"></div>
    <div id="hud">
        <h1>Anatomy of Momentum</h1>
        <div class="subtitle">Holographic Biometric Scanner</div>
    </div>
    <div id="loader">INITIALIZING ATHLETIC SCAN...</div>

    <div id="info-card">
        <div class="card-header">
            <div class="muscle-title" id="card-title">Chest</div>
            <div class="status-badge status-fresh" id="card-status">Fresh</div>
        </div>
        <div class="stat-row">
            <span class="stat-label">Recovery Score</span>
            <span class="stat-value" id="card-score">92%</span>
        </div>
    </div>

    <script>
        // Main Logic
        // SDF Metaball Human Generator (Athletic Build)
        const PARTICLE_COUNT = 45000;
        const PARTICLE_SIZE = 0.012;
        const COLORS = {
            FRESH: new THREE.Color(0x00ff80),
            RECOVERING: new THREE.Color(0xffaa00),
            SORE: new THREE.Color(0xff3232),
            NEUTRAL: new THREE.Color(0x8888aa)
        };

        // Global State
        var scene, camera, renderer, controls, raycaster;
        var particles, geometry, material;
        var selectedMuscle = null;
        var clock = new THREE.Clock();
        var mouse = new THREE.Vector2();

        var particlePositions = [];
        var particleColors = [];
        var particleSizes = [];
        var particleAttributes = {
            muscleName: [],
            originalPos: []
        };

        const MUSCLE_DATA = {
            'Chest': { recovery: 95 },
            'Back': { recovery: 85 },
            'Shoulders': { recovery: 45 },
            'Biceps': { recovery: 60 },
            'Triceps': { recovery: 60 },
            'Abs': { recovery: 92 },
            'Quads': { recovery: 100 },
            'Hamstrings': { recovery: 100 },
            'Calves': { recovery: 100 },
            'Glutes': { recovery: 90 },
            'Traps': { recovery: 70 },
            'Forearms': { recovery: 80 },
            'Head': { recovery: 100 }
        };

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.10);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.1, 3.2);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxDistance = 6;
            controls.minDistance = 0.5;
            controls.target.set(0, 1.0, 0);

            raycaster = new THREE.Raycaster();
            raycaster.params.Points.threshold = 0.05;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            generateSDFBody();

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('click', onMouseClick);

            document.getElementById('loader').style.display = 'none';
        }

        // --- SDF Helpers ---
        function sdCapsule(p, a, b, r) {
            const pa = new THREE.Vector3().subVectors(p, a);
            const ba = new THREE.Vector3().subVectors(b, a);
            const h = Math.max(0, Math.min(1, pa.dot(ba) / ba.dot(ba)));
            const d = pa.sub(ba.multiplyScalar(h)).length() - r;
            return d;
        }

        function smin(a, b, k) {
            const h = Math.max(0, Math.min(1, 0.5 + 0.5 * (b - a) / k));
            return a * h + b * (1.0 - h) - k * h * (1.0 - h);
        }

        function generateSDFBody() {
            // Reset
            particlePositions = []; particleColors = []; particleSizes = [];
            particleAttributes.muscleName = []; particleAttributes.originalPos = [];

            // Define Skeleton "Bones" (Capsules) - REFINED ATHLETIC PROPORTIONS
            const bones = [
                // HEAD & NECK
                { name: 'Head', s: [0, 1.68, 0], e: [0, 1.82, 0.02], r: 0.10 }, // Skull
                { name: 'Traps', s: [0, 1.58, 0], e: [0, 1.52, 0], r: 0.09 }, // Neck Base (Thinner)

                // TORSO (Slimmer V-Taper, Less Bulky)
                { name: 'Shoulders', s: [-0.08, 1.52, 0], e: [-0.42, 1.48, 0], r: 0.08 }, // Left Clavicle
                { name: 'Shoulders', s: [0.08, 1.52, 0], e: [0.42, 1.48, 0], r: 0.08 }, // Right Clavicle

                { name: 'Chest', s: [-0.08, 1.42, 0.08], e: [-0.22, 1.35, 0.08], r: 0.125 }, // Flat Athletic Pecs
                { name: 'Chest', s: [0.08, 1.42, 0.08], e: [0.22, 1.35, 0.08], r: 0.125 },

                { name: 'Back', s: [0, 1.5, -0.05], e: [0, 1.1, -0.05], r: 0.15 }, // Lean Spine/Lats
                { name: 'Abs', s: [0, 1.25, 0.06], e: [0, 1.0, 0.04], r: 0.12 }, // Lean Core
                { name: 'Abs', s: [0, 1.0, 0.04], e: [0, 0.85, 0.02], r: 0.12 }, // Lower Abs

                // ARMS (Left) - Leaner
                { name: 'Shoulders', s: [-0.42, 1.48, 0], e: [-0.50, 1.38, 0], r: 0.095 }, // Delt Cap
                { name: 'Biceps', s: [-0.50, 1.35, 0.03], e: [-0.50, 1.05, 0.03], r: 0.075 }, // Slimmer Arm
                { name: 'Triceps', s: [-0.50, 1.35, -0.03], e: [-0.50, 1.05, -0.03], r: 0.075 },
                { name: 'Forearms', s: [-0.50, 1.05, 0], e: [-0.60, 0.7, 0.1], r: 0.065 },

                // ARMS (Right)
                { name: 'Shoulders', s: [0.42, 1.48, 0], e: [0.50, 1.38, 0], r: 0.095 },
                { name: 'Biceps', s: [0.50, 1.35, 0.03], e: [0.50, 1.05, 0.03], r: 0.075 },
                { name: 'Triceps', s: [0.50, 1.35, -0.03], e: [0.50, 1.05, -0.03], r: 0.075 },
                { name: 'Forearms', s: [0.50, 1.05, 0], e: [0.60, 0.7, 0.1], r: 0.065 },

                // LEGS (Left) - Longer & Athletic
                { name: 'Glutes', s: [-0.08, 0.9, -0.08], e: [-0.18, 0.8, -0.08], r: 0.12 }, // Hip
                { name: 'Quads', s: [-0.18, 0.8, 0.04], e: [-0.22, 0.45, 0.04], r: 0.11 }, // Thigh/Knee
                { name: 'Hamstrings', s: [-0.18, 0.8, -0.04], e: [-0.22, 0.45, -0.04], r: 0.11 },
                { name: 'Calves', s: [-0.22, 0.45, -0.02], e: [-0.22, 0.05, -0.02], r: 0.08 }, // Calf/Ankle

                // LEGS (Right)
                { name: 'Glutes', s: [0.08, 0.9, -0.08], e: [0.18, 0.8, -0.08], r: 0.12 },
                { name: 'Quads', s: [0.18, 0.8, 0.04], e: [0.22, 0.45, 0.04], r: 0.11 },
                { name: 'Hamstrings', s: [0.18, 0.8, -0.04], e: [0.22, 0.45, -0.04], r: 0.11 },
                { name: 'Calves', s: [0.22, 0.45, -0.02], e: [0.22, 0.05, -0.02], r: 0.08 },

                // FEET
                { name: 'Calves', s: [-0.22, 0.05, 0], e: [-0.25, 0.0, 0.12], r: 0.07 },
                { name: 'Calves', s: [0.22, 0.05, 0], e: [0.25, 0.0, 0.12], r: 0.07 }
            ];

            // Convert to Vectors
            const capsules = bones.map(b => ({
                name: b.name,
                a: new THREE.Vector3(...b.s),
                b: new THREE.Vector3(...b.e),
                r: b.r
            }));

            // SDF Evaluator
            function getClosestMuscle(p) {
                let minD = 999;
                let muscle = null;
                let smoothD = 2.0;

                for (let c of capsules) {
                    const d = sdCapsule(p, c.a, c.b, c.r);
                    smoothD = smin(smoothD, d, 0.07); // Slightly tighter blend for definition
                    if (d < minD) {
                        minD = d;
                        muscle = c.name;
                    }
                }
                return { d: smoothD, muscle: muscle };
            }

            // SURFACE SAMPLING (SHELL)
            const bounds = { x: 0.6, y: 1.95, z: 0.3 }; // Tighter bounds
            let count = 0;
            const targetCount = PARTICLE_COUNT;

            let attempts = 0;
            const maxAttempts = targetCount * 250;

            while (count < targetCount && attempts < maxAttempts) {
                attempts++;
                const px = (Math.random() - 0.5) * 2 * bounds.x;
                const py = Math.random() * bounds.y;
                const pz = (Math.random() - 0.5) * 2 * bounds.z;
                const p = new THREE.Vector3(px, py, pz);

                const res = getClosestMuscle(p);

                // SHELL CONDITION
                if (Math.abs(res.d) < 0.006) { // Thinner shell

                    const muscle = MUSCLE_DATA[res.muscle] || { recovery: 100 };
                    let baseColor;
                    if (muscle.recovery >= 90) baseColor = COLORS.FRESH;
                    else if (muscle.recovery >= 60) baseColor = COLORS.RECOVERING;
                    else baseColor = COLORS.SORE;

                    particlePositions.push(px, py, pz);
                    particleColors.push(baseColor.r, baseColor.g, baseColor.b);
                    particleSizes.push(PARTICLE_SIZE);

                    particleAttributes.muscleName.push(res.muscle);
                    particleAttributes.originalPos.push(px, py, pz);
                    count++;
                }
            }
            console.log("Scan complete:", count);

            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(particlePositions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(particleColors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(particleSizes, 1));

            material = new THREE.PointsMaterial({
                size: PARTICLE_SIZE, vertexColors: true, transparent: true, opacity: 0.85,
                sizeAttenuation: true, blending: THREE.AdditiveBlending
            });
            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            const planeGeo = new THREE.PlaneGeometry(3, 3);
            const planeMat = new THREE.MeshBasicMaterial({ color: 0x222222, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
            const plane = new THREE.Mesh(planeGeo, planeMat);
            plane.rotation.x = Math.PI / 2;
            plane.position.y = 0;
            scene.add(plane);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }
        function onMouseClick(event) {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(particles);
            if (intersects.length > 0) {
                const name = particleAttributes.muscleName[intersects[0].index];
                if (name) selectMuscle(name);
            } else resetView();
        }

        function selectMuscle(name) {
            if (selectedMuscle === name) return;
            selectedMuscle = name;

            const colors = geometry.attributes.color.array;
            for (let i = 0; i < particleAttributes.muscleName.length; i++) {
                const mName = particleAttributes.muscleName[i];
                const muscle = MUSCLE_DATA[mName] || { recovery: 100 };
                let baseColor = (muscle.recovery >= 90) ? COLORS.FRESH : (muscle.recovery >= 60 ? COLORS.RECOVERING : COLORS.SORE);

                if (mName === name) {
                    colors[i * 3] = baseColor.r * 1.5; colors[i * 3 + 1] = baseColor.g * 1.5; colors[i * 3 + 2] = baseColor.b * 1.5;
                } else {
                    colors[i * 3] = baseColor.r * 0.15; colors[i * 3 + 1] = baseColor.g * 0.15; colors[i * 3 + 2] = baseColor.b * 0.15;
                }
            }
            geometry.attributes.color.needsUpdate = true;

            const card = document.getElementById('info-card');
            const data = MUSCLE_DATA[name];
            document.getElementById('card-title').innerText = name;
            document.getElementById('card-score').innerText = data.recovery + "%";
            const badge = document.getElementById('card-status');
            badge.innerText = data.recovery >= 90 ? "Fresh" : (data.recovery >= 60 ? "Recovering" : "Sore");
            badge.className = "status-badge " + (data.recovery >= 90 ? "status-fresh" : (data.recovery >= 60 ? "status-recovering" : "status-sore"));
            card.className = "visible";

            let sumX = 0, sumY = 0, sumZ = 0, count = 0;
            for (let i = 0; i < particleAttributes.muscleName.length; i++) {
                if (particleAttributes.muscleName[i] === name) {
                    sumX += particleAttributes.originalPos[i * 3];
                    sumY += particleAttributes.originalPos[i * 3 + 1];
                    sumZ += particleAttributes.originalPos[i * 3 + 2];
                    count++;
                }
            }
            if (count) {
                const t = { x: sumX / count, y: sumY / count, z: sumZ / count };
                new TWEEN.Tween(camera.position).to({ x: t.x, y: t.y, z: t.z + 0.8 }, 800).easing(TWEEN.Easing.Cubic.Out).start();
                new TWEEN.Tween(controls.target).to(t, 800).easing(TWEEN.Easing.Cubic.Out).start();
            }
        }

        function resetView() {
            selectedMuscle = null;
            document.getElementById('info-card').className = "";
            const colors = geometry.attributes.color.array;
            for (let i = 0; i < particleAttributes.muscleName.length; i++) {
                const mName = particleAttributes.muscleName[i];
                const muscle = MUSCLE_DATA[mName] || { recovery: 100 };
                let baseColor = (muscle.recovery >= 90) ? COLORS.FRESH : (muscle.recovery >= 60 ? COLORS.RECOVERING : COLORS.SORE);
                colors[i * 3] = baseColor.r; colors[i * 3 + 1] = baseColor.g; colors[i * 3 + 2] = baseColor.b;
            }
            geometry.attributes.color.needsUpdate = true;

            new TWEEN.Tween(camera.position).to({ x: 0, y: 1.1, z: 3.2 }, 800).easing(TWEEN.Easing.Cubic.Out).start();
            new TWEEN.Tween(controls.target).to({ x: 0, y: 1, z: 0 }, 800).easing(TWEEN.Easing.Cubic.Out).start();
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            if (TWEEN) TWEEN.update();
            controls.update();
            particles.rotation.y = Math.sin(time * 0.1) * 0.05;
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>