<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Momentum 3D Recovery Tracker</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Inter', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        
        /* HUD Overlay */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            pointer-events: none;
        }
        h1 { margin: 0; font-weight: 300; letter-spacing: 2px; font-size: 1.5rem; text-transform: uppercase; }
        .subtitle { color: #888; font-size: 0.8rem; margin-top: 5px; }

        /* Tooltip / Info Card */
        #info-card {
            position: absolute;
            bottom: 40px;
            right: 40px;
            width: 280px;
            background: rgba(10, 10, 10, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 24px;
            color: white;
            display: none; /* Hidden by default */
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        #info-card.visible { display: block; opacity: 1; transform: translateY(0); }
        
        .card-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px; }
        .muscle-title { font-size: 1.2rem; font-weight: 700; color: #fff; }
        .status-badge { 
            padding: 4px 10px; border-radius: 20px; font-size: 0.7rem; font-weight: 700; text-transform: uppercase; 
        }
        .status-fresh { background: rgba(0, 255, 128, 0.15); color: #00ff80; border: 1px solid rgba(0, 255, 128, 0.3); }
        .status-recovering { background: rgba(255, 170, 0, 0.15); color: #ffaa00; border: 1px solid rgba(255, 170, 0, 0.3); }
        .status-sore { background: rgba(255, 50, 50, 0.15); color: #ff3232; border: 1px solid rgba(255, 50, 50, 0.3); }

        .stat-row { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 0.9rem; }
        .stat-label { color: #888; }
        .stat-value { font-weight: 600; }
        
        .progress-bar { height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; margin-top: 4px; overflow: hidden; }
        .progress-fill { height: 100%; background: #00ff80; width: 0%; transition: width 0.5s ease; }

        /* Loader */
        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #444; font-size: 0.8rem; letter-spacing: 1px;
        }
        
        /* Interaction Hint */
        #hint {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            color: #444; font-size: 0.8rem; pointer-events: none; opacity: 0.6;
        }
    </style>
    <!-- Import Maps Polyfill -->
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="hud">
        <h1>Anatomy of Momentum</h1>
        <div class="subtitle">Interactive Recovery Visualization</div>
    </div>
    <div id="loader">INITIALIZING NEURAL LINK...</div>
    <div id="hint">Click to Interact • Drag to Rotate • Scroll to Zoom</div>

    <div id="info-card">
        <div class="card-header">
            <div class="muscle-title" id="card-title">Chest</div>
            <div class="status-badge status-fresh" id="card-status">Fresh</div>
        </div>
        <div class="stat-row">
            <span class="stat-label">Recovery Score</span>
            <span class="stat-value" id="card-score">92%</span>
        </div>
        <div class="progress-bar"><div class="progress-fill" id="card-bar"></div></div>
        <br>
        <div class="stat-row">
            <span class="stat-label">Last Worked</span>
            <span class="stat-value" id="card-last">3 days ago</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Volume Load</span>
            <span class="stat-value" id="card-vol">12,400 kg</span>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TWEEN } from 'three/addons/libs/tween.module.min.js';

        // --- Configuration ---
        const PARTICLE_COUNT = 8000;
        const PARTICLE_SIZE = 0.04;
        const COLORS = {
            FRESH: new THREE.Color(0x00ff80),     // Green
            RECOVERING: new THREE.Color(0xffaa00), // Orange
            SORE: new THREE.Color(0xff3232),       // Red
            NEUTRAL: new THREE.Color(0x4444aa)     // Blueish Slate
        };

        // --- State ---
        let scene, camera, renderer, controls, raycaster;
        let particles, geometry, material;
        let selectedMuscle = null;
        let clock = new THREE.Clock();
        const mouse = new THREE.Vector2();

        // Muscle Definitions (Hardcoded Logic)
        // Format: { name, type, yRange, xRange, zRange, radius, recovery }
        // We will generate particles within these bounds to form the shape
        const MUSCLES = {
            'Head': { y: [1.6, 1.85], x: [-0.12, 0.12], z: [-0.15, 0.15], count: 800, recovery: 100 },
            'Chest': { y: [1.3, 1.55], x: [-0.25, 0.25], z: [0.05, 0.15], count: 1200, recovery: 95 },
            'Abs': { y: [0.95, 1.25], x: [-0.15, 0.15], z: [0.05, 0.12], count: 800, recovery: 100 },
            'Back': { y: [1.0, 1.55], x: [-0.25, 0.25], z: [-0.15, -0.05], count: 1200, recovery: 85 }, // Slightly sore
            'Shoulders': { y: [1.45, 1.6], x: [-0.4, 0.4], z: [-0.1, 0.1], count: 900, recovery: 45 }, // Sore
            'Arms': { y: [0.9, 1.45], x: [[-0.45, -0.3], [0.3, 0.45]], z: [-0.1, 0.1], count: 1100, recovery: 60 },
            'Quads': { y: [0.4, 0.9], x: [[-0.25, -0.1], [0.1, 0.25]], z: [0.0, 0.15], count: 1500, recovery: 100 },
            'Calves': { y: [0.0, 0.35], x: [[-0.25, -0.1], [0.1, 0.25]], z: [-0.1, 0.1], count: 800, recovery: 100 },
        };

        // Arrays to store particle data for raycasting
        const particleAttributes = {
            muscleId: [], // Index of muscle in MUSCLES keys
            originalPos: []
        };
        const muscleKeys = Object.keys(MUSCLES);

        init();
        animate();

        function init() {
            // 1. Setup
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.15);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.0, 3.5);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxDistance = 6;
            controls.minDistance = 1;

            raycaster = new THREE.Raycaster();
            raycaster.params.Points.threshold = 0.1;

            // 2. Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 1);
            pointLight.position.set(2, 2, 2);
            scene.add(pointLight);

            // 3. Generate Particles
            generateBody();

            // 4. Events
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('click', onMouseClick);
            
            // Remove Loader
            document.getElementById('loader').style.display = 'none';
        }

        function generateBody() {
            const positions = [];
            const colors = [];
            const sizes = [];

            muscleKeys.forEach((key, index) => {
                const muscle = MUSCLES[key];
                
                // Determine color based on recovery
                let baseColor;
                if (muscle.recovery >= 90) baseColor = COLORS.FRESH;
                else if (muscle.recovery >= 60) baseColor = COLORS.RECOVERING;
                else baseColor = COLORS.SORE;

                for (let i = 0; i < muscle.count; i++) {
                    const x = randomInRanges(muscle.x);
                    const y = randomRange(muscle.y[0], muscle.y[1]);
                    const z = randomRange(muscle.z[0], muscle.z[1]);

                    // Add some noise/shaping to make it organic
                    // Taper towards joints (simple heuristic)
                    
                    positions.push(x, y, z);
                    
                    colors.push(baseColor.r, baseColor.g, baseColor.b);
                    sizes.push(PARTICLE_SIZE * (0.8 + Math.random() * 0.4)); // Random size var
                    
                    particleAttributes.muscleId.push(index);
                    particleAttributes.originalPos.push(x, y, z);
                }
            });

            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1)); // We'll use size later if shader

            // Using standard PointsMaterial for MVP
            material = new THREE.PointsMaterial({ 
                size: PARTICLE_SIZE, 
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function randomRange(min, max) {
            return Math.random() * (max - min) + min;
        }

        function randomInRanges(xConfig) {
            // Handle array of ranges for split muscles (Arms/Legs)
            if (Array.isArray(xConfig[0])) {
                // Pick left or right
                const side = Math.random() > 0.5 ? xConfig[0] : xConfig[1];
                return randomRange(side[0], side[1]);
            } else {
                return randomRange(xConfig[0], xConfig[1]);
            }
        }

        // --- Interaction ---
        
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onMouseClick(event) {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(particles);

            if (intersects.length > 0) {
                // Find closest muscle
                // Since points are tiny, we might click empty space.
                // Threshold handles tolerance.
                
                // Get the index of the point
                const index = intersects[0].index;
                const muscleIndex = particleAttributes.muscleId[index];
                const muscleName = muscleKeys[muscleIndex];
                
                selectMuscle(muscleName);
            } else {
                // Clicked background -> Reset
                resetView();
            }
        }

        function selectMuscle(name) {
            if (selectedMuscle === name) return;
            selectedMuscle = name;
            
            const muscle = MUSCLES[name];
            
            // 1. Zoom Camera
            // Calculate center of muscle
            let avgY = (muscle.y[0] + muscle.y[1]) / 2;
            let avgZ = (muscle.z[0] + muscle.z[1]) / 2;
            // X center depends on split
            let targetPos = { x: 0, y: avgY, z: avgZ + 1.5 }; // Zoom in
            
            // Tween Camera
            new TWEEN.Tween(camera.position)
                .to(targetPos, 1000)
                .easing(TWEEN.Easing.Cubic.Out)
                .start();
                
            new TWEEN.Tween(controls.target)
                .to({ x: 0, y: avgY, z: 0 }, 1000)
                .easing(TWEEN.Easing.Cubic.Out)
                .start();

            // 2. Update UI
            updateInfoCard(name, muscle);
            
            // 3. Highlight Particles
            highlightParticles(name);
        }

        function resetView() {
            selectedMuscle = null;
            
            new TWEEN.Tween(camera.position)
                .to({ x: 0, y: 1.0, z: 3.5 }, 1200)
                .easing(TWEEN.Easing.Exponential.Out)
                .start();
                
            new TWEEN.Tween(controls.target)
                .to({ x: 0, y: 0.9, z: 0 }, 1200)
                .easing(TWEEN.Easing.Exponential.Out)
                .start();

            hideInfoCard();
            resetParticles();
        }

        function highlightParticles(targetName) {
            // Dim others, Brighten target
            // Access colors attribute
            const colors = geometry.attributes.color.array;
            
            muscleKeys.forEach((key, keyIndex) => {
                const muscle = MUSCLES[key];
                let baseColor;
                let alpha = 1.0;
                
                // Determine base color again
                if (muscle.recovery >= 90) baseColor = COLORS.FRESH;
                else if (muscle.recovery >= 60) baseColor = COLORS.RECOVERING;
                else baseColor = COLORS.SORE;

                if (key === targetName) {
                     // Pulse effect logic could go here, for now just keep bright
                } else {
                     // Check if we can dim? PointsMaterial has global opacity.
                     // To dim specific points, we darken their vertex color.
                     baseColor = baseColor.clone().multiplyScalar(0.2); // Darken
                }

                // Apply to all particles of this muscle
                // This is slow O(N), but N=8000 is fine for desktop/mobile
                for(let i=0; i < particleAttributes.muscleId.length; i++) {
                    if (particleAttributes.muscleId[i] === keyIndex) {
                        colors[i*3] = baseColor.r;
                        colors[i*3+1] = baseColor.g;
                        colors[i*3+2] = baseColor.b;
                    }
                }
            });
            
            geometry.attributes.color.needsUpdate = true;
        }

        function resetParticles() {
             const colors = geometry.attributes.color.array;
             muscleKeys.forEach((key, keyIndex) => {
                const muscle = MUSCLES[key];
                let baseColor;
                if (muscle.recovery >= 90) baseColor = COLORS.FRESH;
                else if (muscle.recovery >= 60) baseColor = COLORS.RECOVERING;
                else baseColor = COLORS.SORE;

                for(let i=0; i < particleAttributes.muscleId.length; i++) {
                    if (particleAttributes.muscleId[i] === keyIndex) {
                        colors[i*3] = baseColor.r;
                        colors[i*3+1] = baseColor.g;
                        colors[i*3+2] = baseColor.b;
                    }
                }
             });
             geometry.attributes.color.needsUpdate = true;
        }

        // --- UI Updates ---

        function updateInfoCard(name, muscle) {
            const card = document.getElementById('info-card');
            
            document.getElementById('card-title').innerText = name;
            
            const statusBadge = document.getElementById('card-status');
            const scoreVal = document.getElementById('card-score');
            const barFill = document.getElementById('card-bar');
            
            // Logic
            let statusText = "Fresh";
            let statusClass = "status-fresh";
            let barColor = "#00ff80";
            
            if (muscle.recovery < 60) {
                 statusText = "Sore";
                 statusClass = "status-sore";
                 barColor = "#ff3232";
            } else if (muscle.recovery < 90) {
                 statusText = "Recovering";
                 statusClass = "status-recovering";
                 barColor = "#ffaa00";
            }
            
            statusBadge.innerText = statusText;
            statusBadge.className = `status-badge ${statusClass}`; // Reset class
            
            scoreVal.innerText = `${muscle.recovery}%`;
            barFill.style.width = `${muscle.recovery}%`;
            barFill.style.backgroundColor = barColor; // Override css

            // Fake Data randomness for "Last Worked"
            const daysAgo = Math.floor(Math.random() * 5) + 1;
            document.getElementById('card-last').innerText = `${daysAgo} days ago`;
            document.getElementById('card-vol').innerText = `${Math.floor(Math.random() * 5000 + 1000)} kg`;

            card.classList.add('visible');
        }

        function hideInfoCard() {
            document.getElementById('info-card').classList.remove('visible');
        }

        // --- Loop ---

        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            TWEEN.update();
            controls.update();

            // Breathing / Idle Animation
            // Expand/Contract Chest particles slightly
            // We can just oscillate the geometry vertices? No, expensive.
            // Move object? 
            // Simple: Rotate the whole group slowly
            if (!selectedMuscle) {
               particles.rotation.y = Math.sin(time * 0.1) * 0.1; // Gentle sway
            }

            // Pulse Sore Muscles (Red)
            // Advanced: Write custom shader for pulse. 
            // Simple JS Pulse:
            // Find "Sore" muscles and modulate their color intensity
            // Omitted for performance in simple version, but "Breathing" sway is added.

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
