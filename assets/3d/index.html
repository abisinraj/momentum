<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Momentum 3D Debug (v5.1)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f0;
            color: #eee;
            touch-action: manipulation;
            /* Disables double-tap zoom */
        }

        canvas {
            display: block;
        }

        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            font-weight: 500;
            color: #888;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        #loader.hidden {
            opacity: 0;
        }
    </style>
</head>

<body>
    <div id="loader">Loading Model...</div>
    <script src="three_global.js"></script>
    <script src="BufferGeometryUtils_global.js"></script>
    <script src="GLTFLoader_global.js"></script>
    <script src="OrbitControls_global.js"></script>
    <script src="RoomEnvironment_global.js"></script>


    <script>
        // Explicitly alias globals to ensure access
        const THREE = window.THREE;
        const GLTFLoader = window.GLTFLoader;
        const OrbitControls = window.OrbitControls;
        const RoomEnvironment = window.RoomEnvironment;

        // Use global variables
        var camera, scene, renderer, model, controls;

        // --- Camera Zoom Logic State (Hoisted to avoid TDZ) ---
        var isZooming = false;
        var targetCameraPos = new THREE.Vector3();
        var targetControlsTarget = new THREE.Vector3();
        var zoomDuration = 800; // ms (Faster, smoother)
        var zoomStartTime = 0;
        var startCameraPos = new THREE.Vector3();
        var startControlsTarget = new THREE.Vector3();
        var lastTapTime = 0;
        var tapsOutsideCount = 0;
        var gameMode = false;
        var modelHealth = 100;
        var playerHealth = 100;
        var gameScore = 0;
        var comboCount = 0;
        var gameLastHitTime = 0;

        // --- MUSCLE DEFINITIONS (For Shader) ---
        // --- MUSCLE DEFINITIONS (Initially Empty - Populated by Flutter) ---
        var muscleDefs = [];

        // Function called by Flutter to set definitions
        window.updateMuscleDefs = function (defs, mirroredNames) {
            console.log('Received Muscle Defs from Flutter:', defs.length);
            muscleDefs = defs;

            // Generate Mirrored Muscles (Left Side) automatically
            // Flutter passes a list of names that should be mirrored
            mirroredNames.forEach(name => {
                const original = muscleDefs.find(m => m.name === name);
                if (original) {
                    const mirror = { ...original }; // Shallow copy

                    // Unique name for targeting
                    mirror.name = original.name + ' (Left)';

                    // Flip Bone Names (More robust replacement)
                    if (mirror.bone) mirror.bone = mirror.bone.replace('Right', 'Left').replace('right', 'left');
                    if (mirror.start) mirror.start = mirror.start.replace('Right', 'Left').replace('right', 'left');
                    if (mirror.end) mirror.end = mirror.end.replace('Right', 'Left').replace('right', 'left');

                    // NOTE: Whether to flip X depends on the rig.
                    // For Mixamo rigs, local X is often already mirrored (Right +X = World Right, Left +X = World Left).
                    // If we flip the offset, we'd actually move the point to the wrong side of the bone.
                    // Based on user feedback ("taking to wrong side"), let's NOT flip X and see if it aligns.
                    // We'll keep the shallow copy's offset.

                    muscleDefs.push(mirror);
                }
            });
            console.log('Total Muscle Zones (with mirrors):', muscleDefs.length);
        };

        // Shader Uniforms
        const MAX_ZONES = 64;
        const uniformData = {
            u_zone_starts: { value: new Float32Array(MAX_ZONES * 3) },
            u_zone_ends: { value: new Float32Array(MAX_ZONES * 3) },
            u_zone_radii: { value: new Float32Array(MAX_ZONES) },
            u_zone_intensities: { value: new Float32Array(MAX_ZONES) },
            u_zone_count: { value: 0 }
        };

        var activeHeatmap = {};

        // Efficient dependency gatekeeper
        window.isReady = false;
        window._pendingModelData = null;

        // IMPORT EXTERNAL MODULES
        // These scripts must be loaded in this order
        const loadScript = (src) => {
            return new Promise((resolve, reject) => {
                const s = document.createElement('script');
                s.src = src;
                s.onload = resolve;
                s.onerror = reject;
                document.head.appendChild(s);
            });
        };

        // Load Modules sequentially
        Promise.all([
            loadScript('js/poses.js'),
            loadScript('js/stanceController.js'),
            loadScript('js/aiController.js')
        ]).then(() => {
            console.log("âœ… All Animation Modules Loaded");
            if (model) {
                if (window.stanceController && window.stanceController.init) window.stanceController.init();
                if (window.aiController && window.aiController.init) window.aiController.init();
            }
        }).catch(err => console.error("Failed to load modules:", err));




        window.loadGLTFFromBase64 = function (base64Data) {
            if (!window.isReady) {
                console.log("3D Viewer not ready, buffering model data...");
                window._pendingModelData = base64Data;
                return;
            }

            // Existing logic will be attached to this later or we can just define it here
            // But for now, we'll keep the specialized definition inside init() but 
            // allow this top-level one to catch the early call.
            if (window._actualLoadGLTFFromBase64) {
                window._actualLoadGLTFFromBase64(base64Data);
            } else {
                window._pendingModelData = base64Data;
            }
        };

        function checkDependencies() {
            const startTime = Date.now();
            const TIMEOUT_MS = 15000;

            function check() {
                const missing = [];
                if (!window.THREE) missing.push('THREE');
                if (!window.GLTFLoader) missing.push('GLTFLoader');
                if (!window.OrbitControls) missing.push('OrbitControls');
                if (!window.RoomEnvironment) missing.push('RoomEnvironment');

                if (missing.length === 0) {
                    console.log('âœ“ 3D Viewer initialized successfully');
                    document.getElementById('loader').classList.add('hidden');
                    init();
                    animate();
                    window.isReady = true;

                    // Execute buffered model load
                    if (window._pendingModelData) {
                        console.log("Loading buffered model data...");
                        window.loadGLTFFromBase64(window._pendingModelData);
                        window._pendingModelData = null;
                    }
                    return;
                }

                if (Date.now() - startTime > TIMEOUT_MS) {
                    console.error('âŒ 3D Viewer startup failed: Missing dependencies:', missing.join(', '));
                    const loader = document.getElementById('loader');
                    loader.style.color = '#ff4444';
                    loader.innerHTML = 'Error: Missing ' + missing.join(', ');
                    return;
                }
                requestAnimationFrame(check);
            }
            check();
        }

        window.setCombatMode = function (enabled) {
            if (window.stanceController) {
                window.stanceController.targetPose = enabled ? 'FIGHT' : 'IDLE';
                console.log("ðŸ¥Š Combat Pose:", window.stanceController.targetPose);
            }
        };

        window.isPlayerGuarding = false;
        window.setGuarding = function (isGuarding) {
            if (!gameMode) return;
            window.isPlayerGuarding = isGuarding;
            console.log("ðŸ›¡ï¸ Player Guarding:", isGuarding);

            const ui = document.getElementById('game-ui');
            if (ui) {
                let msg = document.getElementById('guard-indicator');
                if (isGuarding) {
                    if (!msg) {
                        msg = document.createElement('div');
                        msg.id = 'guard-indicator';
                        msg.style.color = '#2196F3';
                        msg.style.fontWeight = 'bold';
                        msg.style.marginTop = '10px';
                        msg.innerText = 'ðŸ›¡ï¸ GUARD ACTIVATED';
                        ui.appendChild(msg);
                    }
                } else if (msg) {
                    msg.remove();
                }
            }
        };

        checkDependencies();

        window.addEventListener('resize', () => {
            if (!camera || !renderer) return;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function init() {
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio); // SUPPORT HDPI SCREENS
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x000000, 0);
            document.body.appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
            // Default Position: Closer and higher to frame upper body
            camera.position.set(0, 1.2, 4.0); // Full View Init

            scene = new THREE.Scene();

            // Environment
            const environment = new RoomEnvironment();
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environment = pmremGenerator.fromScene(environment).texture;

            const dirLight = new THREE.DirectionalLight(0xffffff, 3.0);
            dirLight.position.set(5, 10, 7.5);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 20;
            scene.add(dirLight);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);

            // Add Ground: World Martial Arts Tournament (Stone Platform)
            const groundGroup = new THREE.Group();

            // 1. Stone Foundation (Tenkaichi Budokai - Warm Tile Color)
            const planeGeom = new THREE.PlaneGeometry(20, 20);
            const planeMat = new THREE.MeshStandardMaterial({
                color: 0xe6c288, // Warm Sandy/Beige Tile Color
                roughness: 0.9,
                metalness: 0.0
            });
            const groundPlane = new THREE.Mesh(planeGeom, planeMat);
            groundPlane.rotation.x = -Math.PI / 2;
            groundPlane.receiveShadow = true;
            groundGroup.add(groundPlane);

            // 2. Tile Lines (Grout - Darker Earth Tone)
            const tournamentGrid = new THREE.GridHelper(20, 20, 0x8b7355, 0xafa188);
            tournamentGrid.position.y = 0.01; // Slightly above plane to prevent z-fighting
            groundGroup.add(tournamentGrid);

            groundGroup.position.y = 0;
            groundGroup.visible = false; // Hidden by default (Profile Mode)
            window.groundGroup = groundGroup; // Expose for game mode toggle
            scene.add(groundGroup);

            const loader = new GLTFLoader();

            // Function to handle the GLTF content once loaded
            function onModelLoaded(gltf) {
                model = gltf.scene;
                window.model = model;

                // CRITICAL: Define findBone IMMEDIATELY so stanceController can use it
                window.findBone = function (name) {
                    if (!model) return null;
                    let firstMatch = null;
                    let exactMatch = null;

                    model.traverse(child => {
                        const cName = child.name;
                        if (!cName) return;

                        if (cName === name || cName === 'Mixamo_' + name || cName.split(':').pop() === name) {
                            exactMatch = child;
                        }
                        if (!firstMatch && cName.toLowerCase().includes(name.toLowerCase())) {
                            firstMatch = child;
                        }
                    });

                    return exactMatch || firstMatch;
                };
                // Also make it available without window prefix
                findBone = window.findBone;

                // Auto-center model on X and Z axes for better rotation (profile views)
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                model.position.x = -center.x;
                model.position.z = -center.z;
                model.rotation.set(0, 0, 0); // Force face forward (+Z or towards camera)

                scene.add(model);

                // Animations (Procedural Fallback)
                // Initialize Procedural Stance (ALWAYS)

                // stanceController.init() MOVED to after material setup to prevent overwrite

                if (gltf.animations && gltf.animations.length) {
                    window.mixer = new THREE.AnimationMixer(model);
                    const idle = gltf.animations.find(a => a.name.toLowerCase().includes('idle')) || gltf.animations[0];
                    window.mixer.clipAction(idle).play();
                }

                // Setup Heatmap Materials
                model.traverse(child => {
                    if (child.isMesh) {
                        const name = child.name.toLowerCase();
                        // SKIP DEBUG SPHERES
                        if (child.name.includes('Debug')) return;

                        child.castShadow = true;
                        child.receiveShadow = true;

                        // Visibility Logic
                        if (name.includes('glasses') || name.includes('shoes')) {
                            child.visible = false;
                        } else {
                            // Premium "Statue" Material
                            child.material = new THREE.MeshStandardMaterial({
                                color: 0xe0e0e0,
                                roughness: 0.3,
                                metalness: 0.15,
                                envMapIntensity: 1.0,
                                side: THREE.DoubleSide
                            });

                            // Heatmap Shader override
                            applyHeatmapShader(child);

                            // DEBUG: Apply Color Coding for Parts
                            const lname = name.toLowerCase();
                            if (lname.includes('head')) child.material.color.setHex(0xFF5252); // Red
                            else if (lname.includes('spine') || lname.includes('chest') || lname.includes('hip')) child.material.color.setHex(0x448AFF); // Blue
                            else if (lname.includes('arm')) child.material.color.setHex(0x69F0AE); // Green
                            else if (lname.includes('hand')) child.material.color.setHex(0xFFD740); // Yellow
                            else if (lname.includes('leg')) child.material.color.setHex(0xE040FB); // Purple
                            else if (lname.includes('foot')) child.material.color.setHex(0xFF6E40); // Orange
                        }
                    }
                });

                // Initialize Procedural Stance (Now that materials are set)
                // Check if stanceController is loaded, otherwise it will be init by the script loader
                if (window.stanceController && window.stanceController.init) {
                    window.stanceController.init();
                }

                // Notify Flutter that everything is ready
                if (window.FlutterChannel) {
                    window.FlutterChannel.postMessage(JSON.stringify({ type: 'model_loaded' }));
                }

                // Trigger initial update
                if (window.pendingHeatmap) {
                    window.setMuscleHeatmap(window.pendingHeatmap);
                    window.pendingHeatmap = null;
                }
            }
            window.onModelLoaded = onModelLoaded;

            // Expose Loader for Base64 (Flutter Injection)
            window._actualLoadGLTFFromBase64 = function (base64Data) {
                console.log("Received Base64 Model Data");
                try {
                    const dataUri = 'data:model/gltf-binary;base64,' + base64Data;
                    loader.load(dataUri, onModelLoaded, undefined, function (error) {
                        console.error('Error loading Base64 model:', error);
                    });
                } catch (e) {
                    console.error("Exception loading Base64 model", e);
                }
            };

            // Re-check for pending data now that we have the actual loader
            if (window._pendingModelData) {
                window._actualLoadGLTFFromBase64(window._pendingModelData);
                window._pendingModelData = null;
            }

            // NO DEFAULT LOAD: 'model.glb' fails on Android WebView via file://
            // We wait for Flutter to inject the model via window.loadGLTFFromBase64
            console.log("3D Viewer initialized. Waiting for injection.");

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2 - 0.1; // Restrict camera to stay above ground
            controls.minDistance = 1.5;
            controls.maxDistance = 6;
            controls.target.set(0, 1.0, 0);

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('pointerdown', onPointerDown);
            window.addEventListener('pointerup', onPointerUp); // For hold cancellation
            window.addEventListener('pointercancel', onPointerUp);
        }

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.isPlayerStunned = false;
        window.playerStunEndTime = 0;
        let boxingHoldTimer = null; // Timer for 6s hold
        window.boxingEnabled = true;

        window.setBoxingEnabled = function (enabled) {
            window.boxingEnabled = enabled;
            console.log("Boxing Enabled set to:", enabled);
        };

        // === SOUND EFFECTS SYSTEM (Web Audio API Synthesized) ===
        let audioCtx = null;
        function getAudioContext() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            return audioCtx;
        }

        window.playPunchSound = function () {
            const ctx = getAudioContext();
            // Whoosh sound - white noise fading out
            const bufferSize = ctx.sampleRate * 0.1;
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize) * 0.3;
            }
            const source = ctx.createBufferSource();
            source.buffer = buffer;
            const filter = ctx.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 800;
            source.connect(filter).connect(ctx.destination);
            source.start();
        };

        window.playHitSound = function (isCritical = false) {
            const ctx = getAudioContext();
            // Impact thud - low frequency sine + noise
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.frequency.value = isCritical ? 80 : 120;
            osc.type = 'sine';
            gain.gain.setValueAtTime(isCritical ? 0.5 : 0.3, ctx.currentTime);
            gain.gain.exponentialDecayTo = 0.01;
            gain.gain.setTargetAtTime(0.01, ctx.currentTime, 0.08);
            osc.connect(gain).connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + 0.15);

            // Add noise crunch
            const bufferSize = ctx.sampleRate * 0.08;
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize) * 0.4;
            }
            const noise = ctx.createBufferSource();
            noise.buffer = buffer;
            const noiseFilter = ctx.createBiquadFilter();
            noiseFilter.type = 'lowpass';
            noiseFilter.frequency.value = 1000;
            noise.connect(noiseFilter).connect(ctx.destination);
            noise.start();
        };

        window.playBlockSound = function () {
            const ctx = getAudioContext();
            // Metallic clang - high frequency with quick decay
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.frequency.value = 600;
            osc.type = 'triangle';
            gain.gain.setValueAtTime(0.25, ctx.currentTime);
            gain.gain.setTargetAtTime(0.01, ctx.currentTime, 0.05);
            osc.connect(gain).connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + 0.1);
        };

        window.playBellSound = function () {
            const ctx = getAudioContext();
            // Classic boxing bell - high ping with reverb
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.frequency.value = 1200;
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.4, ctx.currentTime);
            gain.gain.setTargetAtTime(0.01, ctx.currentTime, 0.5);
            osc.connect(gain).connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + 1.0);
        };

        // === SLIP & DUCK SYSTEM ===
        let touchStartX = 0;
        let touchStartY = 0;
        let slipDirection = null; // 'left', 'right', 'duck'
        let slipEndTime = 0;
        const SLIP_THRESHOLD = 50; // Pixels
        const SLIP_DURATION = 400; // ms

        window.addEventListener('touchstart', (e) => {
            if (!gameMode) return;
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, { passive: true });

        window.addEventListener('touchmove', (e) => {
            if (!gameMode || slipEndTime > Date.now()) return; // Already slipping

            const dx = e.touches[0].clientX - touchStartX;
            const dy = e.touches[0].clientY - touchStartY;

            // Detect Slip Left
            if (dx < -SLIP_THRESHOLD && Math.abs(dy) < SLIP_THRESHOLD) {
                slipDirection = 'left';
                slipEndTime = Date.now() + SLIP_DURATION;
                console.log("ðŸƒ SLIP LEFT!");
                // Camera tilt effect
                if (camera) camera.rotation.z = 0.15;
                setTimeout(() => { if (camera) camera.rotation.z = 0; }, SLIP_DURATION);
            }
            // Detect Slip Right
            else if (dx > SLIP_THRESHOLD && Math.abs(dy) < SLIP_THRESHOLD) {
                slipDirection = 'right';
                slipEndTime = Date.now() + SLIP_DURATION;
                console.log("ðŸƒ SLIP RIGHT!");
                if (camera) camera.rotation.z = -0.15;
                setTimeout(() => { if (camera) camera.rotation.z = 0; }, SLIP_DURATION);
            }
            // Detect Duck
            else if (dy > SLIP_THRESHOLD && Math.abs(dx) < SLIP_THRESHOLD) {
                slipDirection = 'duck';
                slipEndTime = Date.now() + SLIP_DURATION;
                console.log("ðŸ¦† DUCK!");
                // Camera dip effect
                if (camera) camera.position.y -= 0.3;
                setTimeout(() => { if (camera) camera.position.y += 0.3; }, SLIP_DURATION);
            }
        }, { passive: true });

        // Expose for AI hit check
        window.isPlayerSlipping = () => Date.now() < slipEndTime;
        window.getSlipDirection = () => slipDirection;

        function onPointerUp() {
            if (boxingHoldTimer) {
                clearTimeout(boxingHoldTimer);
                boxingHoldTimer = null;
                // console.log("Hold cancelled");
            }
        }

        function onPointerDown(event) {
            if (!model) return;

            // Start 3s Hold Timer for Boxing Mode (Only if not already in game AND enabled)
            if (!gameMode && window.boxingEnabled) {
                if (boxingHoldTimer) clearTimeout(boxingHoldTimer);
                boxingHoldTimer = setTimeout(() => {
                    console.log("3s Hold Complete -> Starting Boxing Game");
                    startBoxingGame();
                    boxingHoldTimer = null;
                }, 3000);
            }

            // STUN CHECK: Ignore input if stunned
            if (gameMode && window.isPlayerStunned) {
                if (Date.now() < window.playerStunEndTime) {
                    console.log("ðŸ˜µ Player is stunned! Cannot attack.");
                    return;
                } else {
                    window.isPlayerStunned = false;
                }
            }

            // Start Long-Press timer for Guarding (In-Game Only)
            if (gameMode) {
                window.chargeStartTime = Date.now(); // Track for Charged Punch

                if (window.stanceController) {
                    if (window.stanceController.guardTimer) clearTimeout(window.stanceController.guardTimer);
                    window.stanceController.guardTimer = setTimeout(() => {
                        window.setGuarding(true);
                        window.playerIsCharging = true; // Enter Charge Mode
                        console.log("âš¡ CHARGING PUNCH...");

                        // Visual Feedback: Add pulsing indicator
                        let indicator = document.getElementById('charge-indicator');
                        if (!indicator) {
                            indicator = document.createElement('div');
                            indicator.id = 'charge-indicator';
                            indicator.style.cssText = `
                                position: fixed; bottom: 120px; left: 50%; transform: translateX(-50%);
                                background: radial-gradient(circle, rgba(255,200,0,0.8), transparent);
                                width: 60px; height: 60px; border-radius: 50%;
                                animation: pulse 0.3s ease-in-out infinite alternate;
                                pointer-events: none; z-index: 1001;
                            `;
                            document.body.appendChild(indicator);
                            // Add keyframes if not exist
                            if (!document.getElementById('charge-keyframes')) {
                                const style = document.createElement('style');
                                style.id = 'charge-keyframes';
                                style.textContent = `@keyframes pulse { from { transform: translateX(-50%) scale(1); opacity: 0.6; } to { transform: translateX(-50%) scale(1.3); opacity: 1; } }`;
                                document.head.appendChild(style);
                            }
                        }
                        indicator.style.display = 'block';
                    }, 500); // 500ms to start charging
                }
            }

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(model, true);

            // FILTER FOR VISIBLE MESHES ONLY (Fixes unselectable muscles)
            let hit = null;
            for (let i = 0; i < intersects.length; i++) {
                if (intersects[i].object.visible) {
                    hit = intersects[i];
                    break;
                }
            }

            if (hit) {
                // Tapped the BODY
                const muscle = getMuscleAtPoint(hit.point);

                if (gameMode) {
                    // PARRY SYSTEM: Check if AI is mid-attack
                    if (window.aiController && window.aiController.lungeState && !window.aiController.lungeState.hitTriggered) {
                        const now = Date.now();
                        const state = window.aiController.lungeState;
                        const elapsed = now - state.startTime;
                        const progress = elapsed / state.duration;

                        // PARRY WINDOW: 40-60% of attack swing
                        if (progress >= 0.40 && progress <= 0.60) {
                            console.log("ðŸ›¡ï¸ PERFECT PARRY!");

                            // 1. Cancel AI attack
                            window.aiController.cancelAttack();

                            // 2. Stagger AI (longer stun)
                            window.aiController.isStunned = true;
                            window.aiController.stunEndTime = Date.now() + 1200; // 1.2s stun

                            // 3. Give player counter window
                            window.aiController.counterWindowEnd = Date.now() + 800;

                            // Visual feedback
                            document.body.style.backgroundColor = 'rgba(0,255,100,0.2)';
                            setTimeout(() => document.body.style.backgroundColor = 'transparent', 150);

                            // Don't process as normal hit - parry consumed the input
                            return;
                        }
                    }

                    handleGameHit(muscle, hit.point);
                } else if (muscle) {
                    // console.log("Hit muscle:", muscle, "at", hit.point);
                    if (window.FlutterChannel) {
                        window.FlutterChannel.postMessage(JSON.stringify({ type: 'muscle_tap', name: muscle }));
                    }
                }
            } else {
                // Tapped background
                // Hold timer is already running, nothing specific to do here for tap counting anymore
            }
        }

        function startBoxingGame() {
            if (gameMode) return;
            console.log("ðŸ¥Š BOXING GAME STARTING...");

            // SOUND: Boxing bell
            if (window.playBellSound) window.playBellSound();

            // 1. Hide Muscle Status (Heatmap) Gracefully
            // Cache current logic status to restore later
            window._cachedHeatmapState = { ...activeHeatmap };
            // Clear the logical heatmap so it doesn't bleed into the fight
            window.resetHeatmap();

            // 2. Full Screen Mode for Immersion
            const elem = document.documentElement;
            try {
                if (elem.requestFullscreen) {
                    elem.requestFullscreen().catch(err => console.log("Fullscreen blocked:", err));
                } else if (elem.webkitRequestFullscreen) { /* Safari */
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) { /* IE11 */
                    elem.msRequestFullscreen();
                }
            } catch (e) {
                console.log("Fullscreen request failed", e);
            }

            if (model) {
                model.position.set(0, 0, 0);
                model.rotation.set(0, 0, 0); // Ensure facing forward
            }
            isZooming = false;

            gameMode = true;
            modelHealth = 100;
            playerHealth = 100;
            gameScore = 0;
            comboCount = 0;

            // Show Arena Elements (Tournament Mode)
            if (window.groundGroup) window.groundGroup.visible = true;
            if (window.particleSystem) window.particleSystem.visible = true;
            if (window.gameSpot1) window.gameSpot1.visible = true;
            if (window.gameSpot2) window.gameSpot2.visible = true;

            // Enable AI
            if (window.aiController) {
                window.aiController.enabled = true;
                window.aiController.lastAttackTime = Date.now();
            }

            if (window.mixer) window.mixer.stopAllAction();
            if (window.setCombatMode) window.setCombatMode(true);

            // Intro Camera Sequence (Full View first)
            if (window.controls && window.camera) {
                controls.enabled = false;

                // 1. Show Upper Body (Hips to Head)
                // Y=1.45 centers slightly higher (Upper Chest), pushing hips down.
                camera.position.set(0, 1.45, 2.5);
                controls.target.set(0, 1.45, 0); // Important: Update controls target too
                controls.update(); // FORCE UPDATE to sync state before disabling
                camera.lookAt(0, 1.45, 0);

                controls.enabled = false;

                showGameUI();
            }

            // Cleanup old lights/debug
            if (scene.getObjectByName("debug_cube")) scene.remove(scene.getObjectByName("debug_cube"));
            if (scene.getObjectByName("game_ambient")) scene.remove(scene.getObjectByName("game_ambient"));

            const amb = new THREE.AmbientLight(0xffffff, 1.5);
            amb.name = "game_ambient";
            scene.add(amb);

            // GEOMETRY & MATERIAL FIX (Strip Shaders) -> Moved to happen immediately for perf
            // (But maybe we want to keep heatmap for the intro 2s? nah, strip it to indicate change)
            if (model) {
                model.scale.set(1.2, 1.2, 1.2); // Scale up for fight
                model.updateMatrixWorld(true);
                model.traverse(c => {
                    if (c.isMesh && c.visible) {
                        c.frustumCulled = false;
                        c.renderOrder = 0;
                        if (c.material && c.material.type !== 'MeshStandardMaterial') {
                            c.material = new THREE.MeshStandardMaterial({
                                map: c.material.map,
                                normalMap: c.material.normalMap,
                                roughnessMap: c.material.roughnessMap,
                                color: c.material.color,
                                roughness: 0.6,
                                metalness: 0.1,
                                skinning: true,
                                side: THREE.DoubleSide
                            });
                        }
                    }
                });
            }

            if (window._savedBones && window.stanceController) {
                window.stanceController.bones = window._savedBones;
                window.stanceController.targetPose = 'FIGHT';
            } else if (window.stanceController) {
                window.stanceController.targetPose = 'FIGHT';
            }

            showGameUI();

            if (window.FlutterChannel) {
                window.FlutterChannel.postMessage(JSON.stringify({ type: 'game_start', mode: 'boxing' }));
            }

            // === ROUNDS SYSTEM ===
            window.currentRound = 1;
            window.maxRounds = 3;
            window.roundDuration = 30; // 30 seconds per round (1.30m total)
            window.roundTimeRemaining = window.roundDuration;
            window.isResting = false;
            window.roundDamageDealt = 0; // Track for scoring
            window.roundDamageTaken = 0;

            startRoundTimer();
        }

        // === ROUNDS SYSTEM FUNCTIONS ===
        let roundTimerInterval = null;

        function startRoundTimer() {
            if (roundTimerInterval) clearInterval(roundTimerInterval);

            window.roundTimeRemaining = window.roundDuration;
            updateRoundUI();

            roundTimerInterval = setInterval(() => {
                if (!gameMode || window.isResting) return;

                window.roundTimeRemaining--;
                updateRoundUI();

                if (window.roundTimeRemaining <= 0) {
                    endRound();
                }
            }, 1000);
        }

        function updateRoundUI() {
            let timerEl = document.getElementById('round-timer');
            if (!timerEl) {
                timerEl = document.createElement('div');
                timerEl.id = 'round-timer';
                timerEl.style.cssText = `
                    position: fixed; top: 50px; left: 50%; transform: translateX(-50%);
                    font-size: 24px; font-weight: bold; color: #fff;
                    text-shadow: 2px 2px 0 #000;
                    font-family: monospace; z-index: 1001;
                `;
                document.body.appendChild(timerEl);
            }

            const mins = Math.floor(window.roundTimeRemaining / 60);
            const secs = window.roundTimeRemaining % 60;
            timerEl.textContent = `Round ${window.currentRound}/${window.maxRounds} - ${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function endRound() {
            if (window.playBellSound) window.playBellSound();

            if (window.currentRound >= window.maxRounds) {
                // Game over - determine winner by damage differential
                const playerWins = window.roundDamageDealt > window.roundDamageTaken;
                endBoxingGame(playerWins);
                return;
            }

            // Instruction overlay (brief transition)
            window.isResting = true;
            window.aiController.enabled = false;

            const instructions = [
                "KEEP MOVING! DON'T BE A SITTING DUCK.",
                "WATCH FOR THE HOOKS! SLIP LEFT OR RIGHT.",
                "USE YOUR CHARGED PUNCH FOR BIG DAMAGE.",
                "DON'T SPAM! WATCH YOUR STAMINA.",
                "PARRY THE AI ATTACKS TO STUN THEM!",
                "DUCK UNDER THE STRAIGHTS!"
            ];
            const randomInstruction = instructions[Math.floor(Math.random() * instructions.length)];

            // Show instruction overlay
            const restOverlay = document.createElement('div');
            restOverlay.id = 'rest-overlay';
            restOverlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.85); z-index: 10000;
                display: flex; align-items: center; justify-content: center;
                flex-direction: column; color: #fff; font-family: 'Outfit', sans-serif;
                text-align: center; padding: 20px;
            `;
            restOverlay.innerHTML = `
                <div style="font-size: 32px; color: #aaa; margin-bottom: 10px;">Round ${window.currentRound} Complete!</div>
                <div style="font-size: 48px; font-weight: bold; color: #ffcc00; margin-bottom: 30px;">GET READY!</div>
                <div style="font-size: 24px; color: #fff; max-width: 80%; line-height: 1.4;">${randomInstruction}</div>
                <div id="rest-countdown" style="font-size: 64px; margin-top: 40px; font-family: monospace;">3</div>
            `;
            document.body.appendChild(restOverlay);

            // Health recovery (20%)
            modelHealth = Math.min(100, modelHealth + 20);
            playerHealth = Math.min(100, playerHealth + 20);
            updateGameUI();

            let restTime = 3; // Shortened to 3 seconds
            const restInterval = setInterval(() => {
                restTime--;
                const countdown = document.getElementById('rest-countdown');
                if (countdown) countdown.textContent = restTime;

                if (restTime <= 0) {
                    clearInterval(restInterval);
                    restOverlay.remove();
                    window.isResting = false;
                    window.currentRound++;
                    window.aiController.enabled = true;
                    if (window.playBellSound) window.playBellSound();
                    startRoundTimer();
                }
            }, 1000);
        }

        function handleGameHit(muscle, point) {
            if (!gameMode) return;

            // CLEAR GUARD TIMER: If we are attacking, we are not guarding
            if (window.stanceController && window.stanceController.guardTimer) {
                clearTimeout(window.stanceController.guardTimer);
                window.stanceController.guardTimer = null;
            }
            window.setGuarding(false);

            let damage = 5;
            let isWeakPoint = false;
            let hitText = "HIT!";
            let isCritical = false;

            // CHARGED PUNCH: Apply 2x damage if charged
            if (window.playerChargedPunch) {
                damage *= 2;
                hitText = "POWER!";
                isCritical = true;
                console.log("ðŸ’¥ CHARGED PUNCH LANDED! 2x Damage!");
                window.playerChargedPunch = false; // Consume charge
            }

            // CHECK GUARD (Damage Mitigation)
            if (window.stanceController && window.stanceController.targetPose === 'GUARD') {
                damage *= 0.3; // Blocked damage
                hitText = "BLOCKED";
                if (window.playBlockSound) window.playBlockSound();
            }

            // CHECK COUNTER WINDOW (Bonus Damage)
            if (window.aiController && window.aiController.counterWindowEnd && Date.now() < window.aiController.counterWindowEnd) {
                damage *= 2; // Double damage during counter window
                hitText = "COUNTER!";
                isCritical = true;
                console.log("âš¡ COUNTER HIT! 2x Damage!");
                window.aiController.counterWindowEnd = 0; // Consume the window
            }

            // 1. Weak Point (Anatomical)
            const weakPoints = ['Neck', 'Chest', 'Upper Abs', 'Lower Abs'];
            if (muscle && weakPoints.includes(muscle)) {
                damage = 4;
                isWeakPoint = true;
                hitText = "SOLID!";
            }

            // 2. Tired Spot (Heatmap Logic)
            if (muscle && activeHeatmap[muscle] > 0.6) {
                damage += 6; // Moderate Bonus
                isCritical = true;
                isWeakPoint = true;
                hitText = "TIRED SPOT!";
                gameScore += 100; // Extra points
            }

            if (!muscle) {
                damage = 1; // Glancing hit
            }

            modelHealth -= damage;
            gameScore += damage * (comboCount + 1);
            window.roundDamageDealt += damage;

            const now = Date.now();
            if (now - gameLastHitTime < 1000) {
                comboCount++;
            } else {
                comboCount = 0;
            }
            gameLastHitTime = now;

            // Procedural Twitch/Block React
            if (window.stanceController && window.stanceController.triggerHit) {
                window.stanceController.triggerHit(muscle, point, isCritical);
            }

            // === HIT VFX: Impact Particles ===
            spawnHitVFX(point, isCritical);

            // === SOUND: Play hit impact ===
            if (window.playHitSound) window.playHitSound(isCritical);

            // CANCEL ATTACK & TRIGGER GUARD
            if (window.aiController) {
                window.aiController.cancelAttack();

                // NOTIFY AI OF HIT (For Spam Detection)
                if (window.aiController.registerPlayerHit) {
                    window.aiController.registerPlayerHit();
                }

                // Reactive Guard (try to block next hit)
                if (Math.random() < 0.4 && !window.aiController.isGuarding) {
                    setTimeout(() => { if (window.aiController) window.aiController.activateGuard() }, 300);
                }
            }

            // Visual feedback - flash red (brighter if critical)
            flashModelColor(isCritical ? 0xffaa00 : (isWeakPoint ? 0xff0000 : 0xffffff));

            // Add Hit Marker UI? Just console for now
            if (isCritical) console.log("ðŸ”¥ CRITICAL TIRED HIT!");

            updateGameUI();

            // Update Heatmap for this hit (make it hotter)
            updateHeatmap(muscle, point);

            if (modelHealth <= 0) {
                endBoxingGame(true);
            }
        }

        function flashModelColor(color) {
            // DISABLED FOR DEBUGGING (Prevent Invisible Material)
            return;
        }

        // === HIT VFX SYSTEM ===
        function spawnHitVFX(point, isCritical) {
            if (!point || !camera) return;

            // Project 3D point to 2D screen
            const screenPos = point.clone().project(camera);
            const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;

            // Particle count based on critical
            const count = isCritical ? 10 : 6;
            const color = isCritical ? '#ffcc00' : '#ffffff';
            const size = isCritical ? 12 : 8;

            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');

                // Random direction
                const angle = (Math.PI * 2 / count) * i + (Math.random() - 0.5) * 0.5;
                const distance = 30 + Math.random() * 40;
                const dx = Math.cos(angle) * distance;
                const dy = Math.sin(angle) * distance;

                particle.style.cssText = `
                    position: fixed;
                    left: ${x}px;
                    top: ${y}px;
                    width: ${size}px;
                    height: ${size}px;
                    background: ${color};
                    border-radius: 50%;
                    pointer-events: none;
                    z-index: 10000;
                    box-shadow: 0 0 ${size}px ${color};
                    transform: translate(-50%, -50%);
                    transition: all 0.25s ease-out;
                `;
                document.body.appendChild(particle);

                // Animate outward + fade
                requestAnimationFrame(() => {
                    particle.style.left = `${x + dx}px`;
                    particle.style.top = `${y + dy}px`;
                    particle.style.opacity = '0';
                    particle.style.transform = 'translate(-50%, -50%) scale(0.3)';
                });

                // Cleanup
                setTimeout(() => particle.remove(), 300);
            }

            // Impact flash at center
            const flash = document.createElement('div');
            flash.style.cssText = `
                position: fixed;
                left: ${x}px;
                top: ${y}px;
                width: ${isCritical ? 40 : 25}px;
                height: ${isCritical ? 40 : 25}px;
                background: radial-gradient(circle, ${color} 0%, transparent 70%);
                border-radius: 50%;
                pointer-events: none;
                z-index: 9999;
                transform: translate(-50%, -50%);
                animation: hitFlash 0.15s ease-out forwards;
            `;
            document.body.appendChild(flash);

            // Add animation keyframes if not exist
            if (!document.getElementById('hit-flash-keyframes')) {
                const style = document.createElement('style');
                style.id = 'hit-flash-keyframes';
                style.textContent = `@keyframes hitFlash { from { opacity: 1; transform: translate(-50%, -50%) scale(1); } to { opacity: 0; transform: translate(-50%, -50%) scale(2); } }`;
                document.head.appendChild(style);
            }

            setTimeout(() => flash.remove(), 200);
        }

        function showGameUI() {
            // console.log("Showing Game UI...");
            let ui = document.getElementById('game-ui');
            if (!ui) {
                ui = document.createElement('div');
                ui.id = 'game-ui';
                ui.style.position = 'absolute';
                ui.style.top = '0';
                ui.style.left = '0';
                ui.style.width = '100%';
                ui.style.height = '100%';
                ui.style.pointerEvents = 'none'; // Allow clicks to pass through to canvas
                ui.style.zIndex = '1000';

                ui.innerHTML = `
                    <!-- EXIT BUTTON (Top Right) -->
                    <button id="exit-game-btn" style="
                        pointer-events: auto;
                        position: absolute;
                        top: 60px;
                        right: 20px;
                        background: #d32f2f;
                        color: white;
                        border: 2px solid white;
                        border-radius: 50%;
                        width: 32px;
                        height: 32px;
                        font-weight: bold;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        padding: 0;
                        box-shadow: 0 2px 5px rgba(0,0,0,0.3);
                    ">X</button>

                    <!-- AI / MODEL HEALTH (Bottom Left - RED) -->
                    <div style="position: absolute; bottom: 80px; left: 20px; text-align: left;">
                        <div style="font-weight: 900; color: #ff4444; font-size: 14px; margin-bottom: 4px; text-shadow: 1px 1px 2px black; font-family: sans-serif; letter-spacing: 1px;">OPPONENT</div>
                        <div style="width: 120px; height: 8px; background: rgba(0,0,0,0.5); border: 1px solid #555; border-radius: 5px; overflow: hidden;">
                            <div id="health-bar" style="width: 100%; height: 100%; background: linear-gradient(90deg, #ff4444, #b71c1c); transition: width 0.3s ease;"></div>
                        </div>
                    </div>

                    <!-- PLAYER HEALTH (Bottom Right - GREEN) -->
                    <div style="position: absolute; bottom: 80px; right: 20px; text-align: right;">
                        <div style="font-weight: 900; color: #4CAF50; font-size: 14px; margin-bottom: 4px; text-shadow: 1px 1px 2px black; font-family: sans-serif; letter-spacing: 1px;">YOU</div>
                        <div style="width: 120px; height: 8px; background: rgba(0,0,0,0.5); border: 1px solid #555; border-radius: 5px; overflow: hidden; margin-left: auto;">
                            <div id="player-health-bar" style="width: 100%; height: 100%; background: linear-gradient(90deg, #43a047, #4CAF50); transition: width 0.3s ease;"></div>
                        </div>
                    </div>
                `;
                document.body.appendChild(ui);

                // Add event listener to the button (since we just created it)
                setTimeout(() => {
                    const btn = document.getElementById('exit-game-btn');
                    if (btn) {
                        btn.onclick = function () {
                            console.log("Exit button clicked");
                            endBoxingGame(false);
                        };
                        // Also Add touch event for mobile responsiveness
                        btn.ontouchstart = function (e) {
                            e.preventDefault();
                            endBoxingGame(false);
                        };
                    }
                }, 100);
            }
            ui.style.display = 'block';
        }

        function updateGameUI() {
            const healthBar = document.getElementById('health-bar');
            const playerHealthBar = document.getElementById('player-health-bar');
            if (healthBar) healthBar.style.width = modelHealth + '%';
            if (playerHealthBar) playerHealthBar.style.width = playerHealth + '%';
        }

        function endBoxingGame(won) {
            gameMode = false;
            window.aiController.enabled = false;
            window.aiController.isAttacking = false;
            window.aiController.isGuarding = false;
            window.aiController.lungeState = null;
            window.aiController.comboQueue = [];

            // Disable procedural stance temporarily so animation can play
            window.stanceController.targetPose = null;
            if (modelHealth <= 0) {
                window.stanceController.targetPose = 'KNOCKDOWN';
            } else {
                window.stanceController.targetPose = 'IDLE';
            }
            // === KNOCKDOWN: Yamcha Death Pose ===
            if (won) {
                // Use procedural KNOCKDOWN pose (Yamcha style)
                window.stanceController.targetPose = 'KNOCKDOWN';

                // Lower model to ground
                if (model) {
                    model.position.y = 0; // Drop to floor (aligned with new ground at y=0)
                }

                // Text overlay removed as per request
            }

            // Fallback: Try built-in animation if available
            if (won && window.mixer) {
                const fallAnim = model.animations.find(a => a.name.toLowerCase().includes('fall') || a.name.toLowerCase().includes('death') || a.name.toLowerCase().includes('hit'));
                if (fallAnim) {
                    const action = window.mixer.clipAction(fallAnim);
                    action.setLoop(THREE.LoopOnce);
                    action.clampWhenFinished = true;
                    action.reset().fadeIn(0.2).play();
                    // Fade out others
                    model.animations.forEach(a => {
                        if (a !== fallAnim && window.mixer.clipAction(a).isRunning()) {
                            window.mixer.clipAction(a).fadeOut(0.2);
                        }
                    });
                }
            }

            const ui = document.getElementById('game-ui');
            if (ui) {
                ui.innerHTML = `
                    <div style="font-weight: bold; color: #ff4444; font-size: 20px; margin-bottom: 10px;">${won ? 'KNOCKOUT!' : 'FINISHED'}</div>
                `;
            }

            // INSTANT RESTORATION (No Delay)
            setTimeout(() => {
                // 1. Exit Fullscreen (End of Experience)
                if (document.exitFullscreen) {
                    document.exitFullscreen().catch(e => console.log("Exit fullscreen failed", e));
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }

                const ui = document.getElementById('game-ui');
                if (ui) ui.style.display = 'none';

                // 2. FORCE RESTORE MODEL (Position & Shaders)
                if (model) {
                    // Reset Animation Mixer
                    if (window.mixer) window.mixer.stopAllAction();

                    // Reset Position
                    model.position.set(0, 0, 0);
                    model.scale.set(1, 1, 1);

                    // Restore Shaders & Visibility
                    model.traverse(c => {
                        if (c.isMesh) {
                            // SKIP HIDDEN (Respect Original Visibility)
                            if (!c.visible) return;

                            c.frustumCulled = false;

                            // RESTORE SHADERS (Fix White Model)
                            if (c.material) {
                                c.material.opacity = 1.0;
                                c.material.transparent = false;

                                // Re-apply Heatmap Shader Logic
                                if (window.applyHeatmapShader) applyHeatmapShader(c);
                            }
                        }
                    });

                    // RESTORE HEATMAP DATA
                    if (window._cachedHeatmapState) {
                        console.log("Restoring Heatmap Data...");
                        for (let key in window._cachedHeatmapState) {
                            activeHeatmap[key] = window._cachedHeatmapState[key];
                        }
                        window._cachedHeatmapState = null;
                        updateUniforms(); // Force update
                    }
                }

                // 3. Return to Idle Stance
                if (window.setCombatMode) window.setCombatMode(false); // Sets targetPose to 'IDLE'

                // 4. Hide Arena Elements (Return to Profile Mode)
                if (window.groundGroup) window.groundGroup.visible = false;
                if (window.particleSystem) window.particleSystem.visible = false;
                if (window.gameSpot1) window.gameSpot1.visible = false;
                if (window.gameSpot2) window.gameSpot2.visible = false;

                // 5. Close the page completely (exit 3D mode)
                if (window.FlutterChannel) {
                    window.FlutterChannel.postMessage(JSON.stringify({ type: 'close_page' }));
                }
            }, 0); // Instant restoration

            if (window.FlutterChannel) {
                window.FlutterChannel.postMessage(JSON.stringify({ type: 'game_end', score: gameScore }));
            }
        }

        function getMuscleAtPoint(point) {
            let bestMuscle = null;
            let minDist = Infinity;

            muscleDefs.forEach(def => {
                let startPos = new THREE.Vector3();
                let endPos = new THREE.Vector3();

                if (def.bone) {
                    const bone = getBoneCached(def.bone);
                    if (bone) {
                        bone.getWorldPosition(startPos);
                        if (def.offset) {
                            const off = new THREE.Vector3(...def.offset);
                            const q = new THREE.Quaternion();
                            bone.getWorldQuaternion(q);
                            startPos.add(off.applyQuaternion(q));
                        }
                        endPos.copy(startPos).add(new THREE.Vector3(0, -0.01, 0));
                    }
                } else if (def.start && def.end) {
                    const sBone = getBoneCached(def.start);
                    const eBone = getBoneCached(def.end);
                    if (sBone && eBone) {
                        sBone.getWorldPosition(startPos);
                        eBone.getWorldPosition(endPos);
                        if (def.offset) {
                            const off = new THREE.Vector3(...def.offset);
                            const q = new THREE.Quaternion();
                            sBone.getWorldQuaternion(q);
                            startPos.add(off.applyQuaternion(q));
                            endPos.add(off.applyQuaternion(q));
                        }
                    }
                }

                const d = distToSegment(point, startPos, endPos);
                if (d < def.radius && d < minDist) {
                    minDist = d;
                    bestMuscle = def.name;
                }
            });

            return bestMuscle;
        }

        function distToSegment(p, a, b) {
            const pa = new THREE.Vector3().subVectors(p, a);
            const ba = new THREE.Vector3().subVectors(b, a);
            const h = THREE.MathUtils.clamp(pa.dot(ba) / ba.dot(ba), 0, 1);
            return pa.sub(ba.multiplyScalar(h)).length();
        }

        function applyHeatmapShader(mesh) {
            // Store original material reference to avoid losing textures
            const baseMaterial = mesh.material;

            mesh.material.onBeforeCompile = (shader) => {
                shader.uniforms.u_zone_starts = uniformData.u_zone_starts;
                shader.uniforms.u_zone_ends = uniformData.u_zone_ends;
                shader.uniforms.u_zone_radii = uniformData.u_zone_radii;
                shader.uniforms.u_zone_intensities = uniformData.u_zone_intensities;
                shader.uniforms.u_zone_count = uniformData.u_zone_count;

                shader.vertexShader = `
                    varying vec3 vWorldPosition;
                    ${shader.vertexShader}
                `.replace(
                    '#include <worldpos_vertex>',
                    `
                    #include <worldpos_vertex>
                    vWorldPosition = (modelMatrix * vec4(transformed, 1.0)).xyz;
                    `
                );

                shader.fragmentShader = `
                    varying vec3 vWorldPosition;
                    uniform vec3 u_zone_starts[${MAX_ZONES}];
                    uniform vec3 u_zone_ends[${MAX_ZONES}];
                    uniform float u_zone_radii[${MAX_ZONES}];
                    uniform float u_zone_intensities[${MAX_ZONES}];
                    uniform int u_zone_count;

                    float distToSegment(vec3 p, vec3 a, vec3 b) {
                        vec3 pa = p - a, ba = b - a;
                        float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
                        return length(pa - ba * h);
                    }

                    ${shader.fragmentShader}
                `.replace(
                    '#include <dithering_fragment>',
                    `
                    #include <dithering_fragment>
                    
                    float totalHeat = 0.0;
                    for (int i = 0; i < ${MAX_ZONES}; i++) {
                        if (i >= u_zone_count) break;
                        float dist = distToSegment(vWorldPosition, u_zone_starts[i], u_zone_ends[i]);
                        float radius = u_zone_radii[i];
                        if (dist < radius) {
                            float factor = 1.0 - (dist / radius);
                            totalHeat += factor * u_zone_intensities[i] * 1.5;
                        }
                    }
                    totalHeat = clamp(totalHeat, 0.0, 1.0);
                    if (totalHeat > 0.05) {
                        vec3 heatColor = vec3(1.0, 0.25, 0.0); // Vibrant Orange/Red
                        gl_FragColor.rgb = mix(gl_FragColor.rgb, heatColor, totalHeat * 0.7);
                        gl_FragColor.rgb += heatColor * totalHeat * 0.3;
                    }
                `
                );
            };
            mesh.material.needsUpdate = true;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function animate() {
            const time = Date.now();
            requestAnimationFrame(animate);

            // PERSISTENT VISIBILITY FIX (Prevent Flickering)
            if (model && gameMode) {
                model.traverse(c => {
                    if (c.isMesh) {
                        c.frustumCulled = false;
                        // c.visible = true; // REMOVED: Do not force visibility of hidden meshes (Sunglasses/Layers)
                    }
                });
            }

            // Apply Manual/Procedural Stance

            const delta = 0.016; // Assuming 60fps
            if (window.mixer) {
                window.mixer.update(delta);
            }

            const now = Date.now();
            if (window.stanceController) {
                try {
                    // IMPORTANT: Run stance controller AFTER mixer to overwrite bone rotations
                    window.stanceController.update(now);
                } catch (e) {
                    console.warn("StanceController error:", e);
                }
            }
            if (window.aiController) {
                try {
                    window.aiController.update(now);
                } catch (e) {
                    console.warn("AIController error:", e);
                }
            }

            // CAMERA CONTROL LOGIC
            if (isZooming) {
                updateZoom();
                if (controls) controls.enabled = false;
            } else {
                // Only enable controls if NOT in game mode (Boxing locks camera)
                if (window.controls) {
                    if (!gameMode) controls.enabled = true;
                    // If gameMode, controls.enabled was set to false by startBoxingGame
                }
            }

            // --- DYNAMIC ATMOSPHERE ---

            // 1. Camera Shake System
            window.shakeIntensity = 0;
            window.shakeCamera = function (intensity) {
                window.shakeIntensity = Math.min(window.shakeIntensity + intensity, 1.0);
            };

            // 2. Dust Particles
            const particleCount = 200;
            const particlesGeom = new THREE.BufferGeometry();
            const particlePositions = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount * 3; i++) {
                particlePositions[i] = (Math.random() - 0.5) * 15; // Spread
            }
            particlesGeom.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            const particlesMat = new THREE.PointsMaterial({
                color: 0xffaa00, // Golden dust
                size: 0.05,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            const particleSystem = new THREE.Points(particlesGeom, particlesMat);
            particleSystem.visible = false; // Hidden by default (Profile Mode)
            window.particleSystem = particleSystem; // Expose for game mode toggle
            scene.add(particleSystem);

            // 3. Dynamic Spotlights (Tournament Feel)
            const spot1 = new THREE.SpotLight(0xffaa00, 50.0);
            spot1.angle = 0.3;
            spot1.penumbra = 0.5;
            spot1.position.set(5, 10, 5);
            spot1.castShadow = true;
            spot1.target.position.set(0, 0, 0);
            scene.add(spot1);
            scene.add(spot1.target);

            const spot2 = new THREE.SpotLight(0x00aaff, 50.0); // Contrast blue
            spot2.angle = 0.3;
            spot2.penumbra = 0.5;
            spot2.position.set(-5, 10, -5);
            spot2.castShadow = true;
            spot2.target.position.set(0, 0, 0);
            scene.add(spot2);
            scene.add(spot2.target);

            // Hide spotlights by default (Profile Mode)
            spot1.visible = false;
            spot2.visible = false;
            window.gameSpot1 = spot1;
            window.gameSpot2 = spot2;

            function updateAtmosphere(time) {
                // Animate Particles
                const positions = particleSystem.geometry.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    const idx = i * 3;
                    positions[idx + 1] += Math.sin(time * 0.001 + positions[idx]) * 0.002; // Float Y
                    positions[idx] += Math.cos(time * 0.0005 + positions[idx + 1]) * 0.001; // Drift X
                }
                particleSystem.geometry.attributes.position.needsUpdate = true;

                // Animate Spotlights
                spot1.target.position.x = Math.sin(time * 0.0005) * 3;
                spot1.target.position.z = Math.cos(time * 0.0005) * 3;

                spot2.target.position.x = Math.sin(time * 0.0007 + Math.PI) * 3;
                spot2.target.position.z = Math.cos(time * 0.0007 + Math.PI) * 3;

                // Camera Shake
                if (window.shakeIntensity > 0) {
                    const noiseX = (Math.random() - 0.5) * window.shakeIntensity * 0.2;
                    const noiseY = (Math.random() - 0.5) * window.shakeIntensity * 0.2;
                    const noiseZ = (Math.random() - 0.5) * window.shakeIntensity * 0.2;

                    if (camera) {
                        camera.position.add(new THREE.Vector3(noiseX, noiseY, noiseZ));
                        // Dampen
                        window.shakeIntensity *= 0.9;
                        if (window.shakeIntensity < 0.01) window.shakeIntensity = 0;
                    }
                }
            }

            // SAFETY NET: Check for NaN Camera
            if (camera && (isNaN(camera.position.x) || isNaN(camera.position.y) || isNaN(camera.position.z))) {
                console.error("CAMERA BECAME NAN! RESETTING!");
                camera.near = 0.05;
                camera.updateProjectionMatrix();
                camera.position.set(0, 1.6, 3.0); // Restored original Upper Body focus
                camera.lookAt(0, 1.6, 0);
                if (controls) {
                    controls.target.set(0, 1.6, 0);
                    controls.update();
                }
            }

            if (window.controls) controls.update();
            if (gameMode) updateAtmosphere(Date.now()); // Only animate atmosphere in game mode
            updateUniforms();
            renderer.render(scene, camera);
        }

        const boneCache = {};
        function getBoneCached(name) {
            if (boneCache[name]) return boneCache[name];
            const bone = findBone(name);
            if (bone) boneCache[name] = bone;
            return bone;
        }

        function updateUniforms() {
            if (!model) return;
            let count = 0;
            const starts = uniformData.u_zone_starts.value;
            const ends = uniformData.u_zone_ends.value;
            const radii = uniformData.u_zone_radii.value;
            const intensities = uniformData.u_zone_intensities.value;

            // Hoist temporary variables to avoid GC in animation loop
            const _tempStart = new THREE.Vector3();
            const _tempEnd = new THREE.Vector3();
            const _tempOff = new THREE.Vector3();
            const _tempQ = new THREE.Quaternion();
            const _down = new THREE.Vector3(0, -0.01, 0);

            muscleDefs.forEach(def => {
                const intensity = activeHeatmap[def.name] || 0;
                if (intensity > 0) {
                    if (count >= MAX_ZONES) return;

                    // Reset temps
                    _tempStart.set(0, 0, 0);
                    _tempEnd.set(0, 0, 0);

                    if (def.bone) {
                        const bone = getBoneCached(def.bone);
                        if (bone) {
                            bone.getWorldPosition(_tempStart);
                            if (def.offset) {
                                _tempOff.set(def.offset[0], def.offset[1], def.offset[2]);
                                bone.getWorldQuaternion(_tempQ);
                                _tempStart.add(_tempOff.applyQuaternion(_tempQ));
                            }
                            _tempEnd.copy(_tempStart).add(_down);
                        }
                    } else if (def.start && def.end) {
                        const sBone = getBoneCached(def.start);
                        const eBone = getBoneCached(def.end);
                        if (sBone && eBone) {
                            sBone.getWorldPosition(_tempStart);
                            eBone.getWorldPosition(_tempEnd);
                            if (def.offset) {
                                _tempOff.set(def.offset[0], def.offset[1], def.offset[2]);
                                sBone.getWorldQuaternion(_tempQ);
                                _tempOff.applyQuaternion(_tempQ); // Rotate offset
                                _tempStart.add(_tempOff);
                                _tempEnd.add(_tempOff);
                            }
                        }
                    }

                    starts[count * 3] = _tempStart.x;
                    starts[count * 3 + 1] = _tempStart.y;
                    starts[count * 3 + 2] = _tempStart.z;
                    ends[count * 3] = _tempEnd.x;
                    ends[count * 3 + 1] = _tempEnd.y;
                    ends[count * 3 + 2] = _tempEnd.z;
                    radii[count] = def.radius;
                    intensities[count] = intensity;
                    count++;
                }
            });
            uniformData.u_zone_count.value = count;
        }

        function findBone(name) {
            if (!model) return null;
            let firstMatch = null;
            let exactMatch = null;

            model.traverse(child => {
                // Check basically everything in the hierarchy that has a name
                const cName = child.name;
                if (!cName) return;

                const isPotentialBone = child.isBone || child.type === 'Bone' || cName.toLowerCase().includes('bone') || cName.toLowerCase().includes('joint');

                // Check for exact match or standardized patterns
                if (cName === name || cName === 'Mixamo_' + name || cName.split(':').pop() === name) {
                    exactMatch = child;
                }

                // Fallback to fuzzy includes
                if (!firstMatch && cName.toLowerCase().includes(name.toLowerCase())) {
                    firstMatch = child;
                }
            });

            const result = exactMatch || firstMatch;
            return result;
        }
        // Expose globally for stanceController
        window.findBone = findBone;

        window.addEventListener('pointerup', () => {
            if (window.stanceController && window.stanceController.guardTimer) {
                clearTimeout(window.stanceController.guardTimer);
                window.stanceController.guardTimer = null;
            }

            // CHARGED PUNCH: If was charging, enable power hit
            if (window.playerIsCharging) {
                window.playerChargedPunch = true;
                console.log("âš¡ CHARGED PUNCH READY!");
                window.playerIsCharging = false;
            }

            // Hide charge indicator
            const indicator = document.getElementById('charge-indicator');
            if (indicator) indicator.style.display = 'none';

            window.setGuarding(false);
        });

        // --- PUBLIC API ---

        window.zoomToMuscle = function (muscleName) {
            console.log('Zooming to muscle:', muscleName);
            const def = muscleDefs.find(m => m.name === muscleName);
            if (!def) {
                console.warn('Muscle definition not found for:', muscleName);
                return;
            }

            // Calculate target position (center of muscle)
            let center = new THREE.Vector3();
            if (def.bone) {
                const bone = findBone(def.bone);
                if (bone) {
                    bone.getWorldPosition(center);
                    console.log(`Def ${def.name}: Bone ${bone.name} at`, center);
                    if (def.offset) {
                        const off = new THREE.Vector3(...def.offset);
                        const q = new THREE.Quaternion();
                        bone.getWorldQuaternion(q);
                        center.add(off.applyQuaternion(q));
                    }
                }
            } else if (def.start && def.end) {
                const sBone = findBone(def.start);
                const eBone = findBone(def.end);
                if (sBone && eBone) {
                    const sPos = new THREE.Vector3();
                    const ePos = new THREE.Vector3();
                    sBone.getWorldPosition(sPos);
                    eBone.getWorldPosition(ePos);
                    console.log(`Def ${def.name}: StartBone ${sBone.name} at ${sPos}, EndBone ${eBone.name} at ${ePos}`);
                    center.addVectors(sPos, ePos).multiplyScalar(0.5);

                    if (def.offset) {
                        const off = new THREE.Vector3(...def.offset);
                        const q = new THREE.Quaternion();
                        sBone.getWorldQuaternion(q);
                        center.add(off.applyQuaternion(q));
                    }
                }
            }

            console.log('Final Calculated Center:', center);

            // Set controls target to muscle center
            targetControlsTarget.copy(center);

            // Calculate optimal camera position
            // Determine viewing angle based on muscle position (front/back)
            // Ideally, we maintain current azimuth but adjust height and distance.
            // Simple heuristic to verify:
            // For now, let's keep the camera at a nice fixed distance relative to the muscle
            const offsetDir = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
            // Force a slight "up" angle if looking too flat
            if (Math.abs(offsetDir.y) < 0.2) offsetDir.y = 0.2;
            offsetDir.normalize();

            const distance = 1.0; // Zoom distance (tweak as needed)
            targetCameraPos.copy(center).add(offsetDir.multiplyScalar(distance));

            // Start Animation
            startCameraPos.copy(camera.position);
            startControlsTarget.copy(controls.target);
            zoomStartTime = Date.now();
            isZooming = true;
        };

        window.resetCamera = function () {
            // Reset to initial state
            targetControlsTarget.set(0, 1.0, 0);
            targetCameraPos.set(0, 1.2, 4.0); // Full View Default

            startCameraPos.copy(camera.position);
            startControlsTarget.copy(controls.target);
            zoomStartTime = Date.now();
            isZooming = true;
        };

        // HEATMAP LOGIC
        // const activeHeatmap = {}; // Already declared globally

        function updateHeatmap(muscle, point) {
            if (!muscle) return;

            // Increment heat
            if (!activeHeatmap[muscle]) activeHeatmap[muscle] = 0;
            activeHeatmap[muscle] += 0.3; // 3-4 hits to max out
            if (activeHeatmap[muscle] > 1.0) activeHeatmap[muscle] = 1.0;

            // "Splash" damage? Maybe slightly heat neighbors?
            // For now, simple direct heat.
        }

        // Decay Heatmap over time (in animate loop or here with setInterval)
        setInterval(() => {
            for (let m in activeHeatmap) {
                if (activeHeatmap[m] > 0) {
                    activeHeatmap[m] -= 0.05; // Cooldown
                    if (activeHeatmap[m] < 0) activeHeatmap[m] = 0;
                }
            }
        }, 1000); // Run every second

        window.setMuscleHeatmap = function (heatmap) {
            if (!model) {
                window.pendingHeatmap = heatmap;
                return;
            }
            // Clear current
            for (const key in activeHeatmap) activeHeatmap[key] = 0;

            const aliases = {
                'Upper Chest': 'Chest', 'Lower Chest': 'Chest',
                'Shoulders': ['Front Shoulders', 'Side Shoulders', 'Rear Shoulders'],
                'Traps': 'Traps',
                'Abs': ['Upper Abs', 'Lower Abs'],
                'Lower Back': 'Lower Back',
                'Adductors': 'Inner Thighs',
                'Abductors': 'Outer Thighs',
                'Hip flexors': ['Quads', 'Upper Abs']
            };
            const groups = {
                'Arms': ['Biceps', 'Triceps', 'Forearms'],
                'Legs': ['Quads', 'Hamstrings', 'Calves', 'Glutes', 'Inner Thighs', 'Outer Thighs', 'Shins'],
                'Back': ['Lats', 'Upper Back', 'Lower Back', 'Traps'],
                'Core': ['Upper Abs', 'Lower Abs', 'Obliques']
            };

            for (const key in heatmap) {
                const intensity = heatmap[key];
                if (intensity <= 0) continue;

                // Ignore non-muscle keys to prevent log pollution
                if (key === 'Cardio' || key === 'Full Body') continue;

                let targets = [key];

                // Add aliases
                if (aliases[key]) {
                    if (Array.isArray(aliases[key])) targets = targets.concat(aliases[key]);
                    else targets.push(aliases[key]);
                }

                // Add groups
                if (groups[key]) {
                    targets = targets.concat(groups[key]);
                }

                targets.forEach(t => {
                    const variants = [t, t + ' (Left)'];
                    variants.forEach(v => {
                        if (muscleDefs.some(d => d.name === v)) {
                            activeHeatmap[v] = Math.max(activeHeatmap[v] || 0, intensity);
                        }
                    });
                });
            }

        };

        window.resetHeatmap = function () {
            for (const key in activeHeatmap) activeHeatmap[key] = 0;
        };

        window.getCameraState = function () {
            return JSON.stringify({
                position: camera.position,
                target: controls.target
            });
        };

        window.setCameraState = function (stateJson) {
            try {
                const state = JSON.parse(stateJson);
                if (state.position) camera.position.set(state.position.x, state.position.y, state.position.z);
                if (state.target) controls.target.set(state.target.x, state.target.y, state.target.z);
                if (controls) controls.update();
            } catch (e) {
                console.error("Error setting camera state:", e);
            }
        };

        window.setBackgroundColor = function (color) {
            // Support hex or css color strings
            document.body.style.backgroundColor = color;
            // Also update renderer if it's not transparent anymore, but we'll stick to CSS for ease
        };

        window.setProfileView = function (side) {
            // side: 'front', 'back', 'left', 'right'
            const positions = {
                'front': { x: 0, z: 3.5 },
                'back': { x: 0, z: -3.5 },
                'left': { x: -3.5, z: 0 },
                'right': { x: 3.5, z: 0 }
            };
            const pos = positions[side] || positions['front'];

            targetCameraPos.set(pos.x, 1.2, pos.z);
            targetControlsTarget.set(0, 1.0, 0);

            startCameraPos.copy(camera.position);
            startControlsTarget.copy(controls.target);
            zoomStartTime = Date.now();
            isZooming = true;
        };

        window.setRotationMode = function (mode) {
            if (!controls) return;
            if (mode === 'horizontal') {
                controls.minPolarAngle = Math.PI * 0.5; // Lock to horizontal (90 deg)
                controls.maxPolarAngle = Math.PI * 0.5;
            } else {
                controls.minPolarAngle = 0; // Full 360 (vertical too)
                controls.maxPolarAngle = Math.PI;
            }
            controls.update();
        };

        function updateZoom() {
            if (!isZooming) return;

            const now = Date.now();
            const progress = Math.min((now - zoomStartTime) / zoomDuration, 1.0);

            // Smooth Quartic Ease Out
            const ease = 1 - Math.pow(1 - progress, 4);

            camera.position.lerpVectors(startCameraPos, targetCameraPos, ease);
            controls.target.lerpVectors(startControlsTarget, targetControlsTarget, ease);

            if (progress >= 1.0) {
                isZooming = false;
            }
        }

        console.log("3D Viewer initialized (Global Mode)");

        // Showcase trigger
        if (new URLSearchParams(window.location.search).get('showcase') === '1') {
            const script = document.createElement('script');
            script.src = 'showcase.js';
            document.body.appendChild(script);
        }
    </script>
    <script src="debug_loader.js"></script>
</body>

</html>