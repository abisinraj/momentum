<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Momentum 3D Debug (v5.1)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f0;
            color: #eee;
            touch-action: manipulation;
            /* Disables double-tap zoom */
        }

        canvas {
            display: block;
        }

        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            font-weight: 500;
            color: #888;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        #loader.hidden {
            opacity: 0;
        }
    </style>
</head>

<body>
    <div id="loader">Loading Model...</div>
    <script src="three_global.js"></script>
    <script src="BufferGeometryUtils_global.js"></script>
    <script src="GLTFLoader_global.js"></script>
    <script src="OrbitControls_global.js"></script>
    <script src="RoomEnvironment_global.js"></script>


    <script>
        // Explicitly alias globals to ensure access
        const THREE = window.THREE;
        const GLTFLoader = window.GLTFLoader;
        const OrbitControls = window.OrbitControls;
        const RoomEnvironment = window.RoomEnvironment;

        // Use global variables
        var camera, scene, renderer, model, controls;

        // --- Camera Zoom Logic State (Hoisted to avoid TDZ) ---
        let isZooming = false;
        const targetCameraPos = new THREE.Vector3();
        const targetControlsTarget = new THREE.Vector3();
        const zoomDuration = 800; // ms (Faster, smoother)
        let zoomStartTime = 0;
        const startCameraPos = new THREE.Vector3();
        const startControlsTarget = new THREE.Vector3();
        let lastTapTime = 0;
        let tapsOutsideCount = 0;
        let gameMode = false;
        let modelHealth = 100;
        let playerHealth = 100;
        let gameScore = 0;
        let comboCount = 0;
        let gameLastHitTime = 0;

        // --- MUSCLE DEFINITIONS (For Shader) ---
        // --- MUSCLE DEFINITIONS (Initially Empty - Populated by Flutter) ---
        let muscleDefs = [];

        // Function called by Flutter to set definitions
        window.updateMuscleDefs = function (defs, mirroredNames) {
            console.log('Received Muscle Defs from Flutter:', defs.length);
            muscleDefs = defs;

            // Generate Mirrored Muscles (Left Side) automatically
            // Flutter passes a list of names that should be mirrored
            mirroredNames.forEach(name => {
                const original = muscleDefs.find(m => m.name === name);
                if (original) {
                    const mirror = { ...original }; // Shallow copy

                    // Unique name for targeting
                    mirror.name = original.name + ' (Left)';

                    // Flip Bone Names (More robust replacement)
                    if (mirror.bone) mirror.bone = mirror.bone.replace('Right', 'Left').replace('right', 'left');
                    if (mirror.start) mirror.start = mirror.start.replace('Right', 'Left').replace('right', 'left');
                    if (mirror.end) mirror.end = mirror.end.replace('Right', 'Left').replace('right', 'left');

                    // NOTE: Whether to flip X depends on the rig.
                    // For Mixamo rigs, local X is often already mirrored (Right +X = World Right, Left +X = World Left).
                    // If we flip the offset, we'd actually move the point to the wrong side of the bone.
                    // Based on user feedback ("taking to wrong side"), let's NOT flip X and see if it aligns.
                    // We'll keep the shallow copy's offset.

                    muscleDefs.push(mirror);
                }
            });
            console.log('Total Muscle Zones (with mirrors):', muscleDefs.length);
        };

        // Shader Uniforms
        const MAX_ZONES = 64;
        const uniformData = {
            u_zone_starts: { value: new Float32Array(MAX_ZONES * 3) },
            u_zone_ends: { value: new Float32Array(MAX_ZONES * 3) },
            u_zone_radii: { value: new Float32Array(MAX_ZONES) },
            u_zone_intensities: { value: new Float32Array(MAX_ZONES) },
            u_zone_count: { value: 0 }
        };

        const activeHeatmap = {};

        // Efficient dependency gatekeeper
        window.isReady = false;
        window._pendingModelData = null;

        // IMPORT EXTERNAL MODULES
        // These scripts must be loaded in this order
        const loadScript = (src) => {
            return new Promise((resolve, reject) => {
                const s = document.createElement('script');
                s.src = src;
                s.onload = resolve;
                s.onerror = reject;
                document.head.appendChild(s);
            });
        };

        // Load Modules sequentially
        Promise.all([
            loadScript('js/poses.js'),
            loadScript('js/stanceController.js'),
            loadScript('js/aiController.js')
        ]).then(() => {
            console.log("âœ… All Animation Modules Loaded");
            if (model) {
                if (window.stanceController && window.stanceController.init) window.stanceController.init();
                if (window.aiController && window.aiController.init) window.aiController.init();
            }
        }).catch(err => console.error("Failed to load modules:", err));




        window.loadGLTFFromBase64 = function (base64Data) {
            if (!window.isReady) {
                console.log("3D Viewer not ready, buffering model data...");
                window._pendingModelData = base64Data;
                return;
            }

            // Existing logic will be attached to this later or we can just define it here
            // But for now, we'll keep the specialized definition inside init() but 
            // allow this top-level one to catch the early call.
            if (window._actualLoadGLTFFromBase64) {
                window._actualLoadGLTFFromBase64(base64Data);
            } else {
                window._pendingModelData = base64Data;
            }
        };

        function checkDependencies() {
            const startTime = Date.now();
            const TIMEOUT_MS = 15000;

            function check() {
                const missing = [];
                if (!window.THREE) missing.push('THREE');
                if (!window.GLTFLoader) missing.push('GLTFLoader');
                if (!window.OrbitControls) missing.push('OrbitControls');
                if (!window.RoomEnvironment) missing.push('RoomEnvironment');

                if (missing.length === 0) {
                    console.log('âœ“ 3D Viewer initialized successfully');
                    document.getElementById('loader').classList.add('hidden');
                    init();
                    animate();
                    window.isReady = true;

                    // Execute buffered model load
                    if (window._pendingModelData) {
                        console.log("Loading buffered model data...");
                        window.loadGLTFFromBase64(window._pendingModelData);
                        window._pendingModelData = null;
                    }
                    return;
                }

                if (Date.now() - startTime > TIMEOUT_MS) {
                    console.error('âŒ 3D Viewer startup failed: Missing dependencies:', missing.join(', '));
                    const loader = document.getElementById('loader');
                    loader.style.color = '#ff4444';
                    loader.innerHTML = 'Error: Missing ' + missing.join(', ');
                    return;
                }
                requestAnimationFrame(check);
            }
            check();
        }

        window.setCombatMode = function (enabled) {
            if (window.stanceController) {
                window.stanceController.targetPose = enabled ? 'FIGHT' : 'IDLE';
                console.log("ðŸ¥Š Combat Pose:", window.stanceController.targetPose);
            }
        };

        window.isPlayerGuarding = false;
        window.setGuarding = function (isGuarding) {
            if (!gameMode) return;
            window.isPlayerGuarding = isGuarding;
            console.log("ðŸ›¡ï¸ Player Guarding:", isGuarding);

            const ui = document.getElementById('game-ui');
            if (ui) {
                let msg = document.getElementById('guard-indicator');
                if (isGuarding) {
                    if (!msg) {
                        msg = document.createElement('div');
                        msg.id = 'guard-indicator';
                        msg.style.color = '#2196F3';
                        msg.style.fontWeight = 'bold';
                        msg.style.marginTop = '10px';
                        msg.innerText = 'ðŸ›¡ï¸ GUARD ACTIVATED';
                        ui.appendChild(msg);
                    }
                } else if (msg) {
                    msg.remove();
                }
            }
        };

        checkDependencies();

        window.addEventListener('resize', () => {
            if (!camera || !renderer) return;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function init() {
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio); // SUPPORT HDPI SCREENS
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x000000, 0);
            document.body.appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
            // Default Position: Closer and higher to frame upper body
            camera.position.set(0, 1.2, 4.0); // Full View Init

            scene = new THREE.Scene();

            // Environment
            const environment = new RoomEnvironment();
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environment = pmremGenerator.fromScene(environment).texture;

            const dirLight = new THREE.DirectionalLight(0xffffff, 3.0);
            dirLight.position.set(5, 10, 7.5);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 20;
            scene.add(dirLight);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);

            const loader = new GLTFLoader();

            // Function to handle the GLTF content once loaded
            function onModelLoaded(gltf) {
                model = gltf.scene;
                window.model = model;

                // Auto-center model on X and Z axes for better rotation (profile views)
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                model.position.x = -center.x;
                model.position.z = -center.z;

                scene.add(model);

                // Animations (Procedural Fallback)
                // Initialize Procedural Stance (ALWAYS)

                // stanceController.init() MOVED to after material setup to prevent overwrite

                if (gltf.animations && gltf.animations.length) {
                    window.mixer = new THREE.AnimationMixer(model);
                    const idle = gltf.animations.find(a => a.name.toLowerCase().includes('idle')) || gltf.animations[0];
                    window.mixer.clipAction(idle).play();
                }

                // Setup Heatmap Materials
                model.traverse(child => {
                    if (child.isMesh) {
                        const name = child.name.toLowerCase();
                        // SKIP DEBUG SPHERES
                        if (child.name.includes('Debug')) return;

                        child.castShadow = true;
                        child.receiveShadow = true;

                        // Visibility Logic
                        if (name.includes('glasses') || name.includes('shoes')) {
                            child.visible = false;
                        } else {
                            // Premium "Statue" Material
                            child.material = new THREE.MeshStandardMaterial({
                                color: 0xe0e0e0,
                                roughness: 0.3,
                                metalness: 0.15,
                                envMapIntensity: 1.0,
                                side: THREE.DoubleSide
                            });

                            // Heatmap Shader override
                            applyHeatmapShader(child);

                            // DEBUG: Apply Color Coding for Parts
                            const lname = name.toLowerCase();
                            if (lname.includes('head')) child.material.color.setHex(0xFF5252); // Red
                            else if (lname.includes('spine') || lname.includes('chest') || lname.includes('hip')) child.material.color.setHex(0x448AFF); // Blue
                            else if (lname.includes('arm')) child.material.color.setHex(0x69F0AE); // Green
                            else if (lname.includes('hand')) child.material.color.setHex(0xFFD740); // Yellow
                            else if (lname.includes('leg')) child.material.color.setHex(0xE040FB); // Purple
                            else if (lname.includes('foot')) child.material.color.setHex(0xFF6E40); // Orange
                        }
                    }
                });

                // Initialize Procedural Stance (Now that materials are set)
                // Check if stanceController is loaded, otherwise it will be init by the script loader
                if (window.stanceController && window.stanceController.init) {
                    window.stanceController.init();
                }

                // Notify Flutter that everything is ready
                if (window.FlutterChannel) {
                    window.FlutterChannel.postMessage(JSON.stringify({ type: 'model_loaded' }));
                }

                // Trigger initial update
                if (window.pendingHeatmap) {
                    window.setMuscleHeatmap(window.pendingHeatmap);
                    window.pendingHeatmap = null;
                }
            }
            window.onModelLoaded = onModelLoaded;

            // Expose Loader for Base64 (Flutter Injection)
            window._actualLoadGLTFFromBase64 = function (base64Data) {
                console.log("Received Base64 Model Data");
                try {
                    const dataUri = 'data:model/gltf-binary;base64,' + base64Data;
                    loader.load(dataUri, onModelLoaded, undefined, function (error) {
                        console.error('Error loading Base64 model:', error);
                    });
                } catch (e) {
                    console.error("Exception loading Base64 model", e);
                }
            };

            // Re-check for pending data now that we have the actual loader
            if (window._pendingModelData) {
                window._actualLoadGLTFFromBase64(window._pendingModelData);
                window._pendingModelData = null;
            }

            // NO DEFAULT LOAD: 'model.glb' fails on Android WebView via file://
            // We wait for Flutter to inject the model via window.loadGLTFFromBase64
            console.log("3D Viewer initialized. Waiting for injection.");

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI * 0.6; // Prevent looking under model too much
            controls.minDistance = 1.5;
            controls.maxDistance = 6;
            controls.target.set(0, 1.0, 0);

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('pointerdown', onPointerDown);
            window.addEventListener('pointerup', onPointerUp); // For hold cancellation
            window.addEventListener('pointercancel', onPointerUp);
        }

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.isPlayerStunned = false;
        window.playerStunEndTime = 0;
        let boxingHoldTimer = null; // Timer for 6s hold
        window.boxingEnabled = true;

        window.setBoxingEnabled = function (enabled) {
            window.boxingEnabled = enabled;
            console.log("Boxing Enabled set to:", enabled);
        };

        function onPointerUp() {
            if (boxingHoldTimer) {
                clearTimeout(boxingHoldTimer);
                boxingHoldTimer = null;
                // console.log("Hold cancelled");
            }
        }

        function onPointerDown(event) {
            if (!model) return;

            // Start 3s Hold Timer for Boxing Mode (Only if not already in game AND enabled)
            if (!gameMode && window.boxingEnabled) {
                if (boxingHoldTimer) clearTimeout(boxingHoldTimer);
                boxingHoldTimer = setTimeout(() => {
                    console.log("3s Hold Complete -> Starting Boxing Game");
                    startBoxingGame();
                    boxingHoldTimer = null;
                }, 3000);
            }

            // STUN CHECK: Ignore input if stunned
            if (gameMode && window.isPlayerStunned) {
                if (Date.now() < window.playerStunEndTime) {
                    console.log("ðŸ˜µ Player is stunned! Cannot attack.");
                    return;
                } else {
                    window.isPlayerStunned = false;
                }
            }

            // Start Long-Press timer for Guarding (In-Game Only)
            if (gameMode) {
                if (stanceController.guardTimer) clearTimeout(stanceController.guardTimer);
                stanceController.guardTimer = setTimeout(() => {
                    window.setGuarding(true);
                }, 200);
            }

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(model, true);

            // FILTER FOR VISIBLE MESHES ONLY (Fixes unselectable muscles)
            let hit = null;
            for (let i = 0; i < intersects.length; i++) {
                if (intersects[i].object.visible) {
                    hit = intersects[i];
                    break;
                }
            }

            if (hit) {
                // Tapped the BODY
                const muscle = getMuscleAtPoint(hit.point);

                if (gameMode) {
                    handleGameHit(muscle, hit.point);
                } else if (muscle) {
                    // console.log("Hit muscle:", muscle, "at", hit.point);
                    if (window.FlutterChannel) {
                        window.FlutterChannel.postMessage(JSON.stringify({ type: 'muscle_tap', name: muscle }));
                    }
                }
            } else {
                // Tapped background
                // Hold timer is already running, nothing specific to do here for tap counting anymore
            }
        }

        function startBoxingGame() {
            if (gameMode) return;
            console.log("ðŸ¥Š BOXING GAME STARTING...");

            // 1. Hide Muscle Status (Heatmap) Gracefully
            // Cache current logic status to restore later
            window._cachedHeatmapState = { ...activeHeatmap };
            // Clear the logical heatmap so it doesn't bleed into the fight
            window.resetHeatmap();

            // 2. Full Screen Mode for Immersion
            const elem = document.documentElement;
            try {
                if (elem.requestFullscreen) {
                    elem.requestFullscreen().catch(err => console.log("Fullscreen blocked:", err));
                } else if (elem.webkitRequestFullscreen) { /* Safari */
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) { /* IE11 */
                    elem.msRequestFullscreen();
                }
            } catch (e) {
                console.log("Fullscreen request failed", e);
            }

            if (model) model.position.set(0, 0, 0);
            isZooming = false;

            gameMode = true;
            modelHealth = 100;
            playerHealth = 100;
            gameScore = 0;
            comboCount = 0;

            // Enable AI
            if (window.aiController) {
                window.aiController.enabled = true;
                window.aiController.lastAttackTime = Date.now();
            }

            if (window.mixer) window.mixer.stopAllAction();
            if (window.setCombatMode) window.setCombatMode(true);

            // Intro Camera Sequence (Full View first)
            if (window.controls && window.camera) {
                controls.enabled = false;

                // 1. Show Upper Body (Hips to Head)
                // Y=1.45 centers slightly higher (Upper Chest), pushing hips down.
                camera.position.set(0, 1.45, 2.5);
                controls.target.set(0, 1.45, 0); // Important: Update controls target too
                camera.lookAt(0, 1.45, 0);

                showGameUI();
            }

            // Cleanup old lights/debug
            if (scene.getObjectByName("debug_cube")) scene.remove(scene.getObjectByName("debug_cube"));
            if (scene.getObjectByName("game_ambient")) scene.remove(scene.getObjectByName("game_ambient"));

            const amb = new THREE.AmbientLight(0xffffff, 1.5);
            amb.name = "game_ambient";
            scene.add(amb);

            // GEOMETRY & MATERIAL FIX (Strip Shaders) -> Moved to happen immediately for perf
            // (But maybe we want to keep heatmap for the intro 2s? nah, strip it to indicate change)
            if (model) {
                model.scale.set(1.2, 1.2, 1.2); // Scale up for fight
                model.updateMatrixWorld(true);
                model.traverse(c => {
                    if (c.isMesh && c.visible) {
                        c.frustumCulled = false;
                        c.renderOrder = 0;
                        if (c.material && c.material.type !== 'MeshStandardMaterial') {
                            c.material = new THREE.MeshStandardMaterial({
                                map: c.material.map,
                                normalMap: c.material.normalMap,
                                roughnessMap: c.material.roughnessMap,
                                color: c.material.color,
                                roughness: 0.6,
                                metalness: 0.1,
                                skinning: true,
                                side: THREE.DoubleSide
                            });
                        }
                    }
                });
            }

            if (window._savedBones && window.stanceController) {
                window.stanceController.bones = window._savedBones;
                window.stanceController.targetPose = 'FIGHT';
            } else if (window.stanceController) {
                window.stanceController.targetPose = 'FIGHT';
            }

            showGameUI();

            if (window.FlutterChannel) {
                window.FlutterChannel.postMessage(JSON.stringify({ type: 'game_start', mode: 'boxing' }));
            }
        }

        function handleGameHit(muscle, point) {
            if (!gameMode) return;

            // CLEAR GUARD TIMER: If we are attacking, we are not guarding
            if (window.stanceController && window.stanceController.guardTimer) {
                clearTimeout(window.stanceController.guardTimer);
                window.stanceController.guardTimer = null;
            }
            window.setGuarding(false);

            let damage = 5;
            let isWeakPoint = false;
            let hitText = "HIT!";
            let isCritical = false;

            // CHECK GUARD (Damage Mitigation)
            if (stanceController.targetPose === 'GUARD') {
                damage *= 0.3; // Blocked damage
                hitText = "BLOCKED";
                // Play metallic/thud sound?
            }

            // 1. Weak Point (Anatomical)
            const weakPoints = ['Neck', 'Chest', 'Upper Abs', 'Lower Abs'];
            if (muscle && weakPoints.includes(muscle)) {
                damage = 10;
                isWeakPoint = true;
                hitText = "SOLID!";
            }

            // 2. Tired Spot (Heatmap Logic)
            if (muscle && activeHeatmap[muscle] > 0.6) {
                damage += 15; // Massive Bonus
                isCritical = true;
                isWeakPoint = true;
                hitText = "TIRED SPOT!";
                gameScore += 100; // Extra points
            }

            if (!muscle) {
                damage = 2; // Generic hit
            }

            modelHealth -= damage;
            gameScore += damage * (comboCount + 1);

            const now = Date.now();
            if (now - gameLastHitTime < 1000) {
                comboCount++;
            } else {
                comboCount = 0;
            }
            gameLastHitTime = now;

            // Procedural Twitch/Block React
            if (window.stanceController && window.stanceController.triggerHit) {
                window.stanceController.triggerHit(muscle, point, isCritical);
            }

            // CANCEL ATTACK & TRIGGER GUARD
            if (window.aiController) {
                window.aiController.cancelAttack();

                // Reactive Guard (try to block next hit)
                if (Math.random() < 0.4 && !window.aiController.isGuarding) {
                    setTimeout(() => { if (window.aiController) window.aiController.activateGuard() }, 300);
                }
            }

            // Visual feedback - flash red (brighter if critical)
            flashModelColor(isCritical ? 0xffaa00 : (isWeakPoint ? 0xff0000 : 0xffffff));

            // Add Hit Marker UI? Just console for now
            if (isCritical) console.log("ðŸ”¥ CRITICAL TIRED HIT!");

            updateGameUI();

            // Update Heatmap for this hit (make it hotter)
            updateHeatmap(muscle, point);

            if (modelHealth <= 0) {
                endBoxingGame(true);
            }
        }

        function flashModelColor(color) {
            // DISABLED FOR DEBUGGING (Prevent Invisible Material)
            return;
        }

        function showGameUI() {
            // console.log("Showing Game UI...");
            let ui = document.getElementById('game-ui');
            if (!ui) {
                ui = document.createElement('div');
                ui.id = 'game-ui';
                ui.style.position = 'absolute';
                ui.style.top = '0';
                ui.style.left = '0';
                ui.style.width = '100%';
                ui.style.height = '100%';
                ui.style.pointerEvents = 'none'; // Allow clicks to pass through to canvas
                ui.style.zIndex = '1000';

                ui.innerHTML = `
                    <!-- EXIT BUTTON (Top Right) -->
                    <button id="exit-game-btn" style="
                        pointer-events: auto;
                        position: absolute;
                        top: 20px;
                        right: 20px;
                        background: #d32f2f;
                        color: white;
                        border: 2px solid white;
                        border-radius: 50%;
                        width: 32px;
                        height: 32px;
                        font-weight: bold;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        padding: 0;
                        box-shadow: 0 2px 5px rgba(0,0,0,0.3);
                    ">X</button>

                    <!-- AI / MODEL HEALTH (Top Left - RED) -->
                    <div style="position: absolute; top: 20px; left: 20px; text-align: left;">
                        <div style="font-weight: 900; color: #ff4444; font-size: 16px; margin-bottom: 4px; text-shadow: 1px 1px 2px black; font-family: sans-serif; letter-spacing: 1px;">YOU (AI)</div>
                        <div style="width: 150px; height: 10px; background: rgba(0,0,0,0.5); border: 1px solid #555; border-radius: 5px; overflow: hidden;">
                            <div id="health-bar" style="width: 100%; height: 100%; background: linear-gradient(90deg, #ff4444, #b71c1c); transition: width 0.3s ease;"></div>
                        </div>
                    </div>

                    <!-- PLAYER HEALTH (Bottom Right - GREEN) -->
                    <div style="position: absolute; bottom: 80px; right: 20px; text-align: right;">
                        <div style="font-weight: 900; color: #4CAF50; font-size: 16px; margin-bottom: 4px; text-shadow: 1px 1px 2px black; font-family: sans-serif; letter-spacing: 1px;">YOU</div>
                        <div style="width: 150px; height: 10px; background: rgba(0,0,0,0.5); border: 1px solid #555; border-radius: 5px; overflow: hidden; margin-left: auto;">
                            <div id="player-health-bar" style="width: 100%; height: 100%; background: linear-gradient(90deg, #43a047, #4CAF50); transition: width 0.3s ease;"></div>
                        </div>
                    </div>
                `;
                document.body.appendChild(ui);

                // Add event listener to the button (since we just created it)
                setTimeout(() => {
                    const btn = document.getElementById('exit-game-btn');
                    if (btn) {
                        btn.onclick = function () {
                            console.log("Exit button clicked");
                            endBoxingGame(false);
                        };
                        // Also Add touch event for mobile responsiveness
                        btn.ontouchstart = function (e) {
                            e.preventDefault();
                            endBoxingGame(false);
                        };
                    }
                }, 100);
            }
            ui.style.display = 'block';
        }

        function updateGameUI() {
            const healthBar = document.getElementById('health-bar');
            const playerHealthBar = document.getElementById('player-health-bar');
            if (healthBar) healthBar.style.width = modelHealth + '%';
            if (playerHealthBar) playerHealthBar.style.width = playerHealth + '%';
        }

        function endBoxingGame(won) {
            gameMode = false;
            aiController.enabled = false;
            aiController.isAttacking = false;
            aiController.isGuarding = false;
            aiController.lungeState = null;
            aiController.comboQueue = [];

            // Disable procedural stance temporarily so animation can play
            stanceController.targetPose = null;

            // Knockdown animation if won
            if (won && window.mixer) {
                const fallAnim = model.animations.find(a => a.name.toLowerCase().includes('fall') || a.name.toLowerCase().includes('death') || a.name.toLowerCase().includes('hit'));
                if (fallAnim) {
                    const action = window.mixer.clipAction(fallAnim);
                    action.setLoop(THREE.LoopOnce);
                    action.clampWhenFinished = true;
                    action.reset().fadeIn(0.2).play();
                    // Fade out others
                    model.animations.forEach(a => {
                        if (a !== fallAnim && window.mixer.clipAction(a).isRunning()) {
                            window.mixer.clipAction(a).fadeOut(0.2);
                        }
                    });
                }
            }

            const ui = document.getElementById('game-ui');
            if (ui) {
                ui.innerHTML = `
                    <div style="font-weight: bold; color: #ff4444; font-size: 20px; margin-bottom: 10px;">${won ? 'KNOCKOUT!' : 'FINISHED'}</div>
                    <div style="font-size: 14px; color: #888; margin-top: 10px;">Body reset in 3s...</div>
                `;
            }

            // DELAYED RESTORATION (3 Seconds)
            setTimeout(() => {
                // 1. Exit Fullscreen (End of Experience)
                if (document.exitFullscreen) {
                    document.exitFullscreen().catch(e => console.log("Exit fullscreen failed", e));
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }

                const ui = document.getElementById('game-ui');
                if (ui) ui.style.display = 'none';

                // 2. FORCE RESTORE MODEL (Position & Shaders)
                if (model) {
                    // Reset Animation Mixer
                    if (window.mixer) window.mixer.stopAllAction();

                    // Reset Position
                    model.position.set(0, 0, 0);
                    model.scale.set(1, 1, 1);

                    // Restore Shaders & Visibility
                    model.traverse(c => {
                        if (c.isMesh) {
                            // SKIP HIDDEN (Respect Original Visibility)
                            if (!c.visible) return;

                            c.frustumCulled = false;

                            // RESTORE SHADERS (Fix White Model)
                            if (c.material) {
                                c.material.opacity = 1.0;
                                c.material.transparent = false;

                                // Re-apply Heatmap Shader Logic
                                if (window.applyHeatmapShader) applyHeatmapShader(c);
                            }
                        }
                    });

                    // RESTORE HEATMAP DATA
                    if (window._cachedHeatmapState) {
                        console.log("Restoring Heatmap Data...");
                        for (let key in window._cachedHeatmapState) {
                            activeHeatmap[key] = window._cachedHeatmapState[key];
                        }
                        window._cachedHeatmapState = null;
                        updateUniforms(); // Force update
                    }
                }

                // 3. Return to Idle Stance
                if (window.setCombatMode) window.setCombatMode(false); // Sets targetPose to 'IDLE'

                // 4. Return Camera
                if (window.camera && window.controls) {
                    camera.position.set(0, 1.2, 4.0); // Full View Reset
                    controls.target.set(0, 1.0, 0); // Reset target (was 1.35/1.45 during game)

                    // UNLOCK CONTROLS
                    controls.enabled = true;
                    controls.enableZoom = true;
                    controls.enablePan = true;
                    controls.enableRotate = true;
                    controls.enableDamping = true;
                    controls.update();
                }
            }, 3000);

            if (window.FlutterChannel) {
                window.FlutterChannel.postMessage(JSON.stringify({ type: 'game_end', score: gameScore }));
            }
        }

        function getMuscleAtPoint(point) {
            let bestMuscle = null;
            let minDist = Infinity;

            muscleDefs.forEach(def => {
                let startPos = new THREE.Vector3();
                let endPos = new THREE.Vector3();

                if (def.bone) {
                    const bone = getBoneCached(def.bone);
                    if (bone) {
                        bone.getWorldPosition(startPos);
                        if (def.offset) {
                            const off = new THREE.Vector3(...def.offset);
                            const q = new THREE.Quaternion();
                            bone.getWorldQuaternion(q);
                            startPos.add(off.applyQuaternion(q));
                        }
                        endPos.copy(startPos).add(new THREE.Vector3(0, -0.01, 0));
                    }
                } else if (def.start && def.end) {
                    const sBone = getBoneCached(def.start);
                    const eBone = getBoneCached(def.end);
                    if (sBone && eBone) {
                        sBone.getWorldPosition(startPos);
                        eBone.getWorldPosition(endPos);
                        if (def.offset) {
                            const off = new THREE.Vector3(...def.offset);
                            const q = new THREE.Quaternion();
                            sBone.getWorldQuaternion(q);
                            startPos.add(off.applyQuaternion(q));
                            endPos.add(off.applyQuaternion(q));
                        }
                    }
                }

                const d = distToSegment(point, startPos, endPos);
                if (d < def.radius && d < minDist) {
                    minDist = d;
                    bestMuscle = def.name;
                }
            });

            return bestMuscle;
        }

        function distToSegment(p, a, b) {
            const pa = new THREE.Vector3().subVectors(p, a);
            const ba = new THREE.Vector3().subVectors(b, a);
            const h = THREE.MathUtils.clamp(pa.dot(ba) / ba.dot(ba), 0, 1);
            return pa.sub(ba.multiplyScalar(h)).length();
        }

        function applyHeatmapShader(mesh) {
            // Store original material reference to avoid losing textures
            const baseMaterial = mesh.material;

            mesh.material.onBeforeCompile = (shader) => {
                shader.uniforms.u_zone_starts = uniformData.u_zone_starts;
                shader.uniforms.u_zone_ends = uniformData.u_zone_ends;
                shader.uniforms.u_zone_radii = uniformData.u_zone_radii;
                shader.uniforms.u_zone_intensities = uniformData.u_zone_intensities;
                shader.uniforms.u_zone_count = uniformData.u_zone_count;

                shader.vertexShader = `
                    varying vec3 vWorldPosition;
                    ${shader.vertexShader}
                `.replace(
                    '#include <worldpos_vertex>',
                    `
                #include <worldpos_vertex>
                    vWorldPosition = (modelMatrix * vec4(transformed, 1.0)).xyz;
                `
                );

                shader.fragmentShader = `
                    uniform vec3 u_zone_starts[${MAX_ZONES}];
                    uniform vec3 u_zone_ends[${MAX_ZONES}];
                    uniform float u_zone_radii[${MAX_ZONES}];
                    uniform float u_zone_intensities[${MAX_ZONES}];
                    uniform int u_zone_count;
                    varying vec3 vWorldPosition;

                    float distToSegment(vec3 p, vec3 a, vec3 b) {
                        vec3 pa = p - a, ba = b - a;
                        float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
                    return length(pa - ba * h);
                }

                    ${shader.fragmentShader}
                `.replace(
                    '#include <dithering_fragment>',
                    `
                #include <dithering_fragment>
                    float totalHeat = 0.0;
                for (int i = 0; i < ${MAX_ZONES}; i++) {
                    if (i >= u_zone_count) break;
                        float dist = distToSegment(vWorldPosition, u_zone_starts[i], u_zone_ends[i]);
                        float radius = u_zone_radii[i];
                    if (dist < radius) {
                            float factor = 1.0 - (dist / radius);
                        totalHeat += factor * u_zone_intensities[i] * 1.5;
                    }
                }
                totalHeat = clamp(totalHeat, 0.0, 1.0);
                if (totalHeat > 0.05) {
                        vec3 heatColor = vec3(1.0, 0.25, 0.0); // Vibrant Orange/Red
                    gl_FragColor.rgb = mix(gl_FragColor.rgb, heatColor, totalHeat * 0.7);
                    // Add glow
                    gl_FragColor.rgb += heatColor * totalHeat * 0.3;
                }
                `
                );
            };
            mesh.material.needsUpdate = true;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function animate() {
            const time = Date.now();
            requestAnimationFrame(animate);

            // PERSISTENT VISIBILITY FIX (Prevent Flickering)
            if (model && gameMode) {
                model.traverse(c => {
                    if (c.isMesh) {
                        c.frustumCulled = false;
                        // c.visible = true; // REMOVED: Do not force visibility of hidden meshes (Sunglasses/Layers)
                    }
                });
            }

            // Apply Manual/Procedural Stance

            const delta = 0.016; // Assuming 60fps
            if (window.mixer) {
                window.mixer.update(delta);
            }

            const now = Date.now();
            if (window.stanceController) {
                // IMPORTANT: Run stance controller AFTER mixer to overwrite bone rotations
                window.stanceController.update(now);
            }
            if (window.aiController) window.aiController.update(now);

            // CAMERA CONTROL LOGIC
            if (isZooming) {
                updateZoom();
                if (controls) controls.enabled = false;
            } else {
                // Only enable controls if NOT in game mode (Boxing locks camera)
                if (window.controls) {
                    if (!gameMode) controls.enabled = true;
                    // If gameMode, controls.enabled was set to false by startBoxingGame
                }
            }

            // SAFETY NET: Check for NaN Camera
            if (camera && (isNaN(camera.position.x) || isNaN(camera.position.y) || isNaN(camera.position.z))) {
                console.error("CAMERA BECAME NAN! RESETTING!");
                camera.near = 0.05;
                camera.updateProjectionMatrix();
                camera.position.set(0, 1.6, 3.0); // Restored original Upper Body focus
                camera.lookAt(0, 1.6, 0);
                if (controls) {
                    controls.target.set(0, 1.6, 0);
                    controls.update();
                }
            }

            if (window.controls) controls.update();
            updateUniforms();
            renderer.render(scene, camera);
        }

        const boneCache = {};
        function getBoneCached(name) {
            if (boneCache[name]) return boneCache[name];
            const bone = findBone(name);
            if (bone) boneCache[name] = bone;
            return bone;
        }

        function updateUniforms() {
            if (!model) return;
            let count = 0;
            const starts = uniformData.u_zone_starts.value;
            const ends = uniformData.u_zone_ends.value;
            const radii = uniformData.u_zone_radii.value;
            const intensities = uniformData.u_zone_intensities.value;

            // Hoist temporary variables to avoid GC in animation loop
            const _tempStart = new THREE.Vector3();
            const _tempEnd = new THREE.Vector3();
            const _tempOff = new THREE.Vector3();
            const _tempQ = new THREE.Quaternion();
            const _down = new THREE.Vector3(0, -0.01, 0);

            muscleDefs.forEach(def => {
                const intensity = activeHeatmap[def.name] || 0;
                if (intensity > 0) {
                    if (count >= MAX_ZONES) return;

                    // Reset temps
                    _tempStart.set(0, 0, 0);
                    _tempEnd.set(0, 0, 0);

                    if (def.bone) {
                        const bone = getBoneCached(def.bone);
                        if (bone) {
                            bone.getWorldPosition(_tempStart);
                            if (def.offset) {
                                _tempOff.set(def.offset[0], def.offset[1], def.offset[2]);
                                bone.getWorldQuaternion(_tempQ);
                                _tempStart.add(_tempOff.applyQuaternion(_tempQ));
                            }
                            _tempEnd.copy(_tempStart).add(_down);
                        }
                    } else if (def.start && def.end) {
                        const sBone = getBoneCached(def.start);
                        const eBone = getBoneCached(def.end);
                        if (sBone && eBone) {
                            sBone.getWorldPosition(_tempStart);
                            eBone.getWorldPosition(_tempEnd);
                            if (def.offset) {
                                _tempOff.set(def.offset[0], def.offset[1], def.offset[2]);
                                sBone.getWorldQuaternion(_tempQ);
                                _tempOff.applyQuaternion(_tempQ); // Rotate offset
                                _tempStart.add(_tempOff);
                                _tempEnd.add(_tempOff);
                            }
                        }
                    }

                    starts[count * 3] = _tempStart.x;
                    starts[count * 3 + 1] = _tempStart.y;
                    starts[count * 3 + 2] = _tempStart.z;
                    ends[count * 3] = _tempEnd.x;
                    ends[count * 3 + 1] = _tempEnd.y;
                    ends[count * 3 + 2] = _tempEnd.z;
                    radii[count] = def.radius;
                    intensities[count] = intensity;
                    count++;
                }
            });
            uniformData.u_zone_count.value = count;
        }

        function findBone(name) {
            if (!model) return null;
            let firstMatch = null;
            let exactMatch = null;

            model.traverse(child => {
                // Check basically everything in the hierarchy that has a name
                const cName = child.name;
                if (!cName) return;

                const isPotentialBone = child.isBone || child.type === 'Bone' || cName.toLowerCase().includes('bone') || cName.toLowerCase().includes('joint');

                // Check for exact match or standardized patterns
                if (cName === name || cName === 'Mixamo_' + name || cName.split(':').pop() === name) {
                    exactMatch = child;
                }

                // Fallback to fuzzy includes
                if (!firstMatch && cName.toLowerCase().includes(name.toLowerCase())) {
                    firstMatch = child;
                }
            });

            const result = exactMatch || firstMatch;
            return result;
        }

        window.addEventListener('pointerup', () => {
            if (window.stanceController && window.stanceController.guardTimer) {
                clearTimeout(window.stanceController.guardTimer);
                window.stanceController.guardTimer = null;
            }
            window.setGuarding(false);
        });

        // --- PUBLIC API ---

        window.zoomToMuscle = function (muscleName) {
            console.log('Zooming to muscle:', muscleName);
            const def = muscleDefs.find(m => m.name === muscleName);
            if (!def) {
                console.warn('Muscle definition not found for:', muscleName);
                return;
            }

            // Calculate target position (center of muscle)
            let center = new THREE.Vector3();
            if (def.bone) {
                const bone = findBone(def.bone);
                if (bone) {
                    bone.getWorldPosition(center);
                    console.log(`Def ${def.name}: Bone ${bone.name} at`, center);
                    if (def.offset) {
                        const off = new THREE.Vector3(...def.offset);
                        const q = new THREE.Quaternion();
                        bone.getWorldQuaternion(q);
                        center.add(off.applyQuaternion(q));
                    }
                }
            } else if (def.start && def.end) {
                const sBone = findBone(def.start);
                const eBone = findBone(def.end);
                if (sBone && eBone) {
                    const sPos = new THREE.Vector3();
                    const ePos = new THREE.Vector3();
                    sBone.getWorldPosition(sPos);
                    eBone.getWorldPosition(ePos);
                    console.log(`Def ${def.name}: StartBone ${sBone.name} at ${sPos}, EndBone ${eBone.name} at ${ePos}`);
                    center.addVectors(sPos, ePos).multiplyScalar(0.5);

                    if (def.offset) {
                        const off = new THREE.Vector3(...def.offset);
                        const q = new THREE.Quaternion();
                        sBone.getWorldQuaternion(q);
                        center.add(off.applyQuaternion(q));
                    }
                }
            }

            console.log('Final Calculated Center:', center);

            // Set controls target to muscle center
            targetControlsTarget.copy(center);

            // Calculate optimal camera position
            // Determine viewing angle based on muscle position (front/back)
            // Ideally, we maintain current azimuth but adjust height and distance.
            // Simple heuristic to verify:
            // For now, let's keep the camera at a nice fixed distance relative to the muscle
            const offsetDir = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
            // Force a slight "up" angle if looking too flat
            if (Math.abs(offsetDir.y) < 0.2) offsetDir.y = 0.2;
            offsetDir.normalize();

            const distance = 1.0; // Zoom distance (tweak as needed)
            targetCameraPos.copy(center).add(offsetDir.multiplyScalar(distance));

            // Start Animation
            startCameraPos.copy(camera.position);
            startControlsTarget.copy(controls.target);
            zoomStartTime = Date.now();
            isZooming = true;
        };

        window.resetCamera = function () {
            // Reset to initial state
            targetControlsTarget.set(0, 1.0, 0);
            targetCameraPos.set(0, 1.2, 4.0); // Full View Default

            startCameraPos.copy(camera.position);
            startControlsTarget.copy(controls.target);
            zoomStartTime = Date.now();
            isZooming = true;
        };

        // HEATMAP LOGIC
        // const activeHeatmap = {}; // Already declared globally

        function updateHeatmap(muscle, point) {
            if (!muscle) return;

            // Increment heat
            if (!activeHeatmap[muscle]) activeHeatmap[muscle] = 0;
            activeHeatmap[muscle] += 0.3; // 3-4 hits to max out
            if (activeHeatmap[muscle] > 1.0) activeHeatmap[muscle] = 1.0;

            // "Splash" damage? Maybe slightly heat neighbors?
            // For now, simple direct heat.
        }

        // Decay Heatmap over time (in animate loop or here with setInterval)
        setInterval(() => {
            for (let m in activeHeatmap) {
                if (activeHeatmap[m] > 0) {
                    activeHeatmap[m] -= 0.05; // Cooldown
                    if (activeHeatmap[m] < 0) activeHeatmap[m] = 0;
                }
            }
        }, 1000); // Run every second

        window.setMuscleHeatmap = function (heatmap) {
            if (!model) {
                window.pendingHeatmap = heatmap;
                return;
            }
            // Clear current
            for (const key in activeHeatmap) activeHeatmap[key] = 0;

            const aliases = {
                'Upper Chest': 'Chest', 'Lower Chest': 'Chest',
                'Shoulders': ['Front Shoulders', 'Side Shoulders', 'Rear Shoulders'],
                'Traps': 'Traps',
                'Abs': ['Upper Abs', 'Lower Abs'],
                'Lower Back': 'Lower Back',
                'Adductors': 'Inner Thighs',
                'Abductors': 'Outer Thighs',
                'Hip flexors': ['Quads', 'Upper Abs']
            };
            const groups = {
                'Arms': ['Biceps', 'Triceps', 'Forearms'],
                'Legs': ['Quads', 'Hamstrings', 'Calves', 'Glutes', 'Inner Thighs', 'Outer Thighs', 'Shins'],
                'Back': ['Lats', 'Upper Back', 'Lower Back', 'Traps'],
                'Core': ['Upper Abs', 'Lower Abs', 'Obliques']
            };

            for (const key in heatmap) {
                const intensity = heatmap[key];
                if (intensity <= 0) continue;

                // Ignore non-muscle keys to prevent log pollution
                if (key === 'Cardio' || key === 'Full Body') continue;

                let targets = [key];

                // Add aliases
                if (aliases[key]) {
                    if (Array.isArray(aliases[key])) targets = targets.concat(aliases[key]);
                    else targets.push(aliases[key]);
                }

                // Add groups
                if (groups[key]) {
                    targets = targets.concat(groups[key]);
                }

                targets.forEach(t => {
                    const variants = [t, t + ' (Left)'];
                    variants.forEach(v => {
                        if (muscleDefs.some(d => d.name === v)) {
                            activeHeatmap[v] = Math.max(activeHeatmap[v] || 0, intensity);
                        }
                    });
                });
            }

        };

        window.resetHeatmap = function () {
            for (const key in activeHeatmap) activeHeatmap[key] = 0;
        };

        window.getCameraState = function () {
            return JSON.stringify({
                position: camera.position,
                target: controls.target
            });
        };

        window.setCameraState = function (stateJson) {
            try {
                const state = JSON.parse(stateJson);
                if (state.position) camera.position.set(state.position.x, state.position.y, state.position.z);
                if (state.target) controls.target.set(state.target.x, state.target.y, state.target.z);
                if (controls) controls.update();
            } catch (e) {
                console.error("Error setting camera state:", e);
            }
        };

        window.setBackgroundColor = function (color) {
            // Support hex or css color strings
            document.body.style.backgroundColor = color;
            // Also update renderer if it's not transparent anymore, but we'll stick to CSS for ease
        };

        window.setProfileView = function (side) {
            // side: 'front', 'back', 'left', 'right'
            const positions = {
                'front': { x: 0, z: 3.5 },
                'back': { x: 0, z: -3.5 },
                'left': { x: -3.5, z: 0 },
                'right': { x: 3.5, z: 0 }
            };
            const pos = positions[side] || positions['front'];

            targetCameraPos.set(pos.x, 1.2, pos.z);
            targetControlsTarget.set(0, 1.0, 0);

            startCameraPos.copy(camera.position);
            startControlsTarget.copy(controls.target);
            zoomStartTime = Date.now();
            isZooming = true;
        };

        window.setRotationMode = function (mode) {
            if (!controls) return;
            if (mode === 'horizontal') {
                controls.minPolarAngle = Math.PI * 0.5; // Lock to horizontal (90 deg)
                controls.maxPolarAngle = Math.PI * 0.5;
            } else {
                controls.minPolarAngle = 0; // Full 360 (vertical too)
                controls.maxPolarAngle = Math.PI;
            }
            controls.update();
        };

        function updateZoom() {
            if (!isZooming) return;

            const now = Date.now();
            const progress = Math.min((now - zoomStartTime) / zoomDuration, 1.0);

            // Smooth Quartic Ease Out
            const ease = 1 - Math.pow(1 - progress, 4);

            camera.position.lerpVectors(startCameraPos, targetCameraPos, ease);
            controls.target.lerpVectors(startControlsTarget, targetControlsTarget, ease);

            if (progress >= 1.0) {
                isZooming = false;
            }
        }

        console.log("3D Viewer initialized (Global Mode)");

        // Showcase trigger
        if (new URLSearchParams(window.location.search).get('showcase') === '1') {
            const script = document.createElement('script');
            script.src = 'showcase.js';
            document.body.appendChild(script);
        }
    </script>
    <script src="debug_loader.js"></script>
</body>

</html>