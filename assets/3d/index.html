<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mannequin V2</title>
    <style>
        body {
            margin: 0;
            background-color: transparent;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #eee;
        }

        canvas {
            display: block;
        }

        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            font-weight: 500;
            color: #888;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        #loader.hidden {
            opacity: 0;
        }
    </style>
</head>

<body>
    <div id="loader">Loading Model...</div>
    <script src="three_global.js"></script>
    <script src="BufferGeometryUtils_global.js"></script>
    <script src="GLTFLoader_global.js"></script>
    <script src="OrbitControls_global.js"></script>
    <script src="RoomEnvironment_global.js"></script>

    <script>
        // Explicitly alias globals to ensure access
        const THREE = window.THREE;
        const GLTFLoader = window.GLTFLoader;
        const OrbitControls = window.OrbitControls;
        const RoomEnvironment = window.RoomEnvironment;

        // Use global variables
        var camera, scene, renderer, model, controls;

        // --- Camera Zoom Logic State (Hoisted to avoid TDZ) ---
        let isZooming = false;
        const targetCameraPos = new THREE.Vector3();
        const targetControlsTarget = new THREE.Vector3();
        const zoomDuration = 1000; // ms
        let zoomStartTime = 0;
        const startCameraPos = new THREE.Vector3();
        const startControlsTarget = new THREE.Vector3();

        // --- MUSCLE DEFINITIONS (For Shader) ---
        const muscleDefs = [
            // UPPER BODY
            { name: 'Neck', bone: 'Neck', radius: 0.10 },
            { name: 'Traps', bone: 'Spine2', radius: 0.18, offset: [0, 0.2, -0.1] },
            { name: 'Chest', bone: 'Spine2', radius: 0.20, offset: [0, -0.05, 0.15] },
            { name: 'Upper Back', bone: 'Spine2', radius: 0.20, offset: [0, 0.1, -0.1] },
            { name: 'Lats', bone: 'Spine1', radius: 0.22, offset: [0, 0.15, -0.1] },
            { name: 'Lower Back', bone: 'Spine', radius: 0.20, offset: [0, 0.05, -0.12] },

            // SHOULDERS (Sub-divided)
            { name: 'Front Shoulders', bone: 'RightArm', radius: 0.14, offset: [0, 0.05, 0.12] },
            { name: 'Front Shoulders', bone: 'LeftArm', radius: 0.14, offset: [0, 0.05, 0.12] },
            { name: 'Side Shoulders', bone: 'RightArm', radius: 0.12, offset: [0.08, 0.05, 0] },
            { name: 'Side Shoulders', bone: 'LeftArm', radius: 0.12, offset: [-0.08, 0.05, 0] },
            { name: 'Rear Shoulders', bone: 'RightArm', radius: 0.12, offset: [0, 0.05, -0.08] },
            { name: 'Rear Shoulders', bone: 'LeftArm', radius: 0.12, offset: [0, 0.05, -0.08] },

            // ARMS
            { name: 'Biceps', start: 'RightArm', end: 'RightForeArm', radius: 0.12, offset: [0, 0, 0.06] },
            { name: 'Biceps', start: 'LeftArm', end: 'LeftForeArm', radius: 0.12, offset: [0, 0, 0.06] },
            { name: 'Triceps', start: 'RightArm', end: 'RightForeArm', radius: 0.12, offset: [0, 0, -0.06] },
            { name: 'Triceps', start: 'LeftArm', end: 'LeftForeArm', radius: 0.12, offset: [0, 0, -0.06] },
            { name: 'Forearms', start: 'RightForeArm', end: 'RightHand', radius: 0.10 },
            { name: 'Forearms', start: 'LeftForeArm', end: 'LeftHand', radius: 0.10 },

            // CORE
            { name: 'Upper Abs', bone: 'Spine2', radius: 0.16, offset: [0, -0.15, 0.14] },
            { name: 'Lower Abs', bone: 'Spine1', radius: 0.16, offset: [0, -0.05, 0.14] },
            { name: 'Obliques', bone: 'Spine1', radius: 0.14, offset: [0.12, -0.05, 0.08] },
            { name: 'Obliques', bone: 'Spine1', radius: 0.14, offset: [-0.12, -0.05, 0.08] },

            // LOWER BODY
            { name: 'Glutes', bone: 'Hips', radius: 0.22, offset: [0, -0.05, -0.15] },
            { name: 'Quads', start: 'RightUpLeg', end: 'RightLeg', radius: 0.16, offset: [0, 0, 0.08] },
            { name: 'Quads', start: 'LeftUpLeg', end: 'LeftLeg', radius: 0.16, offset: [0, 0, 0.08] },
            { name: 'Hamstrings', start: 'RightUpLeg', end: 'RightLeg', radius: 0.16, offset: [0, 0, -0.08] },
            { name: 'Hamstrings', start: 'LeftUpLeg', end: 'LeftLeg', radius: 0.16, offset: [0, 0, -0.08] },
            { name: 'Inner Thighs', start: 'RightUpLeg', end: 'RightLeg', radius: 0.16, offset: [-0.06, 0.05, 0] },
            { name: 'Inner Thighs', start: 'LeftUpLeg', end: 'LeftLeg', radius: 0.16, offset: [0.06, 0.05, 0] },
            { name: 'Outer Thighs', start: 'RightUpLeg', end: 'RightLeg', radius: 0.14, offset: [0.08, 0, 0] },
            { name: 'Outer Thighs', start: 'LeftUpLeg', end: 'LeftLeg', radius: 0.14, offset: [-0.08, 0, 0] },
            { name: 'Calves', start: 'RightLeg', end: 'RightFoot', radius: 0.10, offset: [0, 0, -0.06] },
            { name: 'Calves', start: 'LeftLeg', end: 'LeftFoot', radius: 0.10, offset: [0, 0, -0.06] },
            { name: 'Shins', start: 'RightLeg', end: 'RightFoot', radius: 0.08, offset: [0, 0, 0.06] },
            { name: 'Shins', start: 'LeftLeg', end: 'LeftFoot', radius: 0.08, offset: [0, 0, 0.06] }
        ];

        // Shader Uniforms
        const MAX_ZONES = 32;
        const uniformData = {
            u_zone_starts: { value: new Float32Array(MAX_ZONES * 3) },
            u_zone_ends: { value: new Float32Array(MAX_ZONES * 3) },
            u_zone_radii: { value: new Float32Array(MAX_ZONES) },
            u_zone_intensities: { value: new Float32Array(MAX_ZONES) },
            u_zone_count: { value: 0 }
        };

        const activeHeatmap = {};

        // Efficient dependency gatekeeper
        function checkDependencies() {
            const startTime = Date.now();
            const TIMEOUT_MS = 5000;

            function check() {
                const missing = [];
                if (typeof window.THREE === 'undefined') missing.push('THREE.js');
                else {
                    if (typeof window.THREE.BufferGeometryUtils === 'undefined') missing.push('BufferGeometryUtils');
                    if (typeof window.GLTFLoader === 'undefined') missing.push('GLTFLoader');
                    if (typeof window.OrbitControls === 'undefined') missing.push('OrbitControls');
                    if (typeof window.RoomEnvironment === 'undefined') missing.push('RoomEnvironment');
                }

                if (missing.length === 0) {
                    console.log('✓ 3D Viewer initialized successfully');
                    document.getElementById('loader').classList.add('hidden');
                    init();
                    animate();
                    return;
                }

                if (Date.now() - startTime > TIMEOUT_MS) {
                    console.error('❌ 3D Viewer startup failed: Missing dependencies:', missing.join(', '));
                    const loader = document.getElementById('loader');
                    loader.style.color = '#ff4444';
                    loader.innerHTML = 'Error: Missing ' + missing.join(', ');
                    return;
                }

                // Log status only every 500ms to avoid flooding
                if ((Date.now() - startTime) % 500 < 50) {
                    console.log('Waiting for:', missing.join(', '));
                }

                requestAnimationFrame(check);
            }

            check();
        }

        // Run dependency check
        checkDependencies();

        function init() {
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio); // SUPPORT HDPI SCREENS
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x000000, 0);
            document.body.appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.2, 3.5);

            scene = new THREE.Scene();

            // Environment
            const environment = new RoomEnvironment();
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environment = pmremGenerator.fromScene(environment).texture;

            const dirLight = new THREE.DirectionalLight(0xffffff, 3.0);
            dirLight.position.set(5, 10, 7.5);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 20;
            scene.add(dirLight);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);

            const loader = new GLTFLoader();

            // Function to handle the GLTF content once loaded
            function onModelLoaded(gltf) {
                model = gltf.scene;
                window.model = model;

                // Auto-center model on X and Z axes for better rotation (profile views)
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                model.position.x = -center.x;
                model.position.z = -center.z;

                scene.add(model);

                // Animations
                if (gltf.animations && gltf.animations.length) {
                    window.mixer = new THREE.AnimationMixer(model);
                    const idle = gltf.animations.find(a => a.name.toLowerCase().includes('idle')) || gltf.animations[0];
                    window.mixer.clipAction(idle).play();
                }

                // Setup Heatmap Materials
                model.traverse(child => {
                    if (child.isMesh) {
                        const name = child.name.toLowerCase();
                        child.castShadow = true;
                        child.receiveShadow = true;

                        // Visibility Logic
                        if (name.includes('glasses') || name.includes('shoes')) {
                            child.visible = false;
                        } else {
                            // Premium "Statue" Material
                            child.material = new THREE.MeshStandardMaterial({
                                color: 0xe0e0e0,
                                roughness: 0.3,
                                metalness: 0.15,
                                envMapIntensity: 1.0,
                                side: THREE.DoubleSide
                            });

                            // Heatmap Shader override
                            applyHeatmapShader(child);
                        }
                    }
                });

                // Trigger initial update
                if (window.pendingHeatmap) {
                    window.setMuscleHeatmap(window.pendingHeatmap);
                    window.pendingHeatmap = null;
                }
            }

            // Expose Loader for Base64 (Flutter Injection)
            window.loadGLTFFromBase64 = function (base64Data) {
                console.log("Received Base64 Model Data");
                try {
                    const dataUri = 'data:model/gltf-binary;base64,' + base64Data;
                    loader.load(dataUri, onModelLoaded, undefined, function (error) {
                        console.error('Error loading Base64 model:', error);
                    });
                } catch (e) {
                    console.error("Exception loading Base64 model", e);
                }
            };

            // Attempt default load
            const timestamp = Date.now();
            loader.load('model.glb?t=' + timestamp, onModelLoaded, undefined, function (error) {
                console.warn('Default model load failed. Waiting for Base64 injection.', error);
            });

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI * 0.6; // Prevent looking under model too much
            controls.minDistance = 1.5;
            controls.maxDistance = 6;
            controls.target.set(0, 1.0, 0);

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('pointerdown', onPointerDown);
        }

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function onPointerDown(event) {
            // Prevent interaction if model isn't ready
            if (!model) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(model, true);

            if (intersects.length > 0) {
                const hit = intersects[0];
                const muscle = getMuscleAtPoint(hit.point);
                if (muscle) {
                    console.log("Hit muscle:", muscle);
                    if (window.FlutterChannel) {
                        window.FlutterChannel.postMessage(JSON.stringify({ type: 'muscle_tap', name: muscle }));
                    }
                }
            }
        }

        function getMuscleAtPoint(point) {
            let bestMuscle = null;
            let minDist = Infinity;

            muscleDefs.forEach(def => {
                let startPos = new THREE.Vector3();
                let endPos = new THREE.Vector3();

                if (def.bone) {
                    const bone = findBone(def.bone);
                    if (bone) {
                        bone.getWorldPosition(startPos);
                        if (def.offset) {
                            const off = new THREE.Vector3(...def.offset);
                            const q = new THREE.Quaternion();
                            bone.getWorldQuaternion(q);
                            startPos.add(off.applyQuaternion(q));
                        }
                        endPos.copy(startPos).add(new THREE.Vector3(0, -0.01, 0));
                    }
                } else if (def.start && def.end) {
                    const sBone = findBone(def.start);
                    const eBone = findBone(def.end);
                    if (sBone && eBone) {
                        sBone.getWorldPosition(startPos);
                        eBone.getWorldPosition(endPos);
                        if (def.offset) {
                            const off = new THREE.Vector3(...def.offset);
                            const q = new THREE.Quaternion();
                            sBone.getWorldQuaternion(q);
                            const offW = off.applyQuaternion(q);
                            startPos.add(offW);
                            endPos.add(offW);
                        }
                    }
                }

                const d = distToSegment(point, startPos, endPos);
                if (d < def.radius && d < minDist) {
                    minDist = d;
                    bestMuscle = def.name;
                }
            });

            return bestMuscle;
        }

        function distToSegment(p, a, b) {
            const pa = new THREE.Vector3().subVectors(p, a);
            const ba = new THREE.Vector3().subVectors(b, a);
            const h = THREE.MathUtils.clamp(pa.dot(ba) / ba.dot(ba), 0, 1);
            return pa.sub(ba.multiplyScalar(h)).length();
        }

        function applyHeatmapShader(mesh) {
            // Store original material reference to avoid losing textures
            const baseMaterial = mesh.material;

            mesh.material.onBeforeCompile = (shader) => {
                shader.uniforms.u_zone_starts = uniformData.u_zone_starts;
                shader.uniforms.u_zone_ends = uniformData.u_zone_ends;
                shader.uniforms.u_zone_radii = uniformData.u_zone_radii;
                shader.uniforms.u_zone_intensities = uniformData.u_zone_intensities;
                shader.uniforms.u_zone_count = uniformData.u_zone_count;

                shader.vertexShader = `
                    varying vec3 vWorldPosition;
                    ${shader.vertexShader}
                `.replace(
                    '#include <worldpos_vertex>',
                    `
                    #include <worldpos_vertex>
                    vWorldPosition = (modelMatrix * vec4(transformed, 1.0)).xyz;
                    `
                );

                shader.fragmentShader = `
                    uniform vec3 u_zone_starts[${MAX_ZONES}];
                    uniform vec3 u_zone_ends[${MAX_ZONES}];
                    uniform float u_zone_radii[${MAX_ZONES}];
                    uniform float u_zone_intensities[${MAX_ZONES}];
                    uniform int u_zone_count;
                    varying vec3 vWorldPosition;
                    
                    float distToSegment(vec3 p, vec3 a, vec3 b) {
                        vec3 pa = p - a, ba = b - a;
                        float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
                        return length(pa - ba * h);
                    }

                    ${shader.fragmentShader}
                `.replace(
                    '#include <dithering_fragment>',
                    `
                    #include <dithering_fragment>
                    float totalHeat = 0.0;
                    for(int i = 0; i < ${MAX_ZONES}; i++) {
                        if(i >= u_zone_count) break;
                        float dist = distToSegment(vWorldPosition, u_zone_starts[i], u_zone_ends[i]);
                        float radius = u_zone_radii[i];
                        if(dist < radius) {
                            float factor = 1.0 - (dist / radius);
                            totalHeat += factor * u_zone_intensities[i] * 1.5;
                        }
                    }
                    totalHeat = clamp(totalHeat, 0.0, 1.0);
                    if(totalHeat > 0.05) {
                        vec3 heatColor = vec3(1.0, 0.25, 0.0); // Vibrant Orange/Red
                        gl_FragColor.rgb = mix(gl_FragColor.rgb, heatColor, totalHeat * 0.7);
                        // Add glow
                        gl_FragColor.rgb += heatColor * totalHeat * 0.3;
                    }
                    `
                );
            };
            mesh.material.needsUpdate = true;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (window.mixer) window.mixer.update(0.016);
            if (controls) controls.update();
            updateZoom();
            updateUniforms();
            renderer.render(scene, camera);
        }

        function updateUniforms() {
            if (!model) return;
            let count = 0;
            const starts = uniformData.u_zone_starts.value;
            const ends = uniformData.u_zone_ends.value;
            const radii = uniformData.u_zone_radii.value;
            const intensities = uniformData.u_zone_intensities.value;

            muscleDefs.forEach(def => {
                const intensity = activeHeatmap[def.name] || 0;
                // We fill the array regardless of intensity if we want it to be "targetable" 
                // but the shader only cares about > 0. 
                // Actually, for targeting, we need the positions to be correct.
                // For the shader, we only pass active zones to save uniforms.
                if (intensity > 0) {
                    if (count >= MAX_ZONES) return;
                    let startPos = new THREE.Vector3();
                    let endPos = new THREE.Vector3();

                    if (def.bone) {
                        const bone = findBone(def.bone);
                        if (bone) {
                            bone.getWorldPosition(startPos);
                            if (def.offset) {
                                const off = new THREE.Vector3(...def.offset);
                                const q = new THREE.Quaternion();
                                bone.getWorldQuaternion(q);
                                startPos.add(off.applyQuaternion(q));
                            }
                            endPos.copy(startPos).add(new THREE.Vector3(0, -0.01, 0));
                        }
                    } else if (def.start && def.end) {
                        const sBone = findBone(def.start);
                        const eBone = findBone(def.end);
                        if (sBone && eBone) {
                            sBone.getWorldPosition(startPos);
                            eBone.getWorldPosition(endPos);
                            if (def.offset) {
                                const off = new THREE.Vector3(...def.offset);
                                const q = new THREE.Quaternion();
                                sBone.getWorldQuaternion(q);
                                const offW = off.applyQuaternion(q);
                                startPos.add(offW);
                                endPos.add(offW);
                            }
                        }
                    }

                    starts[count * 3] = startPos.x;
                    starts[count * 3 + 1] = startPos.y;
                    starts[count * 3 + 2] = startPos.z;
                    ends[count * 3] = endPos.x;
                    ends[count * 3 + 1] = endPos.y;
                    ends[count * 3 + 2] = endPos.z;
                    radii[count] = def.radius;
                    intensities[count] = intensity;
                    count++;
                }
            });
            uniformData.u_zone_count.value = count;
        }

        function findBone(name) {
            let res = null;
            if (!model) return null;
            model.traverse(child => {
                if (child.isBone && child.name.includes(name)) res = child;
            });
            return res;
        }

        // --- PUBLIC API ---

        window.zoomToMuscle = function (muscleName) {
            const def = muscleDefs.find(m => m.name === muscleName);
            if (!def) return;

            // Calculate target position (center of muscle)
            let center = new THREE.Vector3();
            if (def.bone) {
                const bone = findBone(def.bone);
                if (bone) {
                    bone.getWorldPosition(center);
                    if (def.offset) {
                        const off = new THREE.Vector3(...def.offset);
                        const q = new THREE.Quaternion();
                        bone.getWorldQuaternion(q);
                        center.add(off.applyQuaternion(q));
                    }
                }
            } else if (def.start && def.end) {
                const sBone = findBone(def.start);
                const eBone = findBone(def.end);
                if (sBone && eBone) {
                    const sPos = new THREE.Vector3();
                    const ePos = new THREE.Vector3();
                    sBone.getWorldPosition(sPos);
                    eBone.getWorldPosition(ePos);
                    center.addVectors(sPos, ePos).multiplyScalar(0.5);

                    if (def.offset) {
                        // Apply offset relative to start bone rotation for stability
                        const off = new THREE.Vector3(...def.offset);
                        const q = new THREE.Quaternion();
                        sBone.getWorldQuaternion(q);
                        center.add(off.applyQuaternion(q));
                    }
                }
            }

            // Set controls target to muscle center
            targetControlsTarget.copy(center);

            // Calculate optimal camera position
            // Determine viewing angle based on muscle position (front/back)
            // Ideally, we maintain current azimuth but adjust height and distance.
            // Simple heuristic to verify:
            // For now, let's keep the camera at a nice fixed distance relative to the muscle
            const offsetDir = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
            // Force a slight "up" angle if looking too flat
            if (Math.abs(offsetDir.y) < 0.2) offsetDir.y = 0.2;
            offsetDir.normalize();

            const distance = 1.0; // Zoom distance (tweak as needed)
            targetCameraPos.copy(center).add(offsetDir.multiplyScalar(distance));

            // Start Animation
            startCameraPos.copy(camera.position);
            startControlsTarget.copy(controls.target);
            zoomStartTime = Date.now();
            isZooming = true;
        };

        window.resetCamera = function () {
            // Reset to initial state
            targetControlsTarget.set(0, 1.0, 0);
            targetCameraPos.set(0, 1.2, 3);

            startCameraPos.copy(camera.position);
            startControlsTarget.copy(controls.target);
            zoomStartTime = Date.now();
            isZooming = true;
        };

        window.setMuscleHeatmap = function (heatmap) {
            if (!model) {
                window.pendingHeatmap = heatmap;
                return;
            }
            // Clear current
            for (const key in activeHeatmap) activeHeatmap[key] = 0;

            const aliases = {
                'Upper Chest': 'Chest', 'Lower Chest': 'Chest',
                'Shoulders': ['Front Shoulders', 'Side Shoulders', 'Rear Shoulders'],
                'Traps': 'Traps',
                'Abs': ['Upper Abs', 'Lower Abs'],
                'Lower Back': 'Lower Back',
                'Adductors': 'Inner Thighs',
                'Abductors': 'Outer Thighs',
                'Hip flexors': ['Quads', 'Upper Abs']
            };
            const groups = {
                'Arms': ['Biceps', 'Triceps', 'Forearms'],
                'Legs': ['Quads', 'Hamstrings', 'Calves', 'Glutes', 'Inner Thighs', 'Outer Thighs', 'Shins'],
                'Back': ['Lats', 'Upper Back', 'Lower Back', 'Traps'],
                'Core': ['Upper Abs', 'Lower Abs', 'Obliques']
            };

            for (const key in heatmap) {
                const intensity = heatmap[key];
                if (intensity <= 0) continue;

                let targets = [key];

                // Add aliases
                if (aliases[key]) {
                    if (Array.isArray(aliases[key])) targets = targets.concat(aliases[key]);
                    else targets.push(aliases[key]);
                }

                // Add groups
                if (groups[key]) {
                    targets = targets.concat(groups[key]);
                }

                targets.forEach(t => {
                    if (activeHeatmap.hasOwnProperty(t)) {
                        activeHeatmap[t] = Math.max(activeHeatmap[t], intensity);
                    } else if (muscleDefs.some(d => d.name === t)) {
                        activeHeatmap[t] = intensity;
                    }
                });
            }

        };

        window.resetHeatmap = function () {
            for (const key in activeHeatmap) activeHeatmap[key] = 0;
        };

        window.setBackgroundColor = function (color) {
            // Support hex or css color strings
            document.body.style.backgroundColor = color;
            // Also update renderer if it's not transparent anymore, but we'll stick to CSS for ease
        };

        window.setProfileView = function (side) {
            // side: 'front', 'back', 'left', 'right'
            const positions = {
                'front': { x: 0, z: 3.5 },
                'back': { x: 0, z: -3.5 },
                'left': { x: -3.5, z: 0 },
                'right': { x: 3.5, z: 0 }
            };
            const pos = positions[side] || positions['front'];

            targetCameraPos.set(pos.x, 1.2, pos.z);
            targetControlsTarget.set(0, 1.0, 0);

            startCameraPos.copy(camera.position);
            startControlsTarget.copy(controls.target);
            zoomStartTime = Date.now();
            isZooming = true;
        };

        function updateZoom() {
            if (!isZooming) return;

            const now = Date.now();
            const progress = Math.min((now - zoomStartTime) / zoomDuration, 1.0);

            // Ease out cubic
            const ease = 1 - Math.pow(1 - progress, 3);

            camera.position.lerpVectors(startCameraPos, targetCameraPos, ease);
            controls.target.lerpVectors(startControlsTarget, targetControlsTarget, ease);

            if (progress >= 1.0) {
                isZooming = false;
            }
        }

        console.log("3D Viewer initialized (Global Mode)");

        // Showcase trigger
        if (new URLSearchParams(window.location.search).get('showcase') === '1') {
            const script = document.createElement('script');
            script.src = 'showcase.js';
            document.body.appendChild(script);
        }
    </script>
</body>

</html>