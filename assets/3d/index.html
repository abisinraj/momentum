<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0;
            background-color: transparent;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script type="module">
        import * as THREE from './three.module.js';

        let camera, scene, renderer;
        let group, particles, linesMesh;

        // Data for heatmap interaction
        // Stores which particle index belongs to which muscle group
        let currentColorsAttribute;
        let particleMap = {}; // 'chest': [0, 1, 2...]
        let originalColors = null;


        // Configuration
        const CONNECTIVITY_DISTANCE = 16;
        const COLOR_PRIMARY = new THREE.Color(0x00D9B8); // Teal
        const COLOR_SECONDARY = new THREE.Color(0xFFFFFF); // White
        const COLOR_HOT = new THREE.Color(0xFF5500); // Orange/Red for heat

        init();
        animate();

        // Expose function to Flutter/JS
        window.setMuscleHeatmap = function (data) {
            // data format: { 'Chest': 0.8, 'Legs': 0.2 } (0.0 to 1.0 intensity)
            if (!particles || !currentColorsAttribute) return;

            const colors = currentColorsAttribute.array;
            const targetColor = new THREE.Color();

            // Iterate over defined groups
            for (const groupName in data) {
                // Find visible particles belonging to this group
                // Note: We need to know which indices map to which group.
                // Refactor: We will regenerate the color buffer based on 'data'.

                const intensity = Math.max(0, Math.min(1, data[groupName]));
                if (intensity <= 0) continue;

                // Find indices for this group
                const groupIndices = particleMap[groupName.toLowerCase()];
                if (!groupIndices) continue;

                for (const i of groupIndices) {
                    // Mix primary with HOT color based on intensity
                    // Base: Random mix of Teal/White. 
                    // Heat: Lerp towards Orange.

                    // Re-calculate base (randomized statics aren't saved per particle easily without extra memory, 
                    // effectively we just push them towards HOT)

                    const baseR = colors[i * 3];
                    const baseG = colors[i * 3 + 1];
                    const baseB = colors[i * 3 + 2];

                    const baseColor = new THREE.Color(baseR, baseG, baseB);
                    const finalColor = baseColor.lerp(COLOR_HOT, intensity * 0.8);

                    colors[i * 3] = finalColor.r;
                    colors[i * 3 + 1] = finalColor.g;
                    colors[i * 3 + 2] = finalColor.b;
                }
            }
            currentColorsAttribute.needsUpdate = true;
        };

        // Reset heatmap
        window.resetHeatmap = function () {
            if (originalColors && currentColorsAttribute) {
                currentColorsAttribute.array.set(originalColors);
                currentColorsAttribute.needsUpdate = true;
            }
        };


        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 400;
            camera.position.y = 50;

            group = new THREE.Group();
            scene.add(group);

            const musclePoints = [];
            const colors = [];

            let particleIndex = 0;

            function registerParticle(groupName, index) {
                const key = groupName.toLowerCase();
                if (!particleMap[key]) particleMap[key] = [];
                particleMap[key].push(index);
            }

            // Helper: Create a muscle between two points
            function createMuscle(start, end, count, radius, bulge, groupName) {
                const curve = new THREE.LineCurve3(start, end);

                for (let i = 0; i < count; i++) {
                    const t = Math.random();
                    const point = curve.getPoint(t);
                    const shapeFactor = 4 * t * (1 - t);
                    const r = radius * (0.5 + 0.5 * shapeFactor * bulge);

                    const u = Math.random();
                    const v = Math.random();
                    const theta = 2 * Math.PI * u;
                    const phi = Math.acos(2 * v - 1);

                    const x = point.x + r * Math.sin(phi) * Math.cos(theta);
                    const y = point.y + r * Math.sin(phi) * Math.sin(theta);
                    const z = point.z + r * Math.cos(phi);

                    musclePoints.push(x, y, z);

                    // Register group
                    registerParticle(groupName, particleIndex++);

                    // Color mix
                    const mixColor = COLOR_PRIMARY.clone().lerp(COLOR_SECONDARY, Math.random() * 0.6);
                    colors.push(mixColor.r, mixColor.g, mixColor.b);
                }
            }

            // --- SKELETON & MUSCLES (REALISTIC PROPORTIONS) ---
            // Unit scale approx 1 unit = 1 cm
            // Total Height ~ 175cm

            // Center Y is roughly at hip or feet? Let's keep feet at 0.

            // Major Landmarks
            const yHeadTop = 175;
            const yNeckBase = 150;
            const yShoulder = 145;
            const yChest = 135;
            const yWaist = 110;
            const yHip = 95;
            const yKnee = 50;
            const yAnkle = 8;
            const yFoot = 0;

            // Widths (Total Width / 2)
            const xShoulder = 23; // 46cm spread
            const xHip = 15; // 30cm spread
            const xKnee = 12; // Slight stance
            const xFoot = 15; // Stance width

            // Z Depths
            const zSpine = -5;

            // Points
            const head = new THREE.Vector3(0, 168, 0); // Center of head
            const neck = new THREE.Vector3(0, yNeckBase, 0);

            const shoulderL = new THREE.Vector3(-xShoulder, yShoulder, 0);
            const shoulderR = new THREE.Vector3(xShoulder, yShoulder, 0);

            const hipL = new THREE.Vector3(-xHip, yHip, 0);
            const hipR = new THREE.Vector3(xHip, yHip, 0);

            const kneeL = new THREE.Vector3(-xKnee, yKnee, 5);
            const kneeR = new THREE.Vector3(xKnee, yKnee, 5);

            const ankleL = new THREE.Vector3(-xFoot, yAnkle, 0);
            const ankleR = new THREE.Vector3(xFoot, yAnkle, 0);

            const footL = new THREE.Vector3(-xFoot, yFoot, 15);
            const footR = new THREE.Vector3(xFoot, yFoot, 15);

            // Arms (Realistic Length & Volume)
            const yArmEnd = 78; // Reaches mid-thigh
            const yElbow = 118;

            const elbowL = new THREE.Vector3(-30, yElbow, 5);
            const elbowR = new THREE.Vector3(30, yElbow, 5);
            const handL = new THREE.Vector3(-32, yArmEnd, 10);
            const handR = new THREE.Vector3(32, yArmEnd, 10);


            // --- MUSCLE CREATION ---

            // Head & Neck
            createMuscle(new THREE.Vector3(0, yHeadTop - 10, 0), new THREE.Vector3(0, yHeadTop, 0), 100, 12, 0.4, 'Head');
            createMuscle(neck, new THREE.Vector3(0, yHeadTop - 5, 0), 80, 10, 0.2, 'Traps');

            // Torso
            // Spine/Center
            createMuscle(new THREE.Vector3(0, yNeckBase, zSpine), new THREE.Vector3(0, yHip, zSpine), 150, 14, 1.0, 'Back');

            // Traps/Shoulders upper
            createMuscle(neck, shoulderL, 50, 8, 0.5, 'Traps');
            createMuscle(neck, shoulderR, 50, 8, 0.5, 'Traps');

            // Deltoids
            createMuscle(shoulderL, new THREE.Vector3(-xShoulder, yShoulder - 10, 0), 60, 11, 1.5, 'Shoulders');
            createMuscle(shoulderR, new THREE.Vector3(xShoulder, yShoulder - 10, 0), 60, 11, 1.5, 'Shoulders');

            // Chest (Pectorals)
            createMuscle(new THREE.Vector3(-5, yChest, 10), new THREE.Vector3(-xShoulder + 10, yShoulder - 5, 5), 80, 14, 1.2, 'Chest');
            createMuscle(new THREE.Vector3(5, yChest, 10), new THREE.Vector3(xShoulder - 10, yShoulder - 5, 5), 80, 14, 1.2, 'Chest');

            // Abs (Rectus Abdominis)
            createMuscle(new THREE.Vector3(-4, yChest - 10, 11), new THREE.Vector3(-4, yWaist, 10), 60, 10, 0.3, 'Abs');
            createMuscle(new THREE.Vector3(4, yChest - 10, 11), new THREE.Vector3(4, yWaist, 10), 60, 10, 0.3, 'Abs');

            // Lats (Wings)
            createMuscle(new THREE.Vector3(-xShoulder + 5, yShoulder - 15, -5), new THREE.Vector3(-xHip + 5, yWaist + 10, -5), 90, 12, 1.4, 'Back');
            createMuscle(new THREE.Vector3(xShoulder - 5, yShoulder - 15, -5), new THREE.Vector3(xHip - 5, yWaist + 10, -5), 90, 12, 1.4, 'Back');

            // Arms (Full Volume)
            // L Upper Arm (Bicep + Tricep)
            createMuscle(shoulderL, elbowL, 60, 8, 1.4, 'Arms'); // Bicep side
            createMuscle(new THREE.Vector3(-xShoulder, yShoulder, -3), new THREE.Vector3(-28, yElbow, -2), 60, 9, 1.6, 'Arms'); // Tricep side

            // R Upper Arm
            createMuscle(shoulderR, elbowR, 60, 8, 1.4, 'Arms');
            createMuscle(new THREE.Vector3(xShoulder, yShoulder, -3), new THREE.Vector3(28, yElbow, -2), 60, 9, 1.6, 'Arms');

            // Forearms
            createMuscle(elbowL, handL, 50, 7, 1.2, 'Arms');
            createMuscle(elbowR, handR, 50, 7, 1.2, 'Arms');
            // Back of forearms for thickness
            createMuscle(new THREE.Vector3(-28, yElbow, 2), new THREE.Vector3(-30, yArmEnd, 4), 40, 6, 1.1, 'Arms');
            createMuscle(new THREE.Vector3(28, yElbow, 2), new THREE.Vector3(30, yArmEnd, 4), 40, 6, 1.1, 'Arms');


            // Legs
            // Quads/Hams (Upper Leg)
            createMuscle(hipL, kneeL, 100, 13, 1.6, 'Legs');
            createMuscle(hipR, kneeR, 100, 13, 1.6, 'Legs');

            // Calves (Lower Leg)
            createMuscle(kneeL, ankleL, 80, 9, 1.5, 'Calves');
            createMuscle(kneeR, ankleR, 80, 9, 1.5, 'Calves');

            // Feet
            createMuscle(ankleL, footL, 40, 7, 1.0, 'Legs');
            createMuscle(ankleR, footR, 40, 7, 1.0, 'Legs');


            // Build Geometry
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(musclePoints, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            currentColorsAttribute = geometry.attributes.color;
            // Save original colors for reset
            originalColors = new Float32Array(colors);

            const pMaterial = new THREE.PointsMaterial({
                size: 3,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            particles = new THREE.Points(geometry, pMaterial);
            group.add(particles);

            // Connections (Plexus)
            const linePositions = [];
            const lineColors = [];
            const pos = geometry.attributes.position.array;
            const thresholdSq = CONNECTIVITY_DISTANCE * CONNECTIVITY_DISTANCE;
            const maxConnections = 6;

            for (let i = 0; i < musclePoints.length / 3; i++) {
                const x1 = pos[i * 3];
                const y1 = pos[i * 3 + 1];
                const z1 = pos[i * 3 + 2];
                let connections = 0;

                for (let j = i + 1; j < musclePoints.length / 3; j++) {
                    const x2 = pos[j * 3];
                    const y2 = pos[j * 3 + 1];
                    const z2 = pos[j * 3 + 2];
                    const distSq = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2);

                    if (distSq < thresholdSq) {
                        linePositions.push(x1, y1, z1);
                        linePositions.push(x2, y2, z2);
                        // Faint line color
                        lineColors.push(COLOR_PRIMARY.r, COLOR_PRIMARY.g, COLOR_PRIMARY.b);
                        lineColors.push(COLOR_PRIMARY.r, COLOR_PRIMARY.g, COLOR_PRIMARY.b);
                        connections++;
                        if (connections >= maxConnections) break;
                    }
                }
            }

            const lineGeo = new THREE.BufferGeometry();
            lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
            lineGeo.setAttribute('color', new THREE.Float32BufferAttribute(lineColors, 3));

            const lineMat = new THREE.LineBasicMaterial({
                vertexColors: true,
                transparent: true,
                opacity: 0.15,
                blending: THREE.AdditiveBlending
            });

            linesMesh = new THREE.LineSegments(lineGeo, lineMat);
            group.add(linesMesh);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize);

            // Interaction
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            const onDown = (x, y) => { isDragging = true; previousMousePosition = { x, y }; };
            const onUp = () => isDragging = false;
            const onMove = (x, y) => {
                if (isDragging) {
                    const deltaX = x - previousMousePosition.x;
                    const deltaY = y - previousMousePosition.y;
                    group.rotation.y += deltaX * 0.005;
                    group.rotation.x += deltaY * 0.005;
                    previousMousePosition = { x, y };
                }
            };

            document.addEventListener('touchstart', e => onDown(e.touches[0].clientX, e.touches[0].clientY));
            document.addEventListener('touchmove', e => onMove(e.touches[0].clientX, e.touches[0].clientY));
            document.addEventListener('touchend', onUp);
            document.addEventListener('mousedown', e => onDown(e.clientX, e.clientY));
            document.addEventListener('mousemove', e => onMove(e.clientX, e.clientY));
            document.addEventListener('mouseup', onUp);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            group.rotation.y += 0.002;
            const time = Date.now() * 0.002;
            const scale = 1 + Math.sin(time) * 0.005;
            group.scale.set(scale, scale, scale);
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>