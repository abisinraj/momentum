<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0;
            background-color: transparent;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script src="three_global.js"></script>
    <script>
        const THREE = window.THREE;

        let camera, scene, renderer;
        let group, particles, linesMesh;

        // Data for heatmap interaction
        let currentColorsAttribute;
        let particleMap = {}; // 'chest': [0, 1, 2...]
        let originalColors = null;


        // Configuration
        const CONNECTIVITY_DISTANCE = 16;
        // v2: Silver/White Theme
        const COLOR_PRIMARY = new THREE.Color(0xCCCCCC); // Silver
        const COLOR_SECONDARY = new THREE.Color(0xFFFFFF); // White
        const COLOR_HOT = new THREE.Color(0xFF5500); // Orange/Red for heat

        // v2: Muscle Hierarchy
        const MUSCLE_HIERARCHY = {
            'Arms': ['Biceps', 'Triceps', 'Forearms'],
            'Legs': ['Quads', 'Hamstrings', 'Calves', 'Glutes'],
            'Shoulders': ['Front Delts', 'Side Delts', 'Rear Delts'],
            'Chest': ['Upper Chest', 'Lower Chest'],
            'Back': ['Lats', 'Upper Back', 'Lower Back'],
            'Abs': ['Upper Abs', 'Lower Abs', 'Obliques']
        };

        init();
        animate();

        // Expose function to Flutter/JS
        window.setMuscleHeatmap = function (data) {
            // data format: { 'Biceps': 0.8, 'Legs': 0.2 } 
            if (!particles || !currentColorsAttribute) return;

            // Reset to clean state first (efficient reset)
            if (originalColors) {
                currentColorsAttribute.array.set(originalColors);
            }

            const colors = currentColorsAttribute.array;

            // Process Data
            for (const key in data) {
                const intensity = Math.max(0, Math.min(1, data[key]));
                if (intensity <= 0) continue;

                const groupName = key; // e.g. "Biceps" or "Arms"

                // 1. Direct Match? (e.g. data has "Biceps")
                applyColorToGroup(groupName, intensity, colors);

                // 2. Is it a Parent Category? (e.g. data has "Arms")
                // Apply to children too
                if (MUSCLE_HIERARCHY[groupName]) {
                    MUSCLE_HIERARCHY[groupName].forEach(child => {
                        applyColorToGroup(child, intensity, colors);
                    });
                }
            }

            currentColorsAttribute.needsUpdate = true;
        };

        function applyColorToGroup(groupName, intensity, colorArray) {
            const key = groupName.toLowerCase();
            const indices = particleMap[key];
            if (!indices) return;

            for (const i of indices) {
                // Current color (likely reset to base)
                // We want to mix HOT logic
                // Since we reset every frame, we just lerp base -> hot

                // Get Original Base (to avoid compounding lerps over frames)
                const rBase = originalColors[i * 3];
                const gBase = originalColors[i * 3 + 1];
                const bBase = originalColors[i * 3 + 2];

                const baseColor = new THREE.Color(rBase, gBase, bBase);
                const finalColor = baseColor.lerp(COLOR_HOT, intensity * 0.9); // 90% towards hot at max

                colorArray[i * 3] = finalColor.r;
                colorArray[i * 3 + 1] = finalColor.g;
                colorArray[i * 3 + 2] = finalColor.b;
            }
        }

        // Reset heatmap
        window.resetHeatmap = function () {
            if (originalColors && currentColorsAttribute) {
                currentColorsAttribute.array.set(originalColors);
                currentColorsAttribute.needsUpdate = true;
            }
        };


        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 400;
            camera.position.y = 50;

            group = new THREE.Group();
            scene.add(group);

            const musclePoints = [];
            const colors = [];

            let particleIndex = 0;

            function registerParticle(groupName, index) {
                const key = groupName.toLowerCase();
                if (!particleMap[key]) particleMap[key] = [];
                particleMap[key].push(index);
            }

            // Helper: Create a muscle between two points
            function createMuscle(start, end, count, radius, bulge, groupName) {
                const curve = new THREE.LineCurve3(start, end);

                for (let i = 0; i < count; i++) {
                    const t = Math.random();
                    const point = curve.getPoint(t);
                    const shapeFactor = 4 * t * (1 - t);
                    const r = radius * (0.5 + 0.5 * shapeFactor * bulge);

                    const u = Math.random();
                    const v = Math.random();
                    const theta = 2 * Math.PI * u;
                    const phi = Math.acos(2 * v - 1);

                    const x = point.x + r * Math.sin(phi) * Math.cos(theta);
                    const y = point.y + r * Math.sin(phi) * Math.sin(theta);
                    const z = point.z + r * Math.cos(phi);

                    musclePoints.push(x, y, z);

                    // Register group
                    registerParticle(groupName, particleIndex++);

                    // Color mix
                    const mixColor = COLOR_PRIMARY.clone().lerp(COLOR_SECONDARY, Math.random() * 0.6);
                    colors.push(mixColor.r, mixColor.g, mixColor.b);
                }
            }

            // --- SKELETON & MUSCLES (v2 GRANULAR) ---

            // Major Landmarks
            const yHeadTop = 175;
            const yNeckBase = 150;
            const yShoulder = 145;
            const yChest = 135;
            const yWaist = 110;
            const yHip = 95;
            const yKnee = 50;
            const yAnkle = 8;
            const yFoot = 0;

            // Widths (Total Width / 2)
            const xShoulder = 23;
            const xHip = 15;
            const xKnee = 12;
            const xFoot = 15;

            // Z Depths
            const zSpine = -5;
            const zPec = 10;

            // Points
            const head = new THREE.Vector3(0, 168, 0);
            const neck = new THREE.Vector3(0, yNeckBase, 0);

            const shoulderL = new THREE.Vector3(-xShoulder, yShoulder, 0);
            const shoulderR = new THREE.Vector3(xShoulder, yShoulder, 0);

            const hipL = new THREE.Vector3(-xHip, yHip, 0);
            const hipR = new THREE.Vector3(xHip, yHip, 0);

            const kneeL = new THREE.Vector3(-xKnee, yKnee, 5);
            const kneeR = new THREE.Vector3(xKnee, yKnee, 5);

            const ankleL = new THREE.Vector3(-xFoot, yAnkle, 0);
            const ankleR = new THREE.Vector3(xFoot, yAnkle, 0);

            const footL = new THREE.Vector3(-xFoot, yFoot, 15);
            const footR = new THREE.Vector3(xFoot, yFoot, 15);

            // Arms
            const yArmEnd = 78;
            const yElbow = 118;
            const elbowL = new THREE.Vector3(-30, yElbow, 5);
            const elbowR = new THREE.Vector3(30, yElbow, 5);
            const handL = new THREE.Vector3(-32, yArmEnd, 10);
            const handR = new THREE.Vector3(32, yArmEnd, 10);

            // --- MUSCLE BUILD ---

            // Head & Neck
            createMuscle(new THREE.Vector3(0, yHeadTop - 10, 0), new THREE.Vector3(0, yHeadTop, 0), 100, 12, 0.4, 'Head');
            createMuscle(neck, new THREE.Vector3(0, yHeadTop - 5, 0), 80, 12, 0.4, 'Traps');

            // Torso
            createMuscle(new THREE.Vector3(0, yNeckBase, zSpine), new THREE.Vector3(0, yHip, zSpine), 150, 16, 1.0, 'Back'); // General Spine

            // Traps
            createMuscle(neck, shoulderL, 50, 12, 0.7, 'Traps');
            createMuscle(neck, shoulderR, 50, 12, 0.7, 'Traps');

            // Shoulders (Deltoids)
            createMuscle(shoulderL, new THREE.Vector3(-xShoulder, yShoulder - 12, 0), 80, 16, 1.8, 'Shoulders');
            createMuscle(shoulderR, new THREE.Vector3(xShoulder, yShoulder - 12, 0), 80, 16, 1.8, 'Shoulders');

            // Chest
            createMuscle(new THREE.Vector3(-5, yChest, zPec), new THREE.Vector3(-xShoulder + 10, yShoulder - 5, 8), 100, 18, 1.4, 'Chest');
            createMuscle(new THREE.Vector3(5, yChest, zPec), new THREE.Vector3(xShoulder - 10, yShoulder - 5, 8), 100, 18, 1.4, 'Chest');

            // Abs
            createMuscle(new THREE.Vector3(-4, yChest - 10, 12), new THREE.Vector3(-4, yWaist, 11), 70, 11, 0.4, 'Abs');
            createMuscle(new THREE.Vector3(4, yChest - 10, 12), new THREE.Vector3(4, yWaist, 11), 70, 11, 0.4, 'Abs');

            // Lats
            createMuscle(new THREE.Vector3(-xShoulder + 5, yShoulder - 15, -5), new THREE.Vector3(-xHip + 5, yWaist + 10, -5), 100, 15, 1.6, 'Back');
            createMuscle(new THREE.Vector3(xShoulder - 5, yShoulder - 15, -5), new THREE.Vector3(xHip - 5, yWaist + 10, -5), 100, 15, 1.6, 'Back');

            // --- ARMS (Granular) ---
            // Biceps (Front of Upper Arm)
            createMuscle(shoulderL, elbowL, 40, 9, 1.6, 'Biceps');
            createMuscle(shoulderR, elbowR, 40, 9, 1.6, 'Biceps');

            // Triceps (Back of Upper Arm)
            createMuscle(new THREE.Vector3(-xShoulder, yShoulder, -3), new THREE.Vector3(-28, yElbow, -4), 50, 10, 1.8, 'Triceps');
            createMuscle(new THREE.Vector3(xShoulder, yShoulder, -3), new THREE.Vector3(28, yElbow, -4), 50, 10, 1.8, 'Triceps');

            // Forearms
            createMuscle(elbowL, handL, 60, 9, 1.3, 'Forearms');
            createMuscle(elbowR, handR, 60, 9, 1.3, 'Forearms');

            // --- LEGS (Granular) ---
            // Quads (Front Thigh)
            createMuscle(hipL, kneeL, 80, 18, 1.8, 'Quads');
            createMuscle(hipR, kneeR, 80, 18, 1.8, 'Quads');

            // Hamstrings (Back Thigh) - Offset Z backwards
            createMuscle(new THREE.Vector3(-xHip, yHip, -4), new THREE.Vector3(-xKnee, yKnee, -4), 60, 16, 1.6, 'Hamstrings');
            createMuscle(new THREE.Vector3(xHip, yHip, -4), new THREE.Vector3(xKnee, yKnee, -4), 60, 16, 1.6, 'Hamstrings');

            // Glutes
            createMuscle(new THREE.Vector3(-5, yHip, -5), new THREE.Vector3(-xHip, yHip - 10, -6), 50, 14, 1.5, 'Glutes');
            createMuscle(new THREE.Vector3(5, yHip, -5), new THREE.Vector3(xHip, yHip - 10, -6), 50, 14, 1.5, 'Glutes');

            // Calves
            createMuscle(kneeL, ankleL, 90, 11, 1.7, 'Calves');
            createMuscle(kneeR, ankleR, 90, 11, 1.7, 'Calves');

            // Feet
            createMuscle(ankleL, footL, 50, 8, 1.0, 'Calves'); // Map feet to calves for simplicity or New 'Feet'
            createMuscle(ankleR, footR, 50, 8, 1.0, 'Calves');


            // Build Geometry
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(musclePoints, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            currentColorsAttribute = geometry.attributes.color;
            // Save original colors for reset
            originalColors = new Float32Array(colors);

            const pMaterial = new THREE.PointsMaterial({
                size: 3,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            particles = new THREE.Points(geometry, pMaterial);
            group.add(particles);

            // Connections (Plexus)
            const linePositions = [];
            const lineColors = [];
            const pos = geometry.attributes.position.array;
            const thresholdSq = CONNECTIVITY_DISTANCE * CONNECTIVITY_DISTANCE;
            const maxConnections = 6;

            for (let i = 0; i < musclePoints.length / 3; i++) {
                const x1 = pos[i * 3];
                const y1 = pos[i * 3 + 1];
                const z1 = pos[i * 3 + 2];
                let connections = 0;

                for (let j = i + 1; j < musclePoints.length / 3; j++) {
                    const x2 = pos[j * 3];
                    const y2 = pos[j * 3 + 1];
                    const z2 = pos[j * 3 + 2];
                    const distSq = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2);

                    if (distSq < thresholdSq) {
                        linePositions.push(x1, y1, z1);
                        linePositions.push(x2, y2, z2);
                        // Faint line color
                        lineColors.push(COLOR_PRIMARY.r, COLOR_PRIMARY.g, COLOR_PRIMARY.b);
                        lineColors.push(COLOR_PRIMARY.r, COLOR_PRIMARY.g, COLOR_PRIMARY.b);
                        connections++;
                        if (connections >= maxConnections) break;
                    }
                }
            }

            const lineGeo = new THREE.BufferGeometry();
            lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
            lineGeo.setAttribute('color', new THREE.Float32BufferAttribute(lineColors, 3));

            const lineMat = new THREE.LineBasicMaterial({
                vertexColors: true,
                transparent: true,
                opacity: 0.15,
                blending: THREE.AdditiveBlending
            });

            linesMesh = new THREE.LineSegments(lineGeo, lineMat);
            group.add(linesMesh);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize);

            // Interaction
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            const onDown = (x, y) => { isDragging = true; previousMousePosition = { x, y }; };
            const onUp = () => isDragging = false;
            const onMove = (x, y) => {
                if (isDragging) {
                    const deltaX = x - previousMousePosition.x;
                    const deltaY = y - previousMousePosition.y;
                    group.rotation.y += deltaX * 0.005;
                    group.rotation.x += deltaY * 0.005;
                    previousMousePosition = { x, y };
                }
            };

            document.addEventListener('touchstart', e => onDown(e.touches[0].clientX, e.touches[0].clientY));
            document.addEventListener('touchmove', e => onMove(e.touches[0].clientX, e.touches[0].clientY));
            document.addEventListener('touchend', onUp);
            document.addEventListener('mousedown', e => onDown(e.clientX, e.clientY));
            document.addEventListener('mousemove', e => onMove(e.clientX, e.clientY));
            document.addEventListener('mouseup', onUp);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            group.rotation.y += 0.002;
            const time = Date.now() * 0.002;
            const scale = 1 + Math.sin(time) * 0.005;
            group.scale.set(scale, scale, scale);
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>