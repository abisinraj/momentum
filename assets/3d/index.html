<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Momentum 3D Debug (v5.1)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f0;
            color: #eee;
            touch-action: manipulation;
            /* Disables double-tap zoom */
        }

        canvas {
            display: block;
        }

        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            font-weight: 500;
            color: #888;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        #loader.hidden {
            opacity: 0;
        }
    </style>
</head>

<body>
    <div id="loader">Loading Model...</div>
    <script src="three_global.js"></script>
    <script src="BufferGeometryUtils_global.js"></script>
    <script src="GLTFLoader_global.js"></script>
    <script src="OrbitControls_global.js"></script>
    <script src="RoomEnvironment_global.js"></script>


    <script>
        // Explicitly alias globals to ensure access
        const THREE = window.THREE;
        const GLTFLoader = window.GLTFLoader;
        const OrbitControls = window.OrbitControls;
        const RoomEnvironment = window.RoomEnvironment;

        // Use global variables
        var camera, scene, renderer, model, controls;

        // --- Camera Zoom Logic State (Hoisted to avoid TDZ) ---
        let isZooming = false;
        const targetCameraPos = new THREE.Vector3();
        const targetControlsTarget = new THREE.Vector3();
        const zoomDuration = 800; // ms (Faster, smoother)
        let zoomStartTime = 0;
        const startCameraPos = new THREE.Vector3();
        const startControlsTarget = new THREE.Vector3();
        let lastTapTime = 0;
        let tapsOutsideCount = 0;
        let gameMode = false;
        let modelHealth = 100;
        let playerHealth = 100;
        let gameScore = 0;
        let comboCount = 0;
        let gameLastHitTime = 0;

        // --- MUSCLE DEFINITIONS (For Shader) ---
        // --- MUSCLE DEFINITIONS (Initially Empty - Populated by Flutter) ---
        let muscleDefs = [];

        // Function called by Flutter to set definitions
        window.updateMuscleDefs = function (defs, mirroredNames) {
            console.log('Received Muscle Defs from Flutter:', defs.length);
            muscleDefs = defs;

            // Generate Mirrored Muscles (Left Side) automatically
            // Flutter passes a list of names that should be mirrored
            mirroredNames.forEach(name => {
                const original = muscleDefs.find(m => m.name === name);
                if (original) {
                    const mirror = { ...original }; // Shallow copy

                    // Unique name for targeting
                    mirror.name = original.name + ' (Left)';

                    // Flip Bone Names (More robust replacement)
                    if (mirror.bone) mirror.bone = mirror.bone.replace('Right', 'Left').replace('right', 'left');
                    if (mirror.start) mirror.start = mirror.start.replace('Right', 'Left').replace('right', 'left');
                    if (mirror.end) mirror.end = mirror.end.replace('Right', 'Left').replace('right', 'left');

                    // NOTE: Whether to flip X depends on the rig.
                    // For Mixamo rigs, local X is often already mirrored (Right +X = World Right, Left +X = World Left).
                    // If we flip the offset, we'd actually move the point to the wrong side of the bone.
                    // Based on user feedback ("taking to wrong side"), let's NOT flip X and see if it aligns.
                    // We'll keep the shallow copy's offset.

                    muscleDefs.push(mirror);
                }
            });
            console.log('Total Muscle Zones (with mirrors):', muscleDefs.length);
        };

        // Shader Uniforms
        const MAX_ZONES = 64;
        const uniformData = {
            u_zone_starts: { value: new Float32Array(MAX_ZONES * 3) },
            u_zone_ends: { value: new Float32Array(MAX_ZONES * 3) },
            u_zone_radii: { value: new Float32Array(MAX_ZONES) },
            u_zone_intensities: { value: new Float32Array(MAX_ZONES) },
            u_zone_count: { value: 0 }
        };

        const activeHeatmap = {};

        // Efficient dependency gatekeeper
        window.isReady = false;
        window._pendingModelData = null;

        const stanceController = window.stanceController = {
            activePose: 'IDLE',
            targetPose: 'IDLE',
            bones: {},
            lastHitTime: 0,
            guardTimer: null,
            poses: {
                IDLE: {
                    'Spine': { rx: 0, ry: 0, rz: 0 },
                    'RightArm': { rx: 1.63, ry: -1.57, rz: 0.4 },  // Vertical, twisted to thigh, spread
                    'LeftArm': { rx: 1.63, ry: 1.57, rz: -0.4 }, // Vertical, twisted to thigh, spread
                    'RightForeArm': { rx: 0.1, ry: 0, rz: 0 },
                    'LeftForeArm': { rx: 0.1, ry: 0, rz: 0 },
                    'Head': { rx: 0, ry: 0, rz: 0 },
                    'Fist': 0.1
                },
                FIGHT: {
                    'Spine': { rx: 0.2, ry: 0, rz: 0 }, // Leaning forward slightly more
                    'RightArm': { rx: 0.6, ry: -0.1, rz: -0.4 }, // Tucked elbow
                    'LeftArm': { rx: 0.8, ry: 0.1, rz: 0.4 }, // Tucked elbow
                    'RightForeArm': { rx: 0, ry: 0, rz: -2.0 }, // Hands up protect face
                    'LeftForeArm': { rx: 0, ry: 0, rz: 2.0 }, // Hands up protect face
                    'Head': { rx: 0.1, ry: 0, rz: 0 }, // Chin tucked
                    'Fist': 1.0
                },
                GUARD: {
                    // High Guard (Peek-a-boo)
                    'Spine': { rx: 0.3, ry: 0, rz: 0 },
                    'RightArm': { rx: 1.2, ry: -0.2, rz: -0.2 },
                    'LeftArm': { rx: 1.2, ry: 0.2, rz: 0.2 },
                    'RightForeArm': { rx: 0, ry: 0, rz: -2.3 }, // Tight to face
                    'LeftForeArm': { rx: 0, ry: 0, rz: 2.3 },
                    'Head': { rx: 0.2, ry: 0, rz: 0 },
                    'Fist': 1.0
                },
                // 1-6 BASIC STRIKES (Cinematic Reach & Eye-Level Calibration)
                ATTACK_1: { // JAB (Left Straight)
                    'Spine': { rx: 0.15, ry: -0.6, rz: 0 },
                    'LeftArm': { rx: -0.1, ry: 1.57, rz: 1.6 }, // Level at 1.60m
                    'LeftForeArm': { rx: 0, ry: 0, rz: 0.02 }, // Max extension
                    'RightArm': { rx: 1.5, ry: -0.3, rz: -0.1 }, // Guard
                    'RightForeArm': { rx: 0, ry: 0, rz: -2.0 },
                    'Head': { rx: 0, ry: 0.4, rz: 0 },
                    'Fist': 1.0
                },
                ATTACK_2: { // CROSS (Right Power)
                    'Spine': { rx: 0.25, ry: 0.6, rz: 0 },
                    'RightArm': { rx: -0.1, ry: -1.57, rz: -1.6 }, // Level at 1.60m
                    'RightForeArm': { rx: 0, ry: 0, rz: -0.02 }, // Max extension
                    'LeftArm': { rx: 1.5, ry: 0.3, rz: 0.1 }, // Guard
                    'LeftForeArm': { rx: 0, ry: 0, rz: 2.0 },
                    'Head': { rx: 0, ry: -0.4, rz: 0 },
                    'Fist': 1.0
                },
                ATTACK_3: { // LEFT HOOK (Wide Head Strike)
                    'Spine': { rx: 0.1, ry: -1.0, rz: 0 },
                    'LeftArm': { rx: -0.1, ry: 1.1, rz: 1.6 }, // Level
                    'LeftForeArm': { rx: 0, ry: 0, rz: 1.3 }, // Punching past center
                    'RightArm': { rx: 1.5, ry: -0.3, rz: -0.1 },
                    'Head': { rx: 0, ry: 0.8, rz: 0 },
                    'Fist': 1.0
                },
                ATTACK_4: { // RIGHT HOOK (Wide Head Strike)
                    'Spine': { rx: 0.1, ry: 1.0, rz: 0 },
                    'RightArm': { rx: -0.1, ry: -1.1, rz: -1.6 }, // Level
                    'RightForeArm': { rx: 0, ry: 0, rz: -1.3 },
                    'LeftArm': { rx: 1.5, ry: 0.3, rz: 0.1 },
                    'Head': { rx: 0, ry: -0.8, rz: 0 },
                    'Fist': 1.0
                },
                ATTACK_5: { // LEFT UPPERCUT (Low to High)
                    'Spine': { rx: -0.1, ry: -0.5, rz: -0.2 },
                    'LeftArm': { rx: -0.7, ry: 0.4, rz: 0.4 },
                    'LeftForeArm': { rx: 0, ry: 0, rz: 2.2 },
                    'RightArm': { rx: 1.5, ry: -0.3, rz: -0.1 },
                    'Head': { rx: 0.1, ry: 0.4, rz: 0 },
                    'Fist': 1.0
                },
                ATTACK_6: { // RIGHT UPPERCUT (Low to High)
                    'Spine': { rx: -0.1, ry: 0.5, rz: 0.2 },
                    'RightArm': { rx: -0.7, ry: -0.4, rz: -0.4 },
                    'RightForeArm': { rx: 0, ry: 0, rz: -2.2 },
                    'LeftArm': { rx: 1.5, ry: 0.3, rz: 0.1 },
                    'Head': { rx: 0.1, ry: -0.4, rz: 0 },
                    'Fist': 1.0
                },
                PUNCH_RIGHT: {
                    'Spine': { rx: 0.1, ry: -0.5, rz: 0.1 }, // Deeper twist
                    'RightArm': { rx: -0.2, ry: -0.2, rz: -1.3 }, // Aim at camera (center)
                    'LeftArm': { rx: 1.2, ry: 0.5, rz: 0.5 }, // Tight guard
                    'RightForeArm': { rx: 0, ry: 0, rz: 0 }, // Fully extended
                    'LeftForeArm': { rx: 0, ry: 0, rz: 2.2 },
                    'Head': { rx: 0.0, ry: -0.3, rz: 0 }, // Look at target
                    'Fist': 1.0,
                    lunge: 0.8 // Forward movement
                },
                PUNCH_LEFT: {
                    'Spine': { rx: 0.1, ry: 0.5, rz: -0.1 },
                    'RightArm': { rx: 1.2, ry: -0.5, rz: -0.5 }, // Tight guard
                    'LeftArm': { rx: -0.2, ry: 0.2, rz: 1.3 }, // Aim at camera
                    'RightForeArm': { rx: 0, ry: 0, rz: -2.2 },
                    'LeftForeArm': { rx: 0, ry: 0, rz: 0 }, // Fully extended
                    'Head': { rx: 0.0, ry: 0.3, rz: 0 },
                    'Fist': 1.0,
                    lunge: 0.8
                }
            },
            init: function () {
                console.log("ðŸ¥Š Procedural Controller: Mapping Skeleton...");

                const searchGroups = {
                    'Spine': ['Spine2', 'Spine1', 'Chest', 'Spine', 'Hips'],
                    'RightArm': ['RightArm', 'UpperArm_R', 'Arm_R', 'mixamorigRightArm'],
                    'LeftArm': ['LeftArm', 'UpperArm_L', 'Arm_L', 'mixamorigLeftArm'],
                    'RightForeArm': ['RightForeArm', 'ForeArm_R', 'LowerArm_R', 'mixamorigRightForeArm'],
                    'LeftForeArm': ['LeftForeArm', 'ForeArm_L', 'LowerArm_L', 'mixamorigLeftForeArm'],
                    'Head': ['Head', 'Neck', 'mixamorigHead'],
                    'Hips': ['Hips', 'Pelvis', 'mixamorigHips'],
                    'RightHand': ['RightHand', 'Hand_R', 'Right_Hand', 'mixamorigRightHand'],
                    'LeftHand': ['LeftHand', 'Hand_L', 'Left_Hand', 'mixamorigLeftHand']
                };

                const fingerBases = ['Index', 'Middle', 'Ring', 'Pinky', 'Thumb'];
                const joints = ['1', '2', '3']; // Find all 3 joints for better curling

                for (let logicalName in searchGroups) {
                    let found = null;
                    for (let term of searchGroups[logicalName]) {
                        found = findBone(term);
                        if (found) break;
                    }

                    if (found) {
                        this.bones[logicalName] = {
                            ref: found,
                            currentRot: found.rotation.clone(),
                            recoil: new THREE.Vector3(0, 0, 0),
                            velocity: new THREE.Vector3(0, 0, 0),
                            cameraShake: 0
                        };

                        if (logicalName.includes('Hand')) {
                            const side = logicalName.includes('Right') ? 'Right' : 'Left';
                            this.bones[logicalName].fingers = [];
                            console.log(`ðŸ” Searching fingers for ${logicalName}...`);

                            fingerBases.forEach((base) => {
                                joints.forEach(j => {
                                    // Try patterns: RightHandIndex1, RightIndex1, mixamorigRightHandIndex1
                                    let fingerBone = findBone(side + 'Hand' + base + j) ||
                                        findBone(side + base + j) ||
                                        findBone('mixamorig' + side + 'Hand' + base + j) ||
                                        findBone('mixamorig' + side + base + j);

                                    if (fingerBone) {
                                        console.log(`   âœ“ Found finger joint: ${fingerBone.name}`);
                                        this.bones[logicalName].fingers.push({
                                            ref: fingerBone,
                                            originalRot: fingerBone.rotation.clone(),
                                            jointLevel: parseInt(j)
                                        });
                                    }
                                });
                            });
                        }
                    }
                }
                const rFin = this.bones['RightHand'] ? this.bones['RightHand'].fingers.length : 0;
                const lFin = this.bones['LeftHand'] ? this.bones['LeftHand'].fingers.length : 0;
                console.log(`ðŸ¥Š Stance Controller: Found R:${rFin} L:${lFin} finger joints`);
                this.targetPose = 'IDLE'; // Default to relaxed
                console.log("ðŸ¥Š Stance Controller Ready (v6.3 - RELAXED IDLE)");
            },
            triggerHit: function (muscle, point, isCritical) {
                const baseForce = isCritical ? 2.2 : 0.9; // Reduced from 1.8/3.5 to fix "throw off"

                // --- BOXING PHYSICS ENGINE (1-6 Strikes & Body Zones) ---
                let reactionType = 'GENERIC';
                let side = 'CENTER';

                if (point) {
                    // Side: x > 0.05 (Left), x < -0.05 (Right)
                    if (point.x > 0.05) side = 'LEFT_SIDE'; // Model's Left
                    else if (point.x < -0.05) side = 'RIGHT_SIDE'; // Model's Right
                    else side = 'CENTER';

                    const absX = Math.abs(point.x);

                    // Height (Y)
                    if (point.y > 1.48) {
                        // High Head
                        if (side === 'CENTER') reactionType = 'UPPERCUT_HEAD';
                        else reactionType = 'HOOK_HEAD';
                    } else if (point.y > 1.32) {
                        // Face
                        if (absX > 0.12) reactionType = 'HOOK_HEAD';
                        else reactionType = 'STRAIGHT_HEAD';
                    } else if (point.y > 1.15) {
                        // Chest
                        reactionType = 'BODY_CHEST';
                    } else if (point.y > 0.95) {
                        // Abs/Obliques
                        if (absX > 0.15) reactionType = 'BODY_OBLIQUE';
                        else reactionType = 'BODY_ABS';
                    } else {
                        // Low
                        reactionType = 'BODY_LOW';
                    }
                }

                let turnDir = 0;
                if (side === 'LEFT_SIDE') turnDir = -1.0;
                if (side === 'RIGHT_SIDE') turnDir = 1.0;

                console.log(`ðŸ¥Š Hit: ${reactionType} on ${side}`);

                if (reactionType.includes('HEAD') && this.bones['Head']) {
                    const b = this.bones['Head'];

                    if (reactionType === 'UPPERCUT_HEAD') {
                        // 5 & 6: Snap Head UP/BACK
                        b.velocity.x -= baseForce * 1.5;
                        b.velocity.y += (Math.random() - 0.5) * 0.5;
                        if (this.bones['Spine']) this.bones['Spine'].velocity.y += 0.08;
                    }
                    else if (reactionType === 'HOOK_HEAD') {
                        // 3 & 4: Violent Spin
                        b.velocity.y += turnDir * baseForce * 1.8;
                        b.velocity.z -= turnDir * baseForce * 0.4;
                        b.velocity.x -= baseForce * 0.3;
                    }
                    else if (reactionType === 'STRAIGHT_HEAD') {
                        // 1 & 2: Snap Back
                        b.velocity.x -= baseForce * 1.2;
                        b.velocity.y += turnDir * baseForce * 0.6;
                    }
                }

                else if (reactionType.includes('BODY') && this.bones['Spine']) {
                    const b = this.bones['Spine'];

                    if (reactionType === 'BODY_CHEST') {
                        b.velocity.z -= baseForce * 0.4;
                        b.velocity.x -= baseForce * 0.3;
                        // Fix: Add directional twist away from hit
                        // Hit Left -> Turn Right (turnDir = -1)
                        if (turnDir !== 0) b.velocity.y += turnDir * baseForce * 0.5;
                    }
                    else if (reactionType === 'BODY_ABS') {
                        b.velocity.x += baseForce * 1.0;
                        b.velocity.y -= 0.05;
                        if (this.bones['Head']) this.bones['Head'].velocity.x += baseForce * 0.5;
                    }
                    else if (reactionType === 'BODY_OBLIQUE') {
                        // Fix: Sway AWAY from hit
                        const sway = (side === 'LEFT_SIDE') ? -1.0 : 1.0;
                        b.velocity.z += sway * baseForce * 0.8;
                        b.velocity.x += baseForce * 0.4;

                        // Subtle Hip Sway (0.2) - Grounded but reactive
                        if (this.bones['Hips']) {
                            this.bones['Hips'].velocity.z += sway * 0.2;
                            this.bones['Hips'].velocity.y -= 0.02;
                        }
                    }
                    else if (reactionType === 'BODY_LOW') {
                        if (this.bones['Hips']) {
                            // Reduced rotation significantly (0.5 -> 0.15) to anchor feet
                            this.bones['Hips'].velocity.z += turnDir * baseForce * 0.15;
                            this.bones['Hips'].velocity.x -= 0.2;
                        }
                    }
                }

                if (this.bones['Spine']) this.bones['Spine'].cameraShake = isCritical ? 0.35 : 0.15;
            },
            update: function (time) {
                if (!model || Object.keys(this.bones).length === 0) return;

                // RESTORED: Breathing & Fatigue (Safe)
                const breathing = Math.sin(time * 0.002) * (this.targetPose === 'IDLE' ? 0.012 : 0.005);
                const fatigue = (typeof modelHealth !== 'undefined') ? Math.max(0, (100 - modelHealth) / 100) : 0;

                // Fatigue Effects (Chin Lift)
                if (this.bones['Head']) {
                    this.bones['Head'].ref.rotation.x -= (fatigue * 0.45);
                }
                if (this.bones['Spine']) {
                    this.bones['Spine'].ref.rotation.x += (fatigue * 0.2);
                }

                // PHYSICS TUNING: "Heavy Bag" Feel
                // PHYSICS TUNING: CONSTANT SAFE MODE
                const stiffness = 0.03; // Smoother transitions (from 0.04)
                const damping = 0.82; // Higher damping to prevent break-dancing oscillations (from 0.75)

                for (let name in this.bones) {
                    const boneData = this.bones[name];
                    const activeP = this.targetPose;
                    const poseData = (typeof activeP === 'object') ? activeP : (this.poses[activeP] || this.poses['IDLE']);
                    const target = poseData ? poseData[name] : null;

                    if (target) {
                        boneData.currentRot.x += (target.rx - boneData.currentRot.x) * stiffness;
                        boneData.currentRot.y += (target.ry - boneData.currentRot.y) * stiffness;
                        boneData.currentRot.z += (target.rz - boneData.currentRot.z) * stiffness;
                    }

                    // Physics damping and clamping
                    boneData.velocity.multiplyScalar(damping);
                    boneData.recoil.add(boneData.velocity);

                    // BRING BACK: Recoil spring (pull back to zero)
                    boneData.recoil.x -= boneData.recoil.x * 0.1;
                    boneData.recoil.y -= boneData.recoil.y * 0.1;
                    boneData.recoil.z -= boneData.recoil.z * 0.1;

                    // CLAMP: Prevent bones from snapping 360 degrees
                    const maxRecoil = 0.8; // radians (~45 deg)
                    boneData.recoil.x = Math.max(-maxRecoil, Math.min(maxRecoil, boneData.recoil.x));
                    boneData.recoil.y = Math.max(-maxRecoil, Math.min(maxRecoil, boneData.recoil.y));
                    boneData.recoil.z = Math.max(-maxRecoil, Math.min(maxRecoil, boneData.recoil.z));

                    // NaN SAFETY
                    let rx = boneData.currentRot.x + boneData.recoil.x;
                    let ry = boneData.currentRot.y + boneData.recoil.y;
                    let rz = boneData.currentRot.z + boneData.recoil.z;

                    if (isNaN(rx) || isNaN(ry) || isNaN(rz)) {
                        boneData.currentRot.set(0, 0, 0);
                        boneData.recoil.set(0, 0, 0);
                        boneData.velocity.set(0, 0, 0);
                        rx = 0; ry = 0; rz = 0;
                    }

                    boneData.ref.rotation.set(rx, ry, rz);

                    if (name === 'Spine' && boneData.cameraShake > 0.001) {
                        // More stable shake
                        controls.target.x += (Math.random() - 0.5) * boneData.cameraShake;
                        controls.target.y += (Math.random() - 0.5) * boneData.cameraShake;
                        boneData.cameraShake *= 0.7; // Faster decay
                        if (boneData.cameraShake <= 0.001) {
                            controls.target.set(0, 1, 0);
                        }
                    }

                    // --- Procedural "Noise" for Life ---
                    const t = time * 0.0005;
                    if (name === 'Spine') {
                        boneData.ref.rotation.x += breathing; // Main breathing
                        boneData.ref.rotation.y += Math.sin(t * 3.1) * 0.02; // Micro twisting
                    }
                    if (name === 'Head') {
                        // Look around slightly
                        boneData.ref.rotation.y += Math.sin(t * 4.5) * 0.03;
                        boneData.ref.rotation.x += Math.cos(t * 3.5) * 0.02;
                    }
                    if (name.includes('Arm')) {
                        boneData.ref.rotation.x += breathing * 0.4;
                        // Uneven arm sway
                        const offset = name.includes('Right') ? 0 : 2;
                        boneData.ref.rotation.z += Math.sin(t * 2 + offset) * 0.01;
                    }

                    // UPDATED: Advanced Anatomical Grip (Fixed undefined .Fist access)
                    if (boneData.fingers) {
                        const activeP = this.targetPose;
                        const poseData = (typeof activeP === 'object') ? activeP : (this.poses[activeP] || this.poses['IDLE']);
                        const amount = (poseData && poseData.Fist !== undefined) ? poseData.Fist : 0;
                        const isRight = name.includes('Right');
                        const sideSig = isRight ? -1 : 1;

                        boneData.fingers.forEach(f => {
                            const fname = f.ref.name.toLowerCase();
                            const isThumb = fname.includes('thumb');

                            // Reset everything first
                            f.ref.scale.set(1, 1, 1);

                            if (amount < 0.1) {
                                // Return to rest pose smoothly
                                f.ref.rotation.x += (f.originalRot.x - f.ref.rotation.x) * 0.1;
                                f.ref.rotation.y += (f.originalRot.y - f.ref.rotation.y) * 0.1;
                                f.ref.rotation.z += (f.originalRot.z - f.ref.rotation.z) * 0.1;
                                return;
                            }

                            // --- FIST 6.0: The "Avalanche" Scale (Depth & Axis Fix) ---
                            // 1. Staggered Z (Curl): Pinky curls much deeper than Index to create a slope.
                            // 2. Swapped Spread Axis: Moving convergence from Y (Twist) to X (Spread).

                            const FIST_ANGLES = {
                                'Thumb': {
                                    // Thumb is special, uses all axes
                                    1: { x: 0.3, y: 0.5, z: 0.6 }, // CMC: Fold across
                                    2: { x: -0.1, y: 0.0, z: 0.8 }, // MCP: Bend
                                    3: { x: 0.0, y: 0.0, z: 1.5 }   // IP: Hook tip
                                },
                                'Index': {
                                    // KNUCKLE: High & Proud (The "peak" of the fist ridge)
                                    1: { x: -0.15, y: 0.0, z: 1.3 }, // X: Flare OUT (Spread), Z: Less Curl
                                    2: { x: 0.0, y: 0.0, z: 1.8 },
                                    3: { x: 0.0, y: 0.0, z: 0.6 }
                                },
                                'Middle': {
                                    1: { x: 0.0, y: 0.0, z: 1.5 }, // Baseline
                                    2: { x: 0.0, y: 0.0, z: 1.9 },
                                    3: { x: 0.0, y: 0.0, z: 0.7 }
                                },
                                'Ring': {
                                    1: { x: 0.1, y: 0.0, z: 1.7 }, // X: Converge IN, Z: Deeper
                                    2: { x: 0.0, y: 0.0, z: 2.1 },
                                    3: { x: 0.0, y: 0.0, z: 0.8 }
                                },
                                'Pinky': {
                                    // KNUCKLE: Buried & Cupped (The bottom of the slope)
                                    1: { x: 0.25, y: 0.0, z: 2.0 }, // X: Strong Cup IN, Z: Max Curl
                                    2: { x: 0.0, y: 0.0, z: 2.2 }, // Compact
                                    3: { x: 0.0, y: 0.0, z: 0.9 }
                                }
                            };

                            // Identify Finger Type
                            let type = '';
                            if (fname.includes('thumb')) type = 'Thumb';
                            else if (fname.includes('index')) type = 'Index';
                            else if (fname.includes('middle')) type = 'Middle';
                            else if (fname.includes('ring')) type = 'Ring';
                            else if (fname.includes('pinky')) type = 'Pinky';

                            if (type && FIST_ANGLES[type] && FIST_ANGLES[type][f.jointLevel]) {
                                const tgt = FIST_ANGLES[type][f.jointLevel];

                                // Apply side inversion
                                // X (Spread/Deviate) needs flip: -X goes Left, +X goes Right.
                                // For Right Hand: +X is Ulnar (Pinky), -X is Radial (Thumb)?

                                let targetX, targetY, targetZ;

                                if (type === 'Thumb') {
                                    // THUMB LOGIC (Separate Coordinate System)
                                    // Usually Thumb bends on Z or Y.
                                    // Let's try Z-Curl again for thumb, but stronger.

                                    // Adjust targets for proper tuck
                                    const thumbScale = amount;
                                    const tBend = tgt.z * thumbScale; // Main bend
                                    const tRoll = tgt.x * thumbScale;
                                    const tYaw = tgt.y * thumbScale; // Opposition

                                    // Thumb Axis Mapping (Correction: Invert Z)
                                    // If it was going wrong way, we flip the signed bend.

                                    // Try: Z is Bend (Inverted), Y is Twist, X is Spread?
                                    // Mixamo Thumbs are notoriously weird.

                                    targetX = f.originalRot.x + (tRoll * sideSig);
                                    targetY = f.originalRot.y + (tYaw * sideSig);
                                    targetZ = f.originalRot.z + (tBend * sideSig * -1.0); // INVERTED Z

                                } else {
                                    // FINGER LOGIC (Proven: X is Curl)
                                    // X = Bend (from defined Z)
                                    // Y = Spread/Yaw (from defined Y)
                                    // Z = Twist/Roll (from defined X)

                                    const tx = tgt.x * sideSig; // Spread/Twist needs mirror
                                    const ty = tgt.y * sideSig;
                                    const tz = tgt.z; // CURL DOES NOT NEED MIRROR (Usually +X for both)

                                    // Axis Swap: Map defined Z (Curl) to Bone X (Bend)
                                    targetX = f.originalRot.x + (tz * amount);  // Curl (Positive = In)
                                    targetY = f.originalRot.y + (ty * amount);  // Spread
                                    targetZ = f.originalRot.z + (tx * amount);  // Twist
                                }

                                f.ref.rotation.x += (targetX - f.ref.rotation.x) * 0.2;
                                f.ref.rotation.y += (targetY - f.ref.rotation.y) * 0.2;
                                f.ref.rotation.z += (targetZ - f.ref.rotation.z) * 0.2;
                            }

                            // Volume Scale (Keep subtle)
                            if (f.jointLevel === 2 && !type.includes('Thumb')) {
                                const s = 1.0 + (amount * 0.08);
                                f.ref.scale.set(s, s, s);
                            }
                        });
                    }
                }

                // Camera Tracking (Dynamic: Upper Body Focus for Game, Full Body for IDLE)
                if (window.controls && model) {
                    const targetY = gameMode ? 1.45 : 1.0; // Restored Upper Body focus for boxing (1.45 = Upper Chest)
                    const lerpSpeed = 0.05;

                    controls.target.x += (model.position.x - controls.target.x) * lerpSpeed;
                    controls.target.z += (model.position.z - controls.target.z) * lerpSpeed;

                    // Maintain focus (1.6 for combat, 1.0 for idle)
                    controls.target.y += (targetY - controls.target.y) * lerpSpeed;
                }
            }
        };

        // AI Controller for counter-attacks and movement
        const aiController = {
            enabled: false,
            difficulty: 'medium',
            lastAttackTime: 0,
            attackCooldown: 3000,
            isAttacking: false,
            isStunned: false,
            stunEndTime: 0,
            attackDuration: 500, // Faster, snappier punches

            // Movement State
            targetX: 0,
            targetZ: -1.0, // Base distance
            moveTimer: 0,
            lungeState: null, // New object for smooth animation { startTime, duration, startZ, depth, damage }

            patterns: {
                easy: { cooldown: 4000, damage: 5, comboChance: 0.1, moveSpeed: 0.02 },
                medium: { cooldown: 2500, damage: 8, comboChance: 0.6, moveSpeed: 0.04 },
                hard: { cooldown: 1500, damage: 12, comboChance: 1.0, moveSpeed: 0.06 }
            },

            init: function () {
                window.aiController = this; // Explicitly expose to window for handleGameHit
                console.log("ðŸ¤– AI Controller Initialized (v5.1 - VISIBILITY FIXED)");
                this.enabled = false;
                this.lastAttackTime = 0;
                this.isAttacking = false;
                this.isGuarding = false;
                this.isStunned = false;
                this.stunEndTime = 0;
                this.comboQueue = []; // Init Queue
                if (model) {
                    model.position.x = 0;
                    model.position.z = 0;
                }
                console.log('ðŸ¤– AI Controller Initialized (v4.0 - Combo Master)');
            },

            update: function (time) {
                if (!this.enabled || !gameMode || !model) return;

                // SAFETY: Prevent Vanishing & Drift
                if (isNaN(model.position.x) || isNaN(model.position.z)) {
                    model.position.set(0, 0, 0);
                }

                // 0. HIT STUN CHECK
                if (this.isStunned) {
                    if (time < this.stunEndTime) {
                        return; // Cannot move or attack while stunned
                    } else {
                        this.isStunned = false;
                    }
                }

                const pattern = this.patterns[this.difficulty];

                // 1. Organic Movement (Layered Sine Waves for "Life" - Increased for Footwork)
                if (!this.isAttacking) {
                    const t = time * 0.001;
                    const w1 = Math.sin(t * pattern.moveSpeed * 20);
                    const w2 = Math.sin(t * 0.5);
                    const offsetX = (w1 * 0.3) + (w2 * 0.15); // Restored full magnitude for Footwork

                    const w3 = Math.cos(t * pattern.moveSpeed * 15);
                    const offsetZ = (w3 * 0.15) - (Math.sin(t * 0.2) * 0.1); // Restored footwork logic

                    const bobY = (Math.sin(t * 2.5) * 0.015);
                    const smooth = 0.03;
                    model.position.x += (offsetX - model.position.x) * smooth;
                    model.position.z += (offsetZ - model.position.z) * smooth;
                    model.position.y += (bobY - model.position.y) * 0.1;
                }

                // 2. Lunge & Attack Animation Loop (Frame Perfect)
                if (this.lungeState) {
                    const now = Date.now();
                    const state = this.lungeState;
                    const elapsed = now - state.startTime;
                    const progress = Math.min(elapsed / state.duration, 1.0);

                    // Forward then Back (Sine wave for lunge)
                    const offset = Math.sin(progress * Math.PI) * state.depth;
                    model.position.z = (state.startZ || 0) + offset;

                    // HIT TRIGGER (At peak of lunge ~50%)
                    if (progress >= 0.5 && !state.hitTriggered) {
                        state.hitTriggered = true;
                        this.hitPlayer(state.damage, state.isCombo);
                        this.shakeCamera(state.depth > 1.5 ? 0.25 : 0.15);
                    }

                    if (progress >= 1.0) {
                        // End of attack
                        model.position.z = (state.startZ || 0); // Ensure reset
                        this.lungeState = null;
                        this.isAttacking = false;
                        stanceController.targetPose = 'FIGHT';
                    }
                }

                // 3. Attack Logic (Combos)
                const timeSinceLastAttack = time - this.lastAttackTime;
                if (timeSinceLastAttack > pattern.cooldown && !this.isAttacking && !this.lungeState && (!this.comboQueue || this.comboQueue.length === 0)) {
                    this.decideAttack(pattern);
                    this.lastAttackTime = time;
                }
            },

            executeAttack: function (damage) {
                if (this.isAttacking || this.lungeState || this.isStunned) return;
                this.isAttacking = true;

                // Pick from 1-6 Basic Strikes
                const type = Math.floor(Math.random() * 6) + 1;
                const attackPose = `ATTACK_${type}`;

                stanceController.targetPose = attackPose;

                // Initialize Lunge State for Update Loop
                this.lungeState = {
                    startTime: Date.now(),
                    duration: 400,
                    startZ: model.position.z || 0,
                    depth: 1.6,
                    damage: damage,
                    hitTriggered: false,
                    isCombo: false
                };
            },


            decideAttack: function (pattern) {
                const isCombo = Math.random() < pattern.comboChance;

                if (isCombo) {
                    const combos = [
                        [1, 2], [1, 1, 2], [2, 3], [1, 2, 3], [3, 4], [5, 2], [6, 3]
                    ];
                    this.comboQueue = combos[Math.floor(Math.random() * combos.length)];
                    console.log(`ðŸ¤– Combo: ${this.comboQueue}`);
                } else {
                    this.comboQueue = [Math.floor(Math.random() * 6) + 1];
                }

                this.processComboStep(pattern.damage);
            },

            processComboStep: function (damage) {
                if (!this.comboQueue || this.comboQueue.length === 0) {
                    this.isAttacking = false;
                    return;
                }

                this.isAttacking = true;
                const type = this.comboQueue.shift();

                // TARGET ZONE VARIETY
                const zones = ['HEAD', 'HEAD', 'BODY', 'HEAD_LEFT', 'HEAD_RIGHT', 'BODY_LEFT', 'BODY_RIGHT'];
                const zone = zones[Math.floor(Math.random() * zones.length)];

                this.executeSingleStrike(type, damage, zone);

                let delay = 600;
                if (type === 1) delay = 400; // Fast Jab

                setTimeout(() => {
                    if (this.enabled && gameMode) this.processComboStep(damage);
                }, delay);
            },

            executeSingleStrike: function (type, damage, zone = 'HEAD') {
                if (this.lungeState || this.isStunned) return; // CRITICAL GUARD

                const attackPoseName = `ATTACK_${type}`;
                const basePose = stanceController.poses[attackPoseName];
                if (!basePose) return;

                const dynamicPose = JSON.parse(JSON.stringify(basePose));

                if (zone.includes('BODY')) {
                    dynamicPose['Spine'].rx += 0.45;
                    if (type % 2 !== 0 && dynamicPose['LeftArm']) dynamicPose['LeftArm'].rx -= 0.6;
                    else if (dynamicPose['RightArm']) dynamicPose['RightArm'].rx -= 0.6;
                } else if (zone.includes('LEFT')) {
                    dynamicPose['Spine'].ry -= 0.25;
                } else if (zone.includes('RIGHT')) {
                    dynamicPose['Spine'].ry += 0.25;
                }

                stanceController.targetPose = dynamicPose;
                const lungeDepth = zone.includes('BODY') ? 1.4 : 2.0;

                // Sync with Frame Perfect System
                this.lungeState = {
                    startTime: Date.now(),
                    duration: 400,
                    startZ: model.position.z || 0,
                    depth: lungeDepth,
                    damage: damage,
                    hitTriggered: false,
                    isCombo: true,
                    zone: zone
                };
            },

            cancelAttack: function () {
                if (this.isAttacking || this.lungeState) {
                    console.log("ðŸ¤– AI INTERRUPTED! Entering Hit Stun...");
                    this.isAttacking = false;
                    this.lungeState = null; // CRITICAL: Clear lunge

                    // Trigger Stun State (Opponent flinches/cannot attack)
                    this.isStunned = true;
                    this.stunEndTime = Date.now() + 800; // 800ms stun on interrupt

                    this.comboQueue = [];
                    stanceController.targetPose = 'FIGHT';
                    if (model) model.position.z = 0; // Immediate reset
                }
            },

            activateGuard: function () {
                if (this.isAttacking || this.isGuarding) return;

                console.log("ðŸ›¡ï¸ AI Guarding!");
                this.isGuarding = true;
                stanceController.targetPose = 'GUARD';

                // Hold guard
                setTimeout(() => {
                    this.isGuarding = false;
                    if (!this.isAttacking) stanceController.targetPose = 'FIGHT';
                }, 1500 + Math.random() * 1000);
            },

            shakeCamera: function (intensity) {
                if (window.controls) {
                    // Shake target
                    controls.target.x += (Math.random() - 0.5) * intensity;
                    controls.target.y += (Math.random() - 0.5) * intensity;

                    // Shake position (creates "head being hit" feel)
                    camera.position.x += (Math.random() - 0.5) * intensity * 0.5;
                }

                // Flash red with varying intensity
                this.flashScreen();
            },

            hitPlayer: function (damage, isCombo = true) {
                // Execute Hit Effect
                if (window.parent) window.parent.postMessage({ type: 'player_hit', damage: damage }, '*');

                // DEFENSE: Reduction if player is guarding
                if (window.isPlayerGuarding) {
                    damage *= 0.3; // 70% reduction
                    console.log("ðŸ›¡ï¸ Player Blocked Damage!");
                } else {
                    // STUN PLAYER: Briefly interrupt input if not guarding
                    window.isPlayerStunned = true;
                    window.playerStunEndTime = Date.now() + 600; // 600ms stun
                    console.log("ðŸ¥Š Player Stunned!");
                }

                playerHealth -= damage;
                updateGameUI();

                // Camera Impact Shake & Flash
                if (window.controls) {
                    const shake = isCombo ? 0.08 : 0.05;
                    controls.target.x += (Math.random() - 0.5) * shake;
                    controls.target.y += (Math.random() - 0.5) * shake;
                }
                document.body.style.backgroundColor = 'rgba(255,0,0,0.1)';
                setTimeout(() => document.body.style.backgroundColor = 'transparent', 100);

                if (playerHealth <= 0) {
                    endBoxingGame(false);
                }
            },

            flashScreen: function () {
                const flash = document.createElement('div');
                flash.style.position = 'fixed';
                flash.style.top = '0';
                flash.style.left = '0';
                flash.style.width = '100%';
                flash.style.height = '100%';
                flash.style.background = 'radial-gradient(circle, transparent 40%, rgba(255,0,0,0.6) 100%)'; // Vignette hit effect
                flash.style.pointerEvents = 'none';
                flash.style.zIndex = '9999';
                flash.style.transition = 'opacity 0.05s'; // Instant attack
                document.body.appendChild(flash);

                // Force layout reflow
                void flash.offsetWidth;

                setTimeout(() => {
                    flash.style.opacity = '0';
                    setTimeout(() => flash.remove(), 150);
                }, 50); // Short flash (50ms)
            }
        };

        // Initialize AI on page load
        aiController.init();

        window.loadGLTFFromBase64 = function (base64Data) {
            if (!window.isReady) {
                console.log("3D Viewer not ready, buffering model data...");
                window._pendingModelData = base64Data;
                return;
            }

            // Existing logic will be attached to this later or we can just define it here
            // But for now, we'll keep the specialized definition inside init() but 
            // allow this top-level one to catch the early call.
            if (window._actualLoadGLTFFromBase64) {
                window._actualLoadGLTFFromBase64(base64Data);
            } else {
                window._pendingModelData = base64Data;
            }
        };

        function checkDependencies() {
            const startTime = Date.now();
            const TIMEOUT_MS = 15000;

            function check() {
                const missing = [];
                if (!window.THREE) missing.push('THREE');
                if (!window.GLTFLoader) missing.push('GLTFLoader');
                if (!window.OrbitControls) missing.push('OrbitControls');
                if (!window.RoomEnvironment) missing.push('RoomEnvironment');

                if (missing.length === 0) {
                    console.log('âœ“ 3D Viewer initialized successfully');
                    document.getElementById('loader').classList.add('hidden');
                    init();
                    animate();
                    window.isReady = true;

                    // Execute buffered model load
                    if (window._pendingModelData) {
                        console.log("Loading buffered model data...");
                        window.loadGLTFFromBase64(window._pendingModelData);
                        window._pendingModelData = null;
                    }
                    return;
                }

                if (Date.now() - startTime > TIMEOUT_MS) {
                    console.error('âŒ 3D Viewer startup failed: Missing dependencies:', missing.join(', '));
                    const loader = document.getElementById('loader');
                    loader.style.color = '#ff4444';
                    loader.innerHTML = 'Error: Missing ' + missing.join(', ');
                    return;
                }
                requestAnimationFrame(check);
            }
            check();
        }

        window.setCombatMode = function (enabled) {
            stanceController.targetPose = enabled ? 'FIGHT' : 'IDLE';
            console.log("ðŸ¥Š Combat Pose:", stanceController.targetPose);
        };

        window.isPlayerGuarding = false;
        window.setGuarding = function (isGuarding) {
            if (!gameMode) return;
            window.isPlayerGuarding = isGuarding;
            console.log("ðŸ›¡ï¸ Player Guarding:", isGuarding);

            const ui = document.getElementById('game-ui');
            if (ui) {
                let msg = document.getElementById('guard-indicator');
                if (isGuarding) {
                    if (!msg) {
                        msg = document.createElement('div');
                        msg.id = 'guard-indicator';
                        msg.style.color = '#2196F3';
                        msg.style.fontWeight = 'bold';
                        msg.style.marginTop = '10px';
                        msg.innerText = 'ðŸ›¡ï¸ GUARD ACTIVATED';
                        ui.appendChild(msg);
                    }
                } else if (msg) {
                    msg.remove();
                }
            }
        };

        checkDependencies();

        window.addEventListener('resize', () => {
            if (!camera || !renderer) return;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function init() {
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio); // SUPPORT HDPI SCREENS
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x000000, 0);
            document.body.appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
            // Default Position: Closer and higher to frame upper body
            camera.position.set(0, 1.2, 4.0); // Full View Init

            scene = new THREE.Scene();

            // Environment
            const environment = new RoomEnvironment();
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environment = pmremGenerator.fromScene(environment).texture;

            const dirLight = new THREE.DirectionalLight(0xffffff, 3.0);
            dirLight.position.set(5, 10, 7.5);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 20;
            scene.add(dirLight);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);

            const loader = new GLTFLoader();

            // Function to handle the GLTF content once loaded
            function onModelLoaded(gltf) {
                model = gltf.scene;
                window.model = model;

                // Auto-center model on X and Z axes for better rotation (profile views)
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                model.position.x = -center.x;
                model.position.z = -center.z;

                scene.add(model);

                // Animations (Procedural Fallback)
                // Initialize Procedural Stance (ALWAYS)

                stanceController.init();

                if (gltf.animations && gltf.animations.length) {
                    window.mixer = new THREE.AnimationMixer(model);
                    const idle = gltf.animations.find(a => a.name.toLowerCase().includes('idle')) || gltf.animations[0];
                    window.mixer.clipAction(idle).play();
                }

                // Setup Heatmap Materials
                model.traverse(child => {
                    if (child.isMesh) {
                        const name = child.name.toLowerCase();
                        child.castShadow = true;
                        child.receiveShadow = true;

                        // Visibility Logic
                        if (name.includes('glasses') || name.includes('shoes')) {
                            child.visible = false;
                        } else {
                            // Premium "Statue" Material
                            child.material = new THREE.MeshStandardMaterial({
                                color: 0xe0e0e0,
                                roughness: 0.3,
                                metalness: 0.15,
                                envMapIntensity: 1.0,
                                side: THREE.DoubleSide
                            });

                            // Heatmap Shader override
                            applyHeatmapShader(child);
                        }
                    }
                });

                // Notify Flutter that everything is ready
                if (window.FlutterChannel) {
                    window.FlutterChannel.postMessage(JSON.stringify({ type: 'model_loaded' }));
                }

                // Trigger initial update
                if (window.pendingHeatmap) {
                    window.setMuscleHeatmap(window.pendingHeatmap);
                    window.pendingHeatmap = null;
                }
            }
            window.onModelLoaded = onModelLoaded;

            // Expose Loader for Base64 (Flutter Injection)
            window._actualLoadGLTFFromBase64 = function (base64Data) {
                console.log("Received Base64 Model Data");
                try {
                    const dataUri = 'data:model/gltf-binary;base64,' + base64Data;
                    loader.load(dataUri, onModelLoaded, undefined, function (error) {
                        console.error('Error loading Base64 model:', error);
                    });
                } catch (e) {
                    console.error("Exception loading Base64 model", e);
                }
            };

            // Re-check for pending data now that we have the actual loader
            if (window._pendingModelData) {
                window._actualLoadGLTFFromBase64(window._pendingModelData);
                window._pendingModelData = null;
            }

            // NO DEFAULT LOAD: 'model.glb' fails on Android WebView via file://
            // We wait for Flutter to inject the model via window.loadGLTFFromBase64
            console.log("3D Viewer initialized. Waiting for injection.");

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI * 0.6; // Prevent looking under model too much
            controls.minDistance = 1.5;
            controls.maxDistance = 6;
            controls.target.set(0, 1.0, 0);

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('pointerdown', onPointerDown);
            window.addEventListener('pointerup', onPointerUp); // For hold cancellation
            window.addEventListener('pointercancel', onPointerUp);
        }

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.isPlayerStunned = false;
        window.playerStunEndTime = 0;
        let boxingHoldTimer = null; // Timer for 6s hold
        window.boxingEnabled = true;

        window.setBoxingEnabled = function (enabled) {
            window.boxingEnabled = enabled;
            console.log("Boxing Enabled set to:", enabled);
        };

        function onPointerUp() {
            if (boxingHoldTimer) {
                clearTimeout(boxingHoldTimer);
                boxingHoldTimer = null;
                // console.log("Hold cancelled");
            }
        }

        function onPointerDown(event) {
            if (!model) return;

            // Start 6s Hold Timer for Boxing Mode (Only if not already in game AND enabled)
            if (!gameMode && window.boxingEnabled) {
                if (boxingHoldTimer) clearTimeout(boxingHoldTimer);
                boxingHoldTimer = setTimeout(() => {
                    console.log("6s Hold Complete -> Starting Boxing Game");
                    startBoxingGame();
                    boxingHoldTimer = null;
                }, 6000);
            }

            // STUN CHECK: Ignore input if stunned
            if (gameMode && window.isPlayerStunned) {
                if (Date.now() < window.playerStunEndTime) {
                    console.log("ðŸ˜µ Player is stunned! Cannot attack.");
                    return;
                } else {
                    window.isPlayerStunned = false;
                }
            }

            // Start Long-Press timer for Guarding (In-Game Only)
            if (gameMode) {
                if (stanceController.guardTimer) clearTimeout(stanceController.guardTimer);
                stanceController.guardTimer = setTimeout(() => {
                    window.setGuarding(true);
                }, 200);
            }

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(model, true);

            // FILTER FOR VISIBLE MESHES ONLY (Fixes unselectable muscles)
            let hit = null;
            for (let i = 0; i < intersects.length; i++) {
                if (intersects[i].object.visible) {
                    hit = intersects[i];
                    break;
                }
            }

            if (hit) {
                // Tapped the BODY
                const muscle = getMuscleAtPoint(hit.point);

                if (gameMode) {
                    handleGameHit(muscle, hit.point);
                } else if (muscle) {
                    // console.log("Hit muscle:", muscle, "at", hit.point);
                    if (window.FlutterChannel) {
                        window.FlutterChannel.postMessage(JSON.stringify({ type: 'muscle_tap', name: muscle }));
                    }
                }
            } else {
                // Tapped background
                // Hold timer is already running, nothing specific to do here for tap counting anymore
            }
        }

        function startBoxingGame() {
            if (gameMode) return;
            console.log("ðŸ¥Š BOXING GAME STARTING...");

            // 1. Hide Muscle Status (Heatmap) Gracefully
            // Cache current logic status to restore later
            window._cachedHeatmapState = { ...activeHeatmap };
            // Clear the logical heatmap so it doesn't bleed into the fight
            window.resetHeatmap();

            // 2. Full Screen Mode for Immersion
            const elem = document.documentElement;
            try {
                if (elem.requestFullscreen) {
                    elem.requestFullscreen().catch(err => console.log("Fullscreen blocked:", err));
                } else if (elem.webkitRequestFullscreen) { /* Safari */
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) { /* IE11 */
                    elem.msRequestFullscreen();
                }
            } catch (e) {
                console.log("Fullscreen request failed", e);
            }

            if (model) model.position.set(0, 0, 0);
            isZooming = false;

            gameMode = true;
            modelHealth = 100;
            playerHealth = 100;
            gameScore = 0;
            comboCount = 0;

            // Enable AI
            aiController.enabled = true;
            aiController.lastAttackTime = Date.now();

            if (window.mixer) window.mixer.stopAllAction();
            if (window.setCombatMode) window.setCombatMode(true);

            // Intro Camera Sequence (Full View first)
            if (window.controls && window.camera) {
                controls.enabled = false;

                // 1. Show Upper Body (Hips to Head)
                // Y=1.45 centers slightly higher (Upper Chest), pushing hips down.
                camera.position.set(0, 1.45, 2.5);
                controls.target.set(0, 1.45, 0); // Important: Update controls target too
                camera.lookAt(0, 1.45, 0);

                showGameUI();
            }

            // Cleanup old lights/debug
            if (scene.getObjectByName("debug_cube")) scene.remove(scene.getObjectByName("debug_cube"));
            if (scene.getObjectByName("game_ambient")) scene.remove(scene.getObjectByName("game_ambient"));

            const amb = new THREE.AmbientLight(0xffffff, 1.5);
            amb.name = "game_ambient";
            scene.add(amb);

            // GEOMETRY & MATERIAL FIX (Strip Shaders) -> Moved to happen immediately for perf
            // (But maybe we want to keep heatmap for the intro 2s? nah, strip it to indicate change)
            if (model) {
                model.scale.set(1.2, 1.2, 1.2); // Scale up for fight
                model.updateMatrixWorld(true);
                model.traverse(c => {
                    if (c.isMesh && c.visible) {
                        c.frustumCulled = false;
                        c.renderOrder = 0;
                        if (c.material && c.material.type !== 'MeshStandardMaterial') {
                            c.material = new THREE.MeshStandardMaterial({
                                map: c.material.map,
                                normalMap: c.material.normalMap,
                                roughnessMap: c.material.roughnessMap,
                                color: c.material.color,
                                roughness: 0.6,
                                metalness: 0.1,
                                skinning: true,
                                side: THREE.DoubleSide
                            });
                        }
                    }
                });
            }

            if (window._savedBones) {
                stanceController.bones = window._savedBones;
                stanceController.targetPose = 'FIGHT';
            } else {
                stanceController.targetPose = 'FIGHT';
            }

            showGameUI();

            if (window.FlutterChannel) {
                window.FlutterChannel.postMessage(JSON.stringify({ type: 'game_start', mode: 'boxing' }));
            }
        }

        function handleGameHit(muscle, point) {
            if (!gameMode) return;

            // CLEAR GUARD TIMER: If we are attacking, we are not guarding
            if (stanceController.guardTimer) {
                clearTimeout(stanceController.guardTimer);
                stanceController.guardTimer = null;
            }
            window.setGuarding(false);

            let damage = 5;
            let isWeakPoint = false;
            let hitText = "HIT!";
            let isCritical = false;

            // CHECK GUARD (Damage Mitigation)
            if (stanceController.targetPose === 'GUARD') {
                damage *= 0.3; // Blocked damage
                hitText = "BLOCKED";
                // Play metallic/thud sound?
            }

            // 1. Weak Point (Anatomical)
            const weakPoints = ['Neck', 'Chest', 'Upper Abs', 'Lower Abs'];
            if (muscle && weakPoints.includes(muscle)) {
                damage = 10;
                isWeakPoint = true;
                hitText = "SOLID!";
            }

            // 2. Tired Spot (Heatmap Logic)
            if (muscle && activeHeatmap[muscle] > 0.6) {
                damage += 15; // Massive Bonus
                isCritical = true;
                isWeakPoint = true;
                hitText = "TIRED SPOT!";
                gameScore += 100; // Extra points
            }

            if (!muscle) {
                damage = 2; // Generic hit
            }

            modelHealth -= damage;
            gameScore += damage * (comboCount + 1);

            const now = Date.now();
            if (now - gameLastHitTime < 1000) {
                comboCount++;
            } else {
                comboCount = 0;
            }
            gameLastHitTime = now;

            // Procedural Twitch/Block React
            if (stanceController.triggerHit) {
                stanceController.triggerHit(muscle, point, isCritical);
            }

            // CANCEL ATTACK & TRIGGER GUARD
            if (aiController) {
                aiController.cancelAttack();

                // Reactive Guard (try to block next hit)
                if (Math.random() < 0.4 && !aiController.isGuarding) {
                    setTimeout(() => aiController.activateGuard(), 300);
                }
            }

            // Visual feedback - flash red (brighter if critical)
            flashModelColor(isCritical ? 0xffaa00 : (isWeakPoint ? 0xff0000 : 0xffffff));

            // Add Hit Marker UI? Just console for now
            if (isCritical) console.log("ðŸ”¥ CRITICAL TIRED HIT!");

            updateGameUI();

            // Update Heatmap for this hit (make it hotter)
            updateHeatmap(muscle, point);

            if (modelHealth <= 0) {
                endBoxingGame(true);
            }
        }

        function flashModelColor(color) {
            // DISABLED FOR DEBUGGING (Prevent Invisible Material)
            return;
        }

        function showGameUI() {
            // console.log("Showing Game UI...");
            let ui = document.getElementById('game-ui');
            if (!ui) {
                ui = document.createElement('div');
                ui.id = 'game-ui';
                ui.style.position = 'absolute';
                ui.style.top = '0';
                ui.style.left = '0';
                ui.style.width = '100%';
                ui.style.height = '100%';
                ui.style.pointerEvents = 'none'; // Allow clicks to pass through to canvas
                ui.style.zIndex = '1000';

                ui.innerHTML = `
                    <!-- EXIT BUTTON (Top Right) -->
                    <button id="exit-game-btn" style="
                        pointer-events: auto;
                        position: absolute;
                        top: 20px;
                        right: 20px;
                        background: #d32f2f;
                        color: white;
                        border: 2px solid white;
                        border-radius: 50%;
                        width: 32px;
                        height: 32px;
                        font-weight: bold;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        padding: 0;
                        box-shadow: 0 2px 5px rgba(0,0,0,0.3);
                    ">X</button>

                    <!-- AI / MODEL HEALTH (Top Left - RED) -->
                    <div style="position: absolute; top: 20px; left: 20px; text-align: left;">
                        <div style="font-weight: 900; color: #ff4444; font-size: 16px; margin-bottom: 4px; text-shadow: 1px 1px 2px black; font-family: sans-serif; letter-spacing: 1px;">YOU (AI)</div>
                        <div style="width: 150px; height: 10px; background: rgba(0,0,0,0.5); border: 1px solid #555; border-radius: 5px; overflow: hidden;">
                            <div id="health-bar" style="width: 100%; height: 100%; background: linear-gradient(90deg, #ff4444, #b71c1c); transition: width 0.3s ease;"></div>
                        </div>
                    </div>

                    <!-- PLAYER HEALTH (Bottom Right - GREEN) -->
                    <div style="position: absolute; bottom: 80px; right: 20px; text-align: right;">
                        <div style="font-weight: 900; color: #4CAF50; font-size: 16px; margin-bottom: 4px; text-shadow: 1px 1px 2px black; font-family: sans-serif; letter-spacing: 1px;">YOU</div>
                        <div style="width: 150px; height: 10px; background: rgba(0,0,0,0.5); border: 1px solid #555; border-radius: 5px; overflow: hidden; margin-left: auto;">
                            <div id="player-health-bar" style="width: 100%; height: 100%; background: linear-gradient(90deg, #43a047, #4CAF50); transition: width 0.3s ease;"></div>
                        </div>
                    </div>
                `;
                document.body.appendChild(ui);

                // Add event listener to the button (since we just created it)
                setTimeout(() => {
                    const btn = document.getElementById('exit-game-btn');
                    if (btn) {
                        btn.onclick = function () {
                            console.log("Exit button clicked");
                            endBoxingGame(false);
                        };
                        // Also Add touch event for mobile responsiveness
                        btn.ontouchstart = function (e) {
                            e.preventDefault();
                            endBoxingGame(false);
                        };
                    }
                }, 100);
            }
            ui.style.display = 'block';
        }

        function updateGameUI() {
            const healthBar = document.getElementById('health-bar');
            const playerHealthBar = document.getElementById('player-health-bar');
            if (healthBar) healthBar.style.width = modelHealth + '%';
            if (playerHealthBar) playerHealthBar.style.width = playerHealth + '%';
        }

        function endBoxingGame(won) {
            gameMode = false;
            aiController.enabled = false;
            aiController.isAttacking = false;
            aiController.isGuarding = false;
            aiController.lungeState = null;
            aiController.comboQueue = [];

            // Disable procedural stance temporarily so animation can play
            stanceController.targetPose = null;

            // Knockdown animation if won
            if (won && window.mixer) {
                const fallAnim = model.animations.find(a => a.name.toLowerCase().includes('fall') || a.name.toLowerCase().includes('death') || a.name.toLowerCase().includes('hit'));
                if (fallAnim) {
                    const action = window.mixer.clipAction(fallAnim);
                    action.setLoop(THREE.LoopOnce);
                    action.clampWhenFinished = true;
                    action.reset().fadeIn(0.2).play();
                    // Fade out others
                    model.animations.forEach(a => {
                        if (a !== fallAnim && window.mixer.clipAction(a).isRunning()) {
                            window.mixer.clipAction(a).fadeOut(0.2);
                        }
                    });
                }
            }

            const ui = document.getElementById('game-ui');
            if (ui) {
                ui.innerHTML = `
                    <div style="font-weight: bold; color: #ff4444; font-size: 20px; margin-bottom: 10px;">${won ? 'KNOCKOUT!' : 'FINISHED'}</div>
                    <div style="font-size: 14px; color: #888; margin-top: 10px;">Body reset in 3s...</div>
                `;
            }

            // DELAYED RESTORATION (3 Seconds)
            setTimeout(() => {
                // 1. Exit Fullscreen (End of Experience)
                if (document.exitFullscreen) {
                    document.exitFullscreen().catch(e => console.log("Exit fullscreen failed", e));
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }

                const ui = document.getElementById('game-ui');
                if (ui) ui.style.display = 'none';

                // 2. FORCE RESTORE MODEL (Position & Shaders)
                if (model) {
                    // Reset Animation Mixer
                    if (window.mixer) window.mixer.stopAllAction();

                    // Reset Position
                    model.position.set(0, 0, 0);
                    model.scale.set(1, 1, 1);

                    // Restore Shaders & Visibility
                    model.traverse(c => {
                        if (c.isMesh) {
                            // SKIP HIDDEN (Respect Original Visibility)
                            if (!c.visible) return;

                            c.frustumCulled = false;

                            // RESTORE SHADERS (Fix White Model)
                            if (c.material) {
                                c.material.opacity = 1.0;
                                c.material.transparent = false;

                                // Re-apply Heatmap Shader Logic
                                if (window.applyHeatmapShader) applyHeatmapShader(c);
                            }
                        }
                    });

                    // RESTORE HEATMAP DATA
                    if (window._cachedHeatmapState) {
                        console.log("Restoring Heatmap Data...");
                        for (let key in window._cachedHeatmapState) {
                            activeHeatmap[key] = window._cachedHeatmapState[key];
                        }
                        window._cachedHeatmapState = null;
                        updateUniforms(); // Force update
                    }
                }

                // 3. Return to Idle Stance
                if (window.setCombatMode) window.setCombatMode(false); // Sets targetPose to 'IDLE'

                // 4. Return Camera
                if (window.camera && window.controls) {
                    camera.position.set(0, 1.2, 4.0); // Full View Reset
                    controls.target.set(0, 1.0, 0); // Reset target (was 1.35/1.45 during game)

                    // UNLOCK CONTROLS
                    controls.enabled = true;
                    controls.enableZoom = true;
                    controls.enablePan = true;
                    controls.enableRotate = true;
                    controls.enableDamping = true;
                    controls.update();
                }
            }, 3000);

            if (window.FlutterChannel) {
                window.FlutterChannel.postMessage(JSON.stringify({ type: 'game_end', score: gameScore }));
            }
        }

        function getMuscleAtPoint(point) {
            let bestMuscle = null;
            let minDist = Infinity;

            muscleDefs.forEach(def => {
                let startPos = new THREE.Vector3();
                let endPos = new THREE.Vector3();

                if (def.bone) {
                    const bone = getBoneCached(def.bone);
                    if (bone) {
                        bone.getWorldPosition(startPos);
                        if (def.offset) {
                            const off = new THREE.Vector3(...def.offset);
                            const q = new THREE.Quaternion();
                            bone.getWorldQuaternion(q);
                            startPos.add(off.applyQuaternion(q));
                        }
                        endPos.copy(startPos).add(new THREE.Vector3(0, -0.01, 0));
                    }
                } else if (def.start && def.end) {
                    const sBone = getBoneCached(def.start);
                    const eBone = getBoneCached(def.end);
                    if (sBone && eBone) {
                        sBone.getWorldPosition(startPos);
                        eBone.getWorldPosition(endPos);
                        if (def.offset) {
                            const off = new THREE.Vector3(...def.offset);
                            const q = new THREE.Quaternion();
                            sBone.getWorldQuaternion(q);
                            startPos.add(off.applyQuaternion(q));
                            endPos.add(off.applyQuaternion(q));
                        }
                    }
                }

                const d = distToSegment(point, startPos, endPos);
                if (d < def.radius && d < minDist) {
                    minDist = d;
                    bestMuscle = def.name;
                }
            });

            return bestMuscle;
        }

        function distToSegment(p, a, b) {
            const pa = new THREE.Vector3().subVectors(p, a);
            const ba = new THREE.Vector3().subVectors(b, a);
            const h = THREE.MathUtils.clamp(pa.dot(ba) / ba.dot(ba), 0, 1);
            return pa.sub(ba.multiplyScalar(h)).length();
        }

        function applyHeatmapShader(mesh) {
            // Store original material reference to avoid losing textures
            const baseMaterial = mesh.material;

            mesh.material.onBeforeCompile = (shader) => {
                shader.uniforms.u_zone_starts = uniformData.u_zone_starts;
                shader.uniforms.u_zone_ends = uniformData.u_zone_ends;
                shader.uniforms.u_zone_radii = uniformData.u_zone_radii;
                shader.uniforms.u_zone_intensities = uniformData.u_zone_intensities;
                shader.uniforms.u_zone_count = uniformData.u_zone_count;

                shader.vertexShader = `
                    varying vec3 vWorldPosition;
                    ${shader.vertexShader}
                `.replace(
                    '#include <worldpos_vertex>',
                    `
                #include <worldpos_vertex>
                    vWorldPosition = (modelMatrix * vec4(transformed, 1.0)).xyz;
                `
                );

                shader.fragmentShader = `
                    uniform vec3 u_zone_starts[${MAX_ZONES}];
                    uniform vec3 u_zone_ends[${MAX_ZONES}];
                    uniform float u_zone_radii[${MAX_ZONES}];
                    uniform float u_zone_intensities[${MAX_ZONES}];
                    uniform int u_zone_count;
                    varying vec3 vWorldPosition;

                    float distToSegment(vec3 p, vec3 a, vec3 b) {
                        vec3 pa = p - a, ba = b - a;
                        float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
                    return length(pa - ba * h);
                }

                    ${shader.fragmentShader}
                `.replace(
                    '#include <dithering_fragment>',
                    `
                #include <dithering_fragment>
                    float totalHeat = 0.0;
                for (int i = 0; i < ${MAX_ZONES}; i++) {
                    if (i >= u_zone_count) break;
                        float dist = distToSegment(vWorldPosition, u_zone_starts[i], u_zone_ends[i]);
                        float radius = u_zone_radii[i];
                    if (dist < radius) {
                            float factor = 1.0 - (dist / radius);
                        totalHeat += factor * u_zone_intensities[i] * 1.5;
                    }
                }
                totalHeat = clamp(totalHeat, 0.0, 1.0);
                if (totalHeat > 0.05) {
                        vec3 heatColor = vec3(1.0, 0.25, 0.0); // Vibrant Orange/Red
                    gl_FragColor.rgb = mix(gl_FragColor.rgb, heatColor, totalHeat * 0.7);
                    // Add glow
                    gl_FragColor.rgb += heatColor * totalHeat * 0.3;
                }
                `
                );
            };
            mesh.material.needsUpdate = true;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function animate() {
            const time = Date.now();
            requestAnimationFrame(animate);

            // PERSISTENT VISIBILITY FIX (Prevent Flickering)
            if (model && gameMode) {
                model.traverse(c => {
                    if (c.isMesh) {
                        c.frustumCulled = false;
                        // c.visible = true; // REMOVED: Do not force visibility of hidden meshes (Sunglasses/Layers)
                    }
                });
            }

            // Apply Manual/Procedural Stance

            const delta = 0.016; // Assuming 60fps
            if (window.mixer) {
                window.mixer.update(delta);
            }

            const now = Date.now();
            if (stanceController) {
                // IMPORTANT: Run stance controller AFTER mixer to overwrite bone rotations
                stanceController.update(now);
            }
            if (aiController) aiController.update(now);

            // CAMERA CONTROL LOGIC
            if (isZooming) {
                updateZoom();
                if (controls) controls.enabled = false;
            } else {
                // Only enable controls if NOT in game mode (Boxing locks camera)
                if (window.controls) {
                    if (!gameMode) controls.enabled = true;
                    // If gameMode, controls.enabled was set to false by startBoxingGame
                }
            }

            // SAFETY NET: Check for NaN Camera
            if (camera && (isNaN(camera.position.x) || isNaN(camera.position.y) || isNaN(camera.position.z))) {
                console.error("CAMERA BECAME NAN! RESETTING!");
                camera.near = 0.05;
                camera.updateProjectionMatrix();
                camera.position.set(0, 1.6, 3.0); // Restored original Upper Body focus
                camera.lookAt(0, 1.6, 0);
                if (controls) {
                    controls.target.set(0, 1.6, 0);
                    controls.update();
                }
            }

            if (window.controls) controls.update();
            updateUniforms();
            renderer.render(scene, camera);
        }

        const boneCache = {};
        function getBoneCached(name) {
            if (boneCache[name]) return boneCache[name];
            const bone = findBone(name);
            if (bone) boneCache[name] = bone;
            return bone;
        }

        function updateUniforms() {
            if (!model) return;
            let count = 0;
            const starts = uniformData.u_zone_starts.value;
            const ends = uniformData.u_zone_ends.value;
            const radii = uniformData.u_zone_radii.value;
            const intensities = uniformData.u_zone_intensities.value;

            // Hoist temporary variables to avoid GC in animation loop
            const _tempStart = new THREE.Vector3();
            const _tempEnd = new THREE.Vector3();
            const _tempOff = new THREE.Vector3();
            const _tempQ = new THREE.Quaternion();
            const _down = new THREE.Vector3(0, -0.01, 0);

            muscleDefs.forEach(def => {
                const intensity = activeHeatmap[def.name] || 0;
                if (intensity > 0) {
                    if (count >= MAX_ZONES) return;

                    // Reset temps
                    _tempStart.set(0, 0, 0);
                    _tempEnd.set(0, 0, 0);

                    if (def.bone) {
                        const bone = getBoneCached(def.bone);
                        if (bone) {
                            bone.getWorldPosition(_tempStart);
                            if (def.offset) {
                                _tempOff.set(def.offset[0], def.offset[1], def.offset[2]);
                                bone.getWorldQuaternion(_tempQ);
                                _tempStart.add(_tempOff.applyQuaternion(_tempQ));
                            }
                            _tempEnd.copy(_tempStart).add(_down);
                        }
                    } else if (def.start && def.end) {
                        const sBone = getBoneCached(def.start);
                        const eBone = getBoneCached(def.end);
                        if (sBone && eBone) {
                            sBone.getWorldPosition(_tempStart);
                            eBone.getWorldPosition(_tempEnd);
                            if (def.offset) {
                                _tempOff.set(def.offset[0], def.offset[1], def.offset[2]);
                                sBone.getWorldQuaternion(_tempQ);
                                _tempOff.applyQuaternion(_tempQ); // Rotate offset
                                _tempStart.add(_tempOff);
                                _tempEnd.add(_tempOff);
                            }
                        }
                    }

                    starts[count * 3] = _tempStart.x;
                    starts[count * 3 + 1] = _tempStart.y;
                    starts[count * 3 + 2] = _tempStart.z;
                    ends[count * 3] = _tempEnd.x;
                    ends[count * 3 + 1] = _tempEnd.y;
                    ends[count * 3 + 2] = _tempEnd.z;
                    radii[count] = def.radius;
                    intensities[count] = intensity;
                    count++;
                }
            });
            uniformData.u_zone_count.value = count;
        }

        function findBone(name) {
            if (!model) return null;
            let firstMatch = null;
            let exactMatch = null;

            model.traverse(child => {
                // Check basically everything in the hierarchy that has a name
                const cName = child.name;
                if (!cName) return;

                const isPotentialBone = child.isBone || child.type === 'Bone' || cName.toLowerCase().includes('bone') || cName.toLowerCase().includes('joint');

                // Check for exact match or standardized patterns
                if (cName === name || cName === 'Mixamo_' + name || cName.split(':').pop() === name) {
                    exactMatch = child;
                }

                // Fallback to fuzzy includes
                if (!firstMatch && cName.toLowerCase().includes(name.toLowerCase())) {
                    firstMatch = child;
                }
            });

            const result = exactMatch || firstMatch;
            return result;
        }

        window.addEventListener('pointerup', () => {
            if (stanceController.guardTimer) {
                clearTimeout(stanceController.guardTimer);
                stanceController.guardTimer = null;
            }
            window.setGuarding(false);
        });

        // --- PUBLIC API ---

        window.zoomToMuscle = function (muscleName) {
            console.log('Zooming to muscle:', muscleName);
            const def = muscleDefs.find(m => m.name === muscleName);
            if (!def) {
                console.warn('Muscle definition not found for:', muscleName);
                return;
            }

            // Calculate target position (center of muscle)
            let center = new THREE.Vector3();
            if (def.bone) {
                const bone = findBone(def.bone);
                if (bone) {
                    bone.getWorldPosition(center);
                    console.log(`Def ${def.name}: Bone ${bone.name} at`, center);
                    if (def.offset) {
                        const off = new THREE.Vector3(...def.offset);
                        const q = new THREE.Quaternion();
                        bone.getWorldQuaternion(q);
                        center.add(off.applyQuaternion(q));
                    }
                }
            } else if (def.start && def.end) {
                const sBone = findBone(def.start);
                const eBone = findBone(def.end);
                if (sBone && eBone) {
                    const sPos = new THREE.Vector3();
                    const ePos = new THREE.Vector3();
                    sBone.getWorldPosition(sPos);
                    eBone.getWorldPosition(ePos);
                    console.log(`Def ${def.name}: StartBone ${sBone.name} at ${sPos}, EndBone ${eBone.name} at ${ePos}`);
                    center.addVectors(sPos, ePos).multiplyScalar(0.5);

                    if (def.offset) {
                        const off = new THREE.Vector3(...def.offset);
                        const q = new THREE.Quaternion();
                        sBone.getWorldQuaternion(q);
                        center.add(off.applyQuaternion(q));
                    }
                }
            }

            console.log('Final Calculated Center:', center);

            // Set controls target to muscle center
            targetControlsTarget.copy(center);

            // Calculate optimal camera position
            // Determine viewing angle based on muscle position (front/back)
            // Ideally, we maintain current azimuth but adjust height and distance.
            // Simple heuristic to verify:
            // For now, let's keep the camera at a nice fixed distance relative to the muscle
            const offsetDir = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
            // Force a slight "up" angle if looking too flat
            if (Math.abs(offsetDir.y) < 0.2) offsetDir.y = 0.2;
            offsetDir.normalize();

            const distance = 1.0; // Zoom distance (tweak as needed)
            targetCameraPos.copy(center).add(offsetDir.multiplyScalar(distance));

            // Start Animation
            startCameraPos.copy(camera.position);
            startControlsTarget.copy(controls.target);
            zoomStartTime = Date.now();
            isZooming = true;
        };

        window.resetCamera = function () {
            // Reset to initial state
            targetControlsTarget.set(0, 1.0, 0);
            targetCameraPos.set(0, 1.2, 4.0); // Full View Default

            startCameraPos.copy(camera.position);
            startControlsTarget.copy(controls.target);
            zoomStartTime = Date.now();
            isZooming = true;
        };

        // HEATMAP LOGIC
        // const activeHeatmap = {}; // Already declared globally

        function updateHeatmap(muscle, point) {
            if (!muscle) return;

            // Increment heat
            if (!activeHeatmap[muscle]) activeHeatmap[muscle] = 0;
            activeHeatmap[muscle] += 0.3; // 3-4 hits to max out
            if (activeHeatmap[muscle] > 1.0) activeHeatmap[muscle] = 1.0;

            // "Splash" damage? Maybe slightly heat neighbors?
            // For now, simple direct heat.
        }

        // Decay Heatmap over time (in animate loop or here with setInterval)
        setInterval(() => {
            for (let m in activeHeatmap) {
                if (activeHeatmap[m] > 0) {
                    activeHeatmap[m] -= 0.05; // Cooldown
                    if (activeHeatmap[m] < 0) activeHeatmap[m] = 0;
                }
            }
        }, 1000); // Run every second

        window.setMuscleHeatmap = function (heatmap) {
            if (!model) {
                window.pendingHeatmap = heatmap;
                return;
            }
            // Clear current
            for (const key in activeHeatmap) activeHeatmap[key] = 0;

            const aliases = {
                'Upper Chest': 'Chest', 'Lower Chest': 'Chest',
                'Shoulders': ['Front Shoulders', 'Side Shoulders', 'Rear Shoulders'],
                'Traps': 'Traps',
                'Abs': ['Upper Abs', 'Lower Abs'],
                'Lower Back': 'Lower Back',
                'Adductors': 'Inner Thighs',
                'Abductors': 'Outer Thighs',
                'Hip flexors': ['Quads', 'Upper Abs']
            };
            const groups = {
                'Arms': ['Biceps', 'Triceps', 'Forearms'],
                'Legs': ['Quads', 'Hamstrings', 'Calves', 'Glutes', 'Inner Thighs', 'Outer Thighs', 'Shins'],
                'Back': ['Lats', 'Upper Back', 'Lower Back', 'Traps'],
                'Core': ['Upper Abs', 'Lower Abs', 'Obliques']
            };

            for (const key in heatmap) {
                const intensity = heatmap[key];
                if (intensity <= 0) continue;

                // Ignore non-muscle keys to prevent log pollution
                if (key === 'Cardio' || key === 'Full Body') continue;

                let targets = [key];

                // Add aliases
                if (aliases[key]) {
                    if (Array.isArray(aliases[key])) targets = targets.concat(aliases[key]);
                    else targets.push(aliases[key]);
                }

                // Add groups
                if (groups[key]) {
                    targets = targets.concat(groups[key]);
                }

                targets.forEach(t => {
                    const variants = [t, t + ' (Left)'];
                    variants.forEach(v => {
                        if (muscleDefs.some(d => d.name === v)) {
                            activeHeatmap[v] = Math.max(activeHeatmap[v] || 0, intensity);
                        }
                    });
                });
            }

        };

        window.resetHeatmap = function () {
            for (const key in activeHeatmap) activeHeatmap[key] = 0;
        };

        window.getCameraState = function () {
            return JSON.stringify({
                position: camera.position,
                target: controls.target
            });
        };

        window.setCameraState = function (stateJson) {
            try {
                const state = JSON.parse(stateJson);
                if (state.position) camera.position.set(state.position.x, state.position.y, state.position.z);
                if (state.target) controls.target.set(state.target.x, state.target.y, state.target.z);
                if (controls) controls.update();
            } catch (e) {
                console.error("Error setting camera state:", e);
            }
        };

        window.setBackgroundColor = function (color) {
            // Support hex or css color strings
            document.body.style.backgroundColor = color;
            // Also update renderer if it's not transparent anymore, but we'll stick to CSS for ease
        };

        window.setProfileView = function (side) {
            // side: 'front', 'back', 'left', 'right'
            const positions = {
                'front': { x: 0, z: 3.5 },
                'back': { x: 0, z: -3.5 },
                'left': { x: -3.5, z: 0 },
                'right': { x: 3.5, z: 0 }
            };
            const pos = positions[side] || positions['front'];

            targetCameraPos.set(pos.x, 1.2, pos.z);
            targetControlsTarget.set(0, 1.0, 0);

            startCameraPos.copy(camera.position);
            startControlsTarget.copy(controls.target);
            zoomStartTime = Date.now();
            isZooming = true;
        };

        window.setRotationMode = function (mode) {
            if (!controls) return;
            if (mode === 'horizontal') {
                controls.minPolarAngle = Math.PI * 0.5; // Lock to horizontal (90 deg)
                controls.maxPolarAngle = Math.PI * 0.5;
            } else {
                controls.minPolarAngle = 0; // Full 360 (vertical too)
                controls.maxPolarAngle = Math.PI;
            }
            controls.update();
        };

        function updateZoom() {
            if (!isZooming) return;

            const now = Date.now();
            const progress = Math.min((now - zoomStartTime) / zoomDuration, 1.0);

            // Smooth Quartic Ease Out
            const ease = 1 - Math.pow(1 - progress, 4);

            camera.position.lerpVectors(startCameraPos, targetCameraPos, ease);
            controls.target.lerpVectors(startControlsTarget, targetControlsTarget, ease);

            if (progress >= 1.0) {
                isZooming = false;
            }
        }

        console.log("3D Viewer initialized (Global Mode)");

        // Showcase trigger
        if (new URLSearchParams(window.location.search).get('showcase') === '1') {
            const script = document.createElement('script');
            script.src = 'showcase.js';
            document.body.appendChild(script);
        }
    </script>
    <script src="debug_loader.js"></script>
</body>

</html>