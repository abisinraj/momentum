<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0;
            background-color: #f0f0f0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script src="three_global.js"></script>
    <script>
        const THREE = window.THREE;

        let camera, scene, renderer, group;
        let muscleMeshes = {}; // Store mesh references for coloring: { 'Biceps': [mesh1, mesh2], ... }

        // Config
        const COLOR_BASE = 0xE0E0E0; // Light Grey/Skin tone base
        const COLOR_HIGHLIGHT = 0xFF4400; // Orange Red

        // Lighting
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0); // Soft grey background

            // Camera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 400;
            camera.position.y = 50;

            // Lights (Essential for solid objects)
            scene.add(hemiLight);

            dirLight.position.set(10, 200, 100);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // Rim light for definition
            const backLight = new THREE.DirectionalLight(0x445566, 0.8);
            backLight.position.set(-100, 0, -100);
            scene.add(backLight);

            group = new THREE.Group();
            scene.add(group);

            // Build Muscles
            buildAnatomy();

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Interaction
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            const onDown = (x, y) => { isDragging = true; previousMousePosition = { x, y }; };
            const onUp = () => isDragging = false;
            const onMove = (x, y) => {
                if (isDragging) {
                    const deltaX = x - previousMousePosition.x;
                    group.rotation.y += deltaX * 0.005;
                    previousMousePosition = { x, y };
                }
            };
            document.addEventListener('mousedown', e => onDown(e.clientX, e.clientY));
            document.addEventListener('mousemove', e => onMove(e.clientX, e.clientY));
            document.addEventListener('mouseup', onUp);
        }

        // Helper to register mesh
        function registerMesh(name, mesh) {
            if (!muscleMeshes[name]) muscleMeshes[name] = [];
            muscleMeshes[name].push(mesh);
        }

        function createMuscleTube(start, end, radius, bulge, name) {
            const path = new THREE.LineCurve3(start, end);
            // Thick tube geometry
            const geometry = new THREE.TubeGeometry(path, 4, radius, 8, false);

            // Modify vertices for bulge (Simple taper)
            // Note: TubeGeometry is hard to taper simply without extending class, 
            // but we can scale the mesh or use Lathe.
            // Let's stick to Tube for prototyping, maybe scale mid?

            // Better: CapsuleGeometry for limbs.
            // Let's us Tube for now, it's flexible.

            const material = new THREE.MeshStandardMaterial({
                color: COLOR_BASE,
                roughness: 0.4,
                metalness: 0.1,
            });

            const mesh = new THREE.Mesh(geometry, material);
            group.add(mesh);
            registerMesh(name, mesh);
        }

        // Uses CapsuleGeometry (Three r137+, assuming we have it, else Cylinder)
        // Checks if Capsule exists, else Cylinder
        function createMuscleCapsule(start, end, radius, name) {
            const vec = new THREE.Vector3().subVectors(end, start);
            const length = vec.length();

            // Create Geometry
            let geometry;
            if (THREE.CapsuleGeometry) {
                geometry = new THREE.CapsuleGeometry(radius, length, 4, 8);
            } else {
                geometry = new THREE.CylinderGeometry(radius, radius, length, 12);
            }

            const material = new THREE.MeshStandardMaterial({
                color: COLOR_BASE,
                roughness: 0.3,
                metalness: 0.0,
            });

            const mesh = new THREE.Mesh(geometry, material);

            // Orient and Position
            // Cylinder is created vertical (Y-axis), centered at (0,0,0)
            const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
            mesh.position.copy(mid);
            mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), vec.clone().normalize());

            mesh.castShadow = true;
            mesh.receiveShadow = true;

            group.add(mesh);
            registerMesh(name, mesh);
        }

        function buildAnatomy() {
            // Coordinate System (Same as V2)
            const yHeadTop = 175;
            const yNeckBase = 150;
            const yShoulder = 145;
            const yChest = 135;
            const yWaist = 110;
            const yHip = 95;
            const yKnee = 50;
            const yFoot = 0;

            const xShoulder = 23;
            const xHip = 15;
            const xKnee = 12;
            const xFoot = 15;

            const yElbow = 118;
            const yArmEnd = 78;

            const neck = new THREE.Vector3(0, yNeckBase, 0);
            const shoulderL = new THREE.Vector3(-xShoulder, yShoulder, 0);
            const shoulderR = new THREE.Vector3(xShoulder, yShoulder, 0);
            const hipL = new THREE.Vector3(-xHip, yHip, 0);
            const hipR = new THREE.Vector3(xHip, yHip, 0);
            const kneeL = new THREE.Vector3(-xKnee, yKnee, 5);
            const kneeR = new THREE.Vector3(xKnee, yKnee, 5);
            const footL = new THREE.Vector3(-xFoot, yFoot, 15);
            const footR = new THREE.Vector3(xFoot, yFoot, 15);

            const elbowL = new THREE.Vector3(-30, yElbow, 5);
            const elbowR = new THREE.Vector3(30, yElbow, 5);
            const handL = new THREE.Vector3(-32, yArmEnd, 10);
            const handR = new THREE.Vector3(32, yArmEnd, 10);

            // -- SOLID CONSTRUCTION --

            // Head
            createMuscleCapsule(new THREE.Vector3(0, 155, 0), new THREE.Vector3(0, 175, 0), 10, 'Head');

            // Neck
            createMuscleCapsule(new THREE.Vector3(0, 150, 0), new THREE.Vector3(0, 155, 0), 6, 'Traps');

            // Torso (Abstracted as Chest + Abs blocks)
            createMuscleCapsule(new THREE.Vector3(0, 130, 0), new THREE.Vector3(0, 150, 0), 16, 'Chest');
            createMuscleCapsule(new THREE.Vector3(0, 110, 0), new THREE.Vector3(0, 130, 0), 13, 'Abs');
            createMuscleCapsule(new THREE.Vector3(0, 95, 0), new THREE.Vector3(0, 110, 0), 14, 'Abs'); // Lower Abs/Hips

            // Shoulders (Delts)
            createMuscleCapsule(shoulderL, new THREE.Vector3(-xShoulder, 135, 0), 7, 'Shoulders');
            createMuscleCapsule(shoulderR, new THREE.Vector3(xShoulder, 135, 0), 7, 'Shoulders');

            // Arms
            // Biceps (Front offset slightly)
            createMuscleCapsule(shoulderL, elbowL, 5, 'Biceps');
            createMuscleCapsule(shoulderR, elbowR, 5, 'Biceps');

            // Triceps? (Hard to overlap solids nicely without looking weird, so we treat Upper Arm as one mass for visual, or try to offset)
            // Let's try thickening the arm and splitting?
            // For Solid, clean look -> One capsule for Upper Arm is best, mapped to both?
            // Or two thinner capsules side by side?
            // Let's do Biceps only for now as requested.

            // Forearms
            createMuscleCapsule(elbowL, handL, 4, 'Forearms');
            createMuscleCapsule(elbowR, handR, 4, 'Forearms');

            // Legs
            // Quads
            createMuscleCapsule(hipL, kneeL, 7, 'Quads');
            createMuscleCapsule(hipR, kneeR, 7, 'Quads');

            // Calves
            createMuscleCapsule(kneeL, new THREE.Vector3(-xFoot, 5, 5), 5, 'Calves');
            createMuscleCapsule(kneeR, new THREE.Vector3(xFoot, 5, 5), 5, 'Calves');
        }

        function animate() {
            requestAnimationFrame(animate);
            group.rotation.y += 0.005;
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>