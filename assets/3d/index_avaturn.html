<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Avaturn Viewer</title>
    <style>
        body {
            margin: 0;
            background-color: #EEE;
            overflow: hidden;
            font-family: sans-serif;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script type="module">
        import * as THREE from './three.module.js';
        import { GLTFLoader } from './GLTFLoader.js';
        import { OrbitControls } from './OrbitControls.js';
        import { RoomEnvironment } from './RoomEnvironment.js';

        let camera, scene, renderer, model, controls;
        window.muscleMeshes = {}; // Store references to meshes by muscle name

        // --- MUSCLE MAPPING CONFIG ---
        // Approximate offsets/scales for standard Mixamo/ReadyPlayerMe/Avaturn skeletons
        const muscleMap = [
            // Arms
            { name: 'Biceps', bone: 'RightArm', offset: [0, 0.15, 0.05], scale: [0.09, 0.15, 0.09] },
            { name: 'Biceps', bone: 'LeftArm', offset: [0, 0.15, 0.05], scale: [0.09, 0.15, 0.09] },
            { name: 'Triceps', bone: 'RightArm', offset: [0, 0.15, -0.05], scale: [0.09, 0.15, 0.09] },
            { name: 'Triceps', bone: 'LeftArm', offset: [0, 0.15, -0.05], scale: [0.09, 0.15, 0.09] },
            { name: 'Forearms', bone: 'RightForeArm', offset: [0, 0.15, 0], scale: [0.07, 0.2, 0.07] },
            { name: 'Forearms', bone: 'LeftForeArm', offset: [0, 0.15, 0], scale: [0.07, 0.2, 0.07] },

            // Legs
            { name: 'Quads', bone: 'RightUpLeg', offset: [0, 0.2, 0.05], scale: [0.12, 0.25, 0.12] },
            { name: 'Quads', bone: 'LeftUpLeg', offset: [0, 0.2, 0.05], scale: [0.12, 0.25, 0.12] },
            { name: 'Hamstrings', bone: 'RightUpLeg', offset: [0, 0.2, -0.05], scale: [0.12, 0.25, 0.12] },
            { name: 'Hamstrings', bone: 'LeftUpLeg', offset: [0, 0.2, -0.05], scale: [0.12, 0.25, 0.12] },
            { name: 'Calves', bone: 'RightLeg', offset: [0, 0.2, -0.02], scale: [0.08, 0.2, 0.08] },
            { name: 'Calves', bone: 'LeftLeg', offset: [0, 0.2, -0.02], scale: [0.08, 0.2, 0.08] },
            { name: 'Glutes', bone: 'Hips', offset: [0.1, 0.05, -0.1], scale: [0.15, 0.15, 0.1] }, // Right Glute approx
            { name: 'Glutes', bone: 'Hips', offset: [-0.1, 0.05, -0.1], scale: [0.15, 0.15, 0.1] }, // Left Glute approx

            // Torso
            { name: 'Chest', bone: 'Spine2', offset: [0, 0.15, 0.12], scale: [0.25, 0.2, 0.1] },
            { name: 'Abs', bone: 'Spine', offset: [0, 0.1, 0.1], scale: [0.2, 0.25, 0.1] },
            { name: 'Upper Back', bone: 'Spine2', offset: [0, 0.2, -0.05], scale: [0.25, 0.25, 0.05] },
            { name: 'Lats', bone: 'Spine1', offset: [0, 0.2, -0.05], scale: [0.35, 0.3, 0.1] },

            // Shoulders
            { name: 'Shoulders', bone: 'RightShoulder', offset: [0, 0, 0], scale: [0.12, 0.12, 0.12] },
            { name: 'Shoulders', bone: 'LeftShoulder', offset: [0, 0, 0], scale: [0.12, 0.12, 0.12] },
        ];


        init();
        animate();

        function init() {

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.setClearColor(0xEEEEEE); // Light grey/white bg to match app theme
            document.body.appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.2, 2.5);

            scene = new THREE.Scene();
            // scene.background = new THREE.Color(0xEEEEEE); // Let alpha handle it or set specific

            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

            const ambient = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambient);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(2, 5, 5);
            scene.add(dirLight);

            const loader = new GLTFLoader();

            loader.load('model.glb', function (gltf) {
                model = gltf.scene;
                window.model = model;
                scene.add(model);

                // Auto-fit logic
                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());

                // Center model
                model.position.x += (model.position.x - center.x);
                model.position.y += (model.position.y - center.y);
                model.position.z += (model.position.z - center.z);

                // Scale to fit ~1.8m roughly or unit scale
                const maxDim = Math.max(size.x, size.y, size.z);
                if (maxDim > 0) {
                    const scale = 1.8 / maxDim;
                    model.scale.setScalar(scale);
                }

                // --- BUILD MUSCLE HIGHLIGHTS ---
                model.traverse(child => {
                    if (child.isBone) {
                        // Find all configs that map to this bone
                        const configs = muscleMap.filter(m => child.name.includes(m.bone));
                        configs.forEach(config => {
                            createHighlight(child, config);
                        });
                    }
                });

            }, undefined, function (error) {
                console.error(error);
            });

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, 0);
            controls.enableDamping = true;
            controls.minDistance = 1;
            controls.maxDistance = 5;

            window.addEventListener('resize', onWindowResize);
        }

        function createHighlight(bone, config) {
            // Use sphere or capsule? Sphere is easier for now.
            const geometry = new THREE.SphereGeometry(1, 16, 16);
            const material = new THREE.MeshBasicMaterial({
                color: 0xff4400,
                transparent: true,
                opacity: 0,
                depthTest: false // Show through body ("X-Ray")
            });
            const mesh = new THREE.Mesh(geometry, material);

            // Apply Transforms
            mesh.scale.set(config.scale[0], config.scale[1], config.scale[2]);
            mesh.position.set(config.offset[0], config.offset[1], config.offset[2]);

            bone.add(mesh);

            // Register in map
            if (!window.muscleMeshes[config.name]) {
                window.muscleMeshes[config.name] = [];
            }
            window.muscleMeshes[config.name].push(mesh);
        }

        // --- PUBLIC API ---
        window.setMuscleHeatmap = function (heatmap) {
            // Reset
            for (const name in window.muscleMeshes) {
                // Dim down (or hide completely)
                window.muscleMeshes[name].forEach(m => {
                    m.material.opacity = 0;
                });
            }

            // Apply
            for (const muscle in heatmap) {
                const intensity = heatmap[muscle];
                if (window.muscleMeshes[muscle] && intensity > 0) {
                    window.muscleMeshes[muscle].forEach(m => {
                        m.material.opacity = 0.5 * intensity; // Semi-transparent glow

                        // Hot color lerp
                        const color = new THREE.Color().lerpColors(
                            new THREE.Color(0xffaa00),
                            new THREE.Color(0xff0000),
                            intensity
                        );
                        m.material.color.copy(color);
                    });
                }
            }
        };

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>